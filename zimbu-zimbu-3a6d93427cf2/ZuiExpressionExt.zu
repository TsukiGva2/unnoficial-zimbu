#
# The Zimbu compiler written in Zimbu
#
# Extension to the Zui.Expression message.
#
# Copyright 2014 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO parser/zui.proto

IMPORT ClassType.zu
IMPORT CodeProperties.zu
IMPORT Conversion.zu
IMPORT Declaration.zu
IMPORT SContext.zu
IMPORT SymUse.zu
IMPORT Type.zu

CLASS ZuiExpressionExt GROWS Zui.Expression @items=public
  int            $undefined = 81
  Type           $leftExprType
  Type           $rightExprType
  Type           $resultType
  Type           $noAllocType
  Declaration    $initDecl  # used for a callback method
  Declaration    $decl
  Conversion     $conversion
  ClassType      $retClass
  string         $toplevelVar
  Declaration    $tempDecl
  CodeProperties $props
  SymUse         $symUse

  # Get a SymUse object for this expression.  It's allocated on the first
  # call, and when the scope changes.
  FUNC $getSymUse(Zui.Expression expr, SContext ctx) SymUse
    IF $symUse == NIL || ctx.scope ISNOT $symUse.ctx.scope
      $symUse = NEW(expr.getPos(), ctx)
    }
    RETURN $symUse
  }

  SHARED

    # Set expr.undefined from the lhs.undefined and rhs.undefined. 
    PROC setUndefined(Zui.Expression expr)
      ZuiExpressionExt exprExt = expr
      exprExt.undefined = 0
      IF expr.hasLeft()
        exprExt.undefined += expr.getLeft().<ZuiExpressionExt>.undefined
      }
      IF expr.hasRight()
        exprExt.undefined += expr.getRight().<ZuiExpressionExt>.undefined
      }
      IF expr.hasCond()
        exprExt.undefined += expr.getCond().<ZuiExpressionExt>.undefined
      }
    }

    # For debugging: recursively report undefined count.
    PROC reportUndefined(string what, Zui.Expression expr)
      IO.print("\(what): \(expr.getType()) \(expr.<ZuiExpressionExt>.undefined)")
      IF expr.hasLeft()
        reportUndefined(what .. "-left", expr.getLeft())
      }
      IF expr.hasRight()
        reportUndefined(what .. "-right", expr.getRight())
      }
      IF expr.hasCond()
        reportUndefined(what .. "-cond", expr.getCond())
      }
      IF expr.hasMethodCall()
        reportUndefined(what .. "-call", expr.getMethodCall())
      }
    }

    PROC reportUndefined(string what, Zui.MethodCall call)
      reportUndefined(what .. "-name", call.getName())
      FOR arg IN call.getArgumentList()
        reportUndefined(what .. "-arg", arg)
      }
    }

  }
}
