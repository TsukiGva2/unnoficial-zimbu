#
# Main file of the Zimbu compiler driver.
#
# This is intentionally a separate, small program, so that when running the C
# compiler and executing the binary the memory used by the actual compiler has
# been released.  That matters a lot when doing fork().
#
# Usage:
#      zimbu {file}.zu         Compile {file}.zu
#      zimbu {file}.zu -x      Compile {file}.zu and run it
#      zimbu test {tests}.zu   Compile {tests}.zu and run tests
#
# Options:
#      -o {prog}       Store executable as {prog}
#      -x [arg ...]    Execute the compiled program
#      -cc {compiler}  Use {compiler} for the C compiler
# Options passed on to zimbu2c:
#      -q              Quick - do not generate a stack backtrace
#      -d              Debug mode
#      --profalloc     Profile memory allocations
#      -v              Verbose
#      -vv             Very verbose
#      -z              don't check for undefined symbols
#      --manage        Manage memory
#      --keepunused    Do write unused items.
#
# And later:
#      zimbu                          Execute build commands in ZIMBU file
#      zimbu BUILD                    Execute build commands in BUILD file
#
# Copyright 2009 Bram Moolenaar  All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# The License can be found it in the LICENSE file, or you may obtain a copy of
# the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.
#

IMPORT Arguments.zu
IMPORT CommonFlags.zu
IMPORT Config.zu
IMPORT TargetLang.zu

ARG.StringList execute = NEW("x", "execute", [],
                             "Execute the program after compiling it "
                                .. "(must come last)")
                          .setArgName("arg")
ARG.Bool forceCompileFlag = NEW("f", "force", FALSE,
                  "Force compilation even if source is older than executable")


ARG.String progname = NEW("o", "output", "", "Name for the produced program")
                          .setArgName("progname")
ARG.String zimbu = NEW(NIL, "zimbu", "", "Name for the zimbu2c program")
                          .setArgName("zimbuname")
ARG.String interpreter = NEW(NIL, "interpreter", "nodejs",
                                 "Interpreter that runs the produced program")
                          .setArgName("interpreter")


FUNC Main() int
  TargetLang targetLang = Arguments.getTargetLang()
  Arguments.parse(targetLang)

  string rootName
  string progName
  string exeSuffix = targetLang.js ? ".js"
                                : targetLang.java ? ".class" : Config.exeSuffix
  IF progname.present()
    rootName = progname.get()
    progName = rootName
    IF Config.exeSuffix != ""
                          && !progName.toLower().endsWith(exeSuffix.toLower())
      progName ..= exeSuffix
    }
  ELSE
    rootName = Arguments.rootName
    progName = rootName .. exeSuffix
  }

  # Compile the .zu file in one of these cases:
  # - There is no -x flag
  # - There is a -f flag
  # - There is a -x flag and the source is older than the executable
  bool build
  IF !execute.present() || forceCompileFlag.present()
    build = TRUE
  ELSE
    IO.FileInfo inFileInfo = IO.fileInfo(Arguments.inFileName)
    IO.FileInfo progNameInfo = IO.fileInfo(progName)
    build = inFileInfo.time > progNameInfo.time
  }

  int retval = 0
  IF build
    # STEP 1: Run zimbu2c to convert {file}.zu to ZUDIR/{file}.c.

    string cmd
    IF zimbu.present()
      # Use the command line argument for zimbu2c.
      cmd = zimbu.get()
    ELSE
      # The zimbu2c executable name is the same as this executable.
      # some/path/zimbu -> some/path/zimbu2c
      # some/path/zimbu.exe -> some/path/zimbu2c.exe
      # path/zimbu_test_test -> path/zimbu_test_test2c
      # path/zimbu_test -> path/zimbu_test2c
      string zimbu2c = "zimbu2c"
      IF ARG.exeName.find("zimbu_test_test") >= 0
        zimbu2c = "zimbu_test_test2c"
      ELSEIF ARG.exeName.find("zimbu_test") >= 0
        zimbu2c = "zimbu_test2c"
      }
      cmd = IO.modifyExeName(ARG.exeName, zimbu2c)
      IF cmd.find(' ') >= 0
        # Command contains a space, put it in quotes.
        cmd = "\"\(cmd)\""
      }
    }

    # Pass on relevant arguments.
    cmd ..= CommonFlags.getArguments()

    retval = SYS.shell(cmd)

    IF retval == 0
      # Even when the command failed the exit value may be zero, check that the
      # C or JS file was actually generated.
      IO.FileInfo fileInfo = IO.fileInfo(Arguments.outFileName)
      IF fileInfo.status == FAIL || fileInfo.size == 0
        IO.print("ERROR: \(targetLang.js ? "Javascript" : targetLang.java ? "Java" : "C") program not written")
        retval = 1
      }
    ELSE
      # Avoid retval 256, make sees it as zero.
      retval = 1
    }

    IF retval == 0 && !targetLang.js
      #
      # STEP 2: Compile the produced C or Java code.
      string compilerResult = progName

      IF targetLang.java
        # Delete any existing matching Java .class files: ZUDIR/prog*.class
        FOR f IN matchingClasses(TRUE)
          IO.delete(f)
        }

        # We'll produce the main prog.class file in ZUDIR.
        compilerResult = IO.concatPath(Arguments.zudirName,
                                               Arguments.rootTail .. ".class")
      }

      # Not all compilers return a non-zero value for failure.
      # Delete the binary and check that it was updated and has some size.
      IO.delete(compilerResult)
      IO.FileInfo before = IO.fileInfo(compilerResult)
      string compilerCmd = Config.compilerCmd(Arguments.outFileName,
                                                         progName, targetLang)

      IF targetLang.c
        # Read the .eca file and append it to the compiler command (omitting
        # line breaks).
        # Libraries must come last, the compiler may only pick up methods that
        # were used in the srcName.
        compilerCmd ..= IO.readFile(Arguments.ecaFileName).replaceAll('\n', ' ')

        # Add the tcmalloc library if zimbuConfig could find it.
        IF Config.mallocArg != NIL
          compilerCmd ..= " " .. Config.mallocArg
        }
      }

      LOG.info("Executing compiler: \(compilerCmd)")
      retval = SYS.shell(compilerCmd)

      IO.FileInfo after = IO.fileInfo(compilerResult)
      IF after.size == 0
        LOG.error("Compiled program \(compilerResult) is zero size")
        retval = 1
      ELSEIF before.size == after.size && before.time == after.time
        LOG.error("Compiled program \(compilerResult) was not updated")
        retval = 1
      ELSEIF retval != 0
        # Avoid retval 256, make sees it as zero.
        retval = 1
      }
    }

    IF retval == 0 && targetLang.java
      # pack the ZUDIR/prog*.class files into prog.jar
      string jarCmd = Config.jarCmd(rootName, matchingClasses(FALSE))
      LOG.info("Packing jar archive: \(jarCmd.slice(0, 60))...")
      retval = SYS.shell(jarCmd)
    }
  }

  #
  # STEP 3: Execute the program if "-x" was given.
  #         Or run the tests for "zimbu test".
  #
  IF retval == 0 && (execute.present() || Arguments.testMode)
    IO.StringWriter sw = NEW()
    IF interpreter.present()
      sw.write(interpreter.get())
      sw.write(" ")
    }

    IF targetLang.java
      sw.write(" -cp \(rootName).jar \(rootName)")
    ELSE
      IF progName[0] != '/'
        sw.write(Config.exePrefix)
      }
      sw.write(progName)
    }

    FOR arg IN execute.get()
      # TODO: better escaping
      sw.write(" '\(arg)'")
    }
    string cmd = sw.ToString()

    LOG.info("\(Arguments.testMode ? "Running tests" : "Executing program"): \(cmd)")
    retval = SYS.shell(cmd)
    IF retval != 0
      # Avoid retval 256, make sees it as zero.
      retval = 1
    }
  }

  RETURN retval
}

# Return the list of .class files matching the compiled program.
FUNC matchingClasses(bool withDir) list<string>
  list<string> l = NEW()
  FOR f IN IO.dirList(Arguments.zudirName)
    IF f.contains(".class")
      int rootIdx = f.find(Arguments.rootTail)
      IF rootIdx == 0 || (rootIdx > 0 && f[rootIdx - 1] == '/')
        IF withDir
          l.add(IO.concatPath(Arguments.zudirName, f))
        ELSE
          l.add(f)
        }
      }
    }
  }
  RETURN l
}
