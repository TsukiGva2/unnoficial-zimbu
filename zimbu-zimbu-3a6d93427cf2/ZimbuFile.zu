#
# The Zimbu compiler written in Zimbu
#
# ZimbuFile class: A Zimbu file that can be (or has been) parsed.
#                  Does not contain info about where it was imported, see
#                  UsedFile for that.
#
# Copyright 2009 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO parser/zui.proto

IMPORT Builtin.zu
IMPORT CommonFlags.zu
IMPORT Config.zu
IMPORT Declaration.zu
IMPORT FileScope.zu
IMPORT MethodScope.zu
IMPORT Output.zu
IMPORT Resolve.zu
IMPORT UsedFile.zu
IMPORT ZuiDeclarationExt.zu

CLASS ZimbuFile @items=public   # TODO: restrict visibility
  string $filename     # file name relative to build directory
  string $fullname     # file name with full path
  string $rootName     # |filename| with directory and ".zu"/".zwt" removed
  string $dirName      # directory relative to build directory

  string $outDir       # where to write the output
  string $initFunc     # name of function that inits global vars

  int    $startedPass  # pass number that started (and may have ended)
  bool   $didInitFunc  # set when generated call to initFunc

  bool   $isMainFile    # TRUE for main file; should contain Main()
  bool   $isTestFile    # was used with IMPORT.TEST
  bool   $topZwtFile    # was used in IMPORT.ZWT
  bool   $usedAsZwt     # was used in IMPORT.ZWT or imported through it
  bool   $usedAsZimbu   # was used in IMPORT
  bool   $isProto       # converted from a .proto file

  # Scope for the file level, contains the list of statements.
  FileScope  $fileScope

  # Scope used for the initialization function.  Stores temp variables used in
  # initialization expressions.
  MethodScope $initScope

  Declaration $item    # The one item that this file exports.
                       # NIL when there is not exactly one item.

  # Keep track of which TokenType.id keywords have been used in this file.
  # Set just after parsing.
  # This is for loading a built-in library only when it is used.
  set<string> $usedIdKeywords

  CodeSpecific    $c     # C specific values
  CodeSpecific    $js    # JS specific values
  CodeSpecific    $java  # Java specific values

  Zui.Contents    $contents         # Contents from the .zu file

  NEW(string filename, bool isMainFile)
    $filename = filename
    IF $filename.startsWith("./")
      $filename = $filename.slice(2)
    }
    $fullname = IO.fullPath(filename)
    $isMainFile = isMainFile

    IF $filename.sliceWrap(-3) == ".zu"
      $rootName = $filename.sliceWrap(0, -4)  # without ".zu"
    ELSE
      LOG.error("File not ending in .zu: \($filename)")
    }
    int slash = $rootName.findLast('/')
    IF slash >= 0
      $dirName = $rootName.slice(0, slash - 1)
      $rootName = $rootName.slice(slash + 1)
    ELSE
      $dirName = ""
    }

    # Set the directory to store the produced files.
    IF $dirName != ""
      $outDir = $dirName .. "/" .. Config.zudirName
      IF $outDir.startsWith("./")
        $outDir = $outDir.slice(2)
      }
    ELSE
      $outDir = Config.zudirName
    }

    # TODO: use varString?
    string root = "INC_"
    # Include directory name, replace every "/" with "__"
    int idx
    WHILE idx < $dirName.Size()
      slash = $dirName.find('/', idx)
      IF slash < 0
        root ..= $dirName.slice(idx) .. "__"
        BREAK
      }
      IF slash == 0
        root ..= "__"
      ELSE
        # TODO: including ".." as "dd__" causes trouble when compiling
        # different binaries that use the proto plugin.
        string s = $dirName.slice(idx, slash - 1)
        IF s != ".."
          root ..= s .. "__"
        }
      }
      idx = slash + 1
    }
    root ..= $rootName

    # Identifiers start with "I", use "J" to be unique.
    $initFunc = "J" .. $rootName
    $startedPass = -1  # didn't start any pass yet (parsing is 0)
    $c = NEW()
    $js = NEW()
    $java = NEW()
  }


  #= Return the name of the .zui file.
  FUNC $zuiName() string
    RETURN $outDir .. "/" .. $rootName .. ".zui"
  }

  # Parse the file, unless done already.
  # Return FAIL if the file could not be read.
  FUNC $parse(string indent, UsedFile usedFile) status
    IF $startedPass == -1
      $startedPass = 0
      $fileScope = FileScope.parseFile($filename, indent, usedFile)
    }
    RETURN $fileScope == NIL ? FAIL : OK
  }

  # Return the name of the top module in this file.
  # If not found returns NIL.
  FUNC $getModuleName() string
    Zui.Statement stmt = $getModuleStatement()
    IF stmt == NIL
      RETURN NIL
    }
    RETURN stmt.getDeclaration().getName()
  }

  # Find the node in this file that is the top module.
  # If not found gives an error and returns NIL.
  FUNC $getModuleStatement() Zui.Statement
    RETURN $getDeclarationStatement(TRUE)
  }

  # Find the node in this file that is the top module or class.
  # If not found gives an error and returns NIL.
  FUNC $getDeclarationStatement(bool moduleOnly) Zui.Statement
    # Find the module after IMPORT statements.
    FOR stmt IN $fileScope.statements ?: []
      IF stmt.getType() == Zui.StatementType.eMODULE_DECL
           || (!moduleOnly && stmt.getType() == Zui.StatementType.eCLASS_DECL)
        RETURN stmt
      }
    }
    LOG.error("No Module found in import")
    RETURN NIL
  }

  FUNC $hasUsedItem(Resolve gen, string indent) bool
    bool typeUsed
    FOR stmt IN $fileScope.statements ?: []
      IF stmt.getType() == Zui.StatementType.eMODULE_DECL
          || stmt.getType() == Zui.StatementType.eCLASS_DECL
          || stmt.getType() == Zui.StatementType.eBITS_DECL
          || stmt.getType() == Zui.StatementType.eENUM_DECL
          || stmt.getType() == Zui.StatementType.eMETHOD_DECL
        Zui.Declaration zuiDecl = stmt.getDeclaration()
        ZuiDeclarationExt declExt = zuiDecl
        # A PIECE does not have a declaration, since it's copied to where it
        # is used.
        IF declExt.decl != NIL
          IF gen.isDeclUsed(declExt.decl)
            RETURN TRUE
          }
          IF declExt.decl.typeUsed
            typeUsed = TRUE
          }
        }
      }
    }
    IF typeUsed
      LOG.info("\(indent)\($filename): Only type is used")
    ELSE
      LOG.info("\(indent)\($filename): No used items")
    }

    # When the type was used do go into the item anyway.
    RETURN typeUsed
  }

  SHARED

    CLASS CodeSpecific @directory @items=directory
      bool          $startedWrite  # writing has started
      Output.Group  $outputs

      NEW()
        $clear()
      }

      PROC $clear()
        $outputs = NEW()
      }
    }

    # Find |name| in |importList|.
    FUNC find(list<ZimbuFile> importList, string name) ZimbuFile
      IF importList != NIL
        string fullname = IO.fullPath(name)
        FOR import IN importList
          IF import.fullname == fullname
            RETURN import
          }
        }
      }
      RETURN NIL
    }

  }

  SHARED

    FUNC isParentExpr(Zui.Expression expr) bool
      RETURN expr.getType() == Zui.ExprType.ePARENT
          || (expr.getType() == Zui.ExprType.eMEMBER
              && expr.getRight().getType() == Zui.ExprType.eID
              && expr.getRight().getName() == "PARENT")
    }

    # For an expression that is an ID or a member with IDs, return the string
    # to display for it in messages.
    FUNC expr2String(Zui.Expression expr) string
      SWITCH expr.getType()
        CASE Zui.ExprType.eID
          RETURN expr.getName()
        CASE Zui.ExprType.eMEMBER
          RETURN expr2String(expr.getLeft())
                                        .. "." .. expr2String(expr.getRight())
        CASE Zui.ExprType.eTYPESPEC
          string s = expr2String(expr.getLeft()) .. "<"
          IF expr.hasTypespec()
            # check the typespec arguments: list<Titem>
            string comma = ""
            FOR type IN expr.getTypespecList()
              s ..= comma
              s ..= expr2String(type.getName())
              comma = ", "
            }
          }
          RETURN s .. ">"
        DEFAULT
          # TODO: this is ugly
          RETURN expr.ToString()
      }
      RETURN ""
    }
  }
}
