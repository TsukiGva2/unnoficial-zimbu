#
# Main file of the Zimbu compiler written in Zimbu.
#
# This reads .zu files (and files imported through plugins) and procudes C
# and/or Javascript code.
#
# Usage:
#      zimbu2c {file}.zu    Compile {file}.zu to {file}.c
#
# Options:
#      -d              Debug mode
#      -q              Quick - no stack backtrace
#      -v              Verbose
#      -z              don't check for undefined symbols
#
# Copyright 2009 Bram Moolenaar  All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# The License can be found it in the LICENSE file, or you may obtain a copy of
# the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.
#

IMPORT Arguments.zu
IMPORT Builtin.zu
IMPORT CommonFlags.zu
IMPORT Config.zu
IMPORT MainFile.zu
IMPORT TargetLang.zu
IMPORT ZimbuFile.zu

FUNC Main() int
  TargetLang targetLang = Arguments.getTargetLang()
  Arguments.parse(targetLang)

  IO.mkdir(Arguments.zudirName)  # ignore returned status

  # Prepare for defining builtin modules.  A builtin module is only processed
  # when used.
  Builtin.prepare()

  # Try opening the output file now.  It's pointless to start parsing if we
  # can't write the result.
  IO.File outFile = IO.fileWriter(Arguments.outFileName)
  IF outFile == NIL
    LOG.fatal("Cannot open file for writing: \(Arguments.outFileName)")
  }

  # Also open the file for Extra Compiler Arguments.
  IO.File ecaFile
  IF targetLang.c
    ecaFile = IO.fileWriter(Arguments.ecaFileName)
    IF ecaFile == NIL
      LOG.fatal("Cannot open file for writing: \(Arguments.ecaFileName)")
    }
    DEFER ecaFile.close()
  }

  #
  # STEP 1: Read the main .zu file and imported files, parse and resolve
  # symbols.
  #

  # Parse the main .zu file.
  MainFile %mainFile = NEW(Arguments.inFileName)
  IF %mainFile.parse() == FAIL
    LOG.fatal("Cannot open file for reading: \(Arguments.inFileName)")
  }
  IF !Arguments.testMode && !%mainFile.hasMain()
    LOG.fatal("No Main() found in \(Arguments.inFileName)")
  }

  # Only when there are no parse errors it makes sense to do more work.
  IF LOG.errorCount == 0
    # Recursively parse imported files.
    %mainFile.parseImports()

    #
    # Resolve symbols.  This recursively enters imported files.
    # Repeat this until they are all defined or no more can be resolved.
    #
    DO
      bool doPass = %mainFile.resolve()
    UNTIL !doPass || LOG.errorCount > 0
  }

  IF LOG.errorCount == 0
    IF targetLang.js
      # Produce a Javascript program
      %mainFile.generateJS(Arguments.inFileName, outFile)
    ELSEIF targetLang.java
      # STEP 2 + 3: Produce Java code from the parse tree and write it to
      # outFile, give errors for unresolved symbols.
      %mainFile.generateJava(Arguments.inFileName, outFile)
    ELSE
      # STEP 2 + 3: Produce C code from the parse tree and write it to
      # outFile, give errors for unresolved symbols.
      %mainFile.generateC(Arguments.inFileName, outFile)
    }
    IF !targetLang.js
      # Produce any JS code for ZUT modules.
      # This is written to separate files.
      %mainFile.generateZUT()
    }
  }

  outFile.close()

  IF LOG.errorCount == 0 && targetLang.c
    # Write the Extra Compiler Arguments into the .eca file.
    ecaFile.print(Config.extraCompilerArgs())
  }

  IF LOG.isVerbose()
    # Dump info about garbage collection.
    GC.writeRunInfo(IO.stdout)
  }

  RETURN LOG.errorCount > 0 ? 1 : 0
}
