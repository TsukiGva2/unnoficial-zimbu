#
# The Zimbu compiler written in Zimbu
#
# Class to store information about functions that write code.
#
# Copyright 2015 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT DeclStore.zu
IMPORT Declaration.zu
IMPORT Resolve.zu
IMPORT genC/WriteC.zu
IMPORT genJS/WriteJS.zu
IMPORT genJava/WriteJava.zu

# A function to write code when $decl is marked as used.
# Can be used for C, JS or Java, not mixed.
CLASS CodeWriter @items=public
  # Conditional dependency: Only when $cond is used the $dep is marked as
  # used.  The $stringDep pair can be used to find a Declaration after the
  # first pass.
  CLASS CondDepend @items=public
    Declaration      $cond
    Declaration      $dep
    list<string>     $stringDep     # To be assigned to $dep with
                                    # DeclStore.getDecl()
  }

  Declaration.C           $decl         # produce when this is marked as used.
  list<Declaration>       $dependencies # optional: what the fragment
                                        # depends on
  list<list<string>>      $stringDeps   # To be added to $dependencies with
                                        # DeclStore.getDecl()

  list<CondDepend>        $condDeps     # Conditional dependencies
  proc<WriteC, IO.File>   $produce      # method to write the C fragment
  proc<WriteJS, IO.File>  $produceJS    # method to write the JS fragment
  proc<WriteJava, IO.File> $produceJava # method to write the Java fragment
  string                  $typedef      # optional: typedef
  string                  $declString   # optional: function or structure
                                        # definition
  proc<WriteC, IO.File>   $produceDecl  # method to write the C declaration
  proc<WriteJS, IO.File>  $produceJSDecl  # method to write the JS declaration
  proc<WriteJava, IO.File> $produceJavaDecl # method to write the Java decl.
  list<func< => bool>>    $condFuncs    # functions that must return TRUE
                                        # for the fragment to be produced.

  NEW(Declaration.C decl, proc<WriteC, IO.File> proc)
    $decl = decl
    $produce = proc
  }

  NEW(Declaration.C decl, proc<WriteJS, IO.File> proc)
    $decl = decl
    $produceJS = proc
  }

  NEW(Declaration.C decl, proc<WriteJava, IO.File> proc)
    $decl = decl
    $produceJava = proc
  }

  NEW(Declaration.C decl)
    $decl = decl
  }

  # TODO: remove once no longer used.
  FUNC $setDependencies(list<Declaration.C> dependencies) CodeWriter
    # TODO: can we avoid making a copy?
    $dependencies = NEW()
    FOR d IN dependencies
      $dependencies.add(d)
    }
    RETURN THIS
  }

  FUNC $setDependencies(list<Declaration> dependencies) CodeWriter
    $dependencies = dependencies
    RETURN THIS
  }

  FUNC $setDependencies(list<list<string>> stringDeps) CodeWriter
    $stringDeps = stringDeps
    RETURN THIS
  }

  FUNC $addCondDepends(Declaration cond, list<string> dep) CodeWriter
    IF $condDeps == NIL
      $condDeps = NEW()
    }
    CondDepend cd = NEW()
    cd.cond = cond
    cd.stringDep = dep  # cd.dep will be set later
    $condDeps.add(cd)
    RETURN THIS
  }

  FUNC $addCondDepends(Declaration cond, Declaration dep) CodeWriter
    IF $condDeps == NIL
      $condDeps = NEW()
    }
    CondDepend cd = NEW()
    cd.cond = cond
    cd.dep = dep
    $condDeps.add(cd)
    RETURN THIS
  }

  # Add a function that returns TRUE when this code is to be written.
  FUNC $addCondFunc(func< => bool> f) CodeWriter
    IF $condFuncs == NIL
      $condFuncs = NEW()
    }
    $condFuncs.add(f)
    RETURN THIS
  }

  # Set the C typedef to be written.
  FUNC $setTypedef(string typedef) CodeWriter
    $typedef = typedef
    RETURN THIS
  }

  # Set the C declaration to be written.
  FUNC $setDecl(string decl) CodeWriter
    $declString = decl
    RETURN THIS
  }

  # Set a method to write the C declaration.
  FUNC $setProduceDecl(proc<WriteC, IO.File> proc) CodeWriter
    $produceDecl = proc
    RETURN THIS
  }

  # Set a method to write the JS declaration.
  FUNC $setProduceDecl(proc<WriteJS, IO.File> proc) CodeWriter
    $produceJSDecl = proc
    RETURN THIS
  }

  # Set a method to write the Java declaration.
  FUNC $setProduceDecl(proc<WriteJava, IO.File> proc) CodeWriter
    $produceJavaDecl = proc
    RETURN THIS
  }

  # Return TRUE if the declaration is used AND all the functions added with
  # $addCondFunc() return TRUE.
  FUNC $isUsed(Resolve gen) bool
    IF !gen.isDeclUsed($decl)
      RETURN FALSE
    }
    FOR f IN $condFuncs
      IF !f()
        RETURN FALSE
      }
    }
    RETURN TRUE
  }

  SHARED

    PROC addDependencies(list<CodeWriter> codeWriters, Resolve.I gen)
      FOR writer IN codeWriters
        # Add dependencies defined by name of module and method.  These can
        # only be found after resolving symbols.
        IF writer.stringDeps != NIL
          IF writer.dependencies == NIL
            writer.dependencies = NEW()
          }
          FOR dep IN writer.stringDeps
            writer.dependencies.add(DeclStore.getDecl(dep[0], dep[1]))
          }
        }

        IF writer.dependencies != NIL
          gen.setDeclDependency(writer.decl, writer.dependencies)
        }

        IF writer.condDeps != NIL
          FOR cd IN writer.condDeps
            IF cd.dep == NIL
              cd.dep = DeclStore.getDecl(cd.stringDep[0], cd.stringDep[1])
            }
            gen.setDeclCondDependency(writer.decl, cd.cond, cd.dep)
          }
        }
      }
    }

  }
}

