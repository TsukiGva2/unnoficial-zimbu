#
# The Zimbu compiler written in Zimbu
#
# Java implementation for List.
#
# Copyright 2009-2012 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO ../parser/zui.proto

IMPORT ../CodeWriter.zu
IMPORT ../ContainerType.zu
IMPORT ../Conversion.zu
IMPORT ../DeclStore.zu
IMPORT ../Declaration.zu
IMPORT ../Generate.zu
IMPORT ../ListStuff.zu
IMPORT ../SContext.zu
IMPORT ../Type.zu
IMPORT ../ZuiExpressionExt.zu
IMPORT WriteJava.zu

MODULE WriteListJava @public @items=public      # TODO: restrict visibility

  # [item1, item2]  ->  [item1, item2]
  # |destType| is the type of a list item (may be NIL).
  # Only called when actually generating code
  FUNC newListWithInit(Zui.Expression expr, Type destType, SContext ctx) Type
    ZuiExpressionExt exprExt = expr

    Type type = destType
    IF expr.sizeListItem() > 0
      IF exprExt.resultType ISA ContainerType
        # Get the type from the resolve pass.
        type = exprExt.resultType.<ContainerType>.itemType
      ELSE
        # Get the type from the first item.
        type = Generate.genExpr(expr.getListItem(0), ctx.copyNoOut(), destType)
      }
    }

    ctx.out.write("new ZList<")
    ctx.gen.<WriteJava>.vartype(type, FALSE, TRUE, expr.getPos(), ctx)
    ctx.out.write(">(")
    ctx.out.write(WriteJava.getTypeName(type, ctx))
    ctx.out.write(")")

    IF expr.sizeListItem() > 0
      # For types smaller than int mask off the bits that shouldn't be there,
      # since we actually use an int.
      int mask
      int min
      int max
      bool int32
      bool nat32
      SWITCH type.getTtype()
        CASE Type.Enum.int8
          min = -128
          max = 127
          mask = 255
        CASE Type.Enum.byte
          mask = 255
        CASE Type.Enum.int16
          min = -32768
          max = 32767
          mask = 65535
        CASE Type.Enum.nat16
          mask = 65535
        CASE Type.Enum.int32
          int32 = TRUE
        CASE Type.Enum.nat32
          nat32 = TRUE
      }
      FOR item IN expr.getListItemList()
        ctx.out.write(".ZLa(")
        IF (item.getType() == Zui.ExprType.eNAT
                                        || item.getType() == Zui.ExprType.eINT)
              && type.isNumberType()
              && max != 0
          int n = item.getNumber()
          IF n > max
            n = n & mask
            IF n > max
              n -= mask + 1
            }
          ELSEIF n < min
            n = -(-n & mask)
          }
          ctx.out.write(n .. "")
        ELSE
          IF mask != 0 || int32
            ctx.out.write("(")
          ELSEIF nat32
            # Logical operators don't fully work on nat32, but we can at least
            # do the truncation.
            ctx.setDeclUsed(%toNat32)
            ctx.out.write("ZtoNat32(")
          }
          Generate.genExprDoConv(item, ctx, type)
          IF int32
            # Any logical operator turns the number into a 32 bit int.
            ctx.out.write(") | 0")
          ELSEIF mask != 0
            ctx.out.write(") & \(mask)")
          ELSEIF nat32
            ctx.out.write(")")
          }
        }
        ctx.out.write(")")
      }
    }
    RETURN type
  }

  FUNC generateSubscript(ContainerType type, Zui.Expression expr, bool lvalue,
                                                 SContext ctx, Type destType
       ) Type
    # Only used when actually writing.
    IF lvalue
      # TODO: this evaluates expr twice, side effects can be a problem.
      ctx.setDeclUsed(%listGetIdx)
      ctx.out.write("(")
      Generate.genExpr(expr.getLeft(), ctx)
      ctx.out.write(").a[ZListGetIdx(")
      Generate.genExpr(expr.getLeft(), ctx)
      ctx.out.write(", ")
      Generate.genExpr(expr.getRight(), ctx, Type.anInt)
      ctx.out.write(")]")
    ELSE
      ctx.setDeclUsed(%listGet)
      ctx.out.write("ZListGet(")
      Generate.genExpr(expr.getLeft(), ctx)
      ctx.out.write(", ")
      Generate.genExpr(expr.getRight(), ctx, Type.anInt)
      ctx.out.write(")")
    }
    IF type.itemType != NIL
      RETURN type.itemType
    }
    RETURN destType
  }

  FUNC generateMethodCall(ContainerType type,
                          Zui.MethodCall call,
                          SContext ctx,
                          Type destType
                         ) Type
    Type retType
    Zui.Expression name = call.getName()
    CHECK.true(name.getType() == Zui.ExprType.eMEMBER)
    string methodName = name.getRight().getName()
    Zui.Expression objExpr = name.getLeft()
    list<Zui.Expression> argList = call.getArgumentList()

    IF methodName == "ToString"
      IF Generate.checkArgCount(call, 0, 1, ctx) != FAIL
                                                       && type.itemType != NIL
        ctx.setDeclUsed(%listToString)
        ctx.out.write("ZListToString(")
        Generate.generateVarname(objExpr, ctx, type)
        # TODO: format argument
        ctx.out.write(", 1)")
        retType = Type.aString
      }
    ELSEIF methodName == "Type"
      ctx.out.write(type.typeUsed(ctx).pName)
      ctx.out.write("__T")
      retType = Type.aType
    ELSEIF methodName == "get"
      # list.get(idx) is the same as list[idx].
      IF Generate.checkArgCount(call, 1, 1, ctx) != FAIL
        Zui.Expression expr = NEW()
        expr.setLeft(objExpr)
        expr.setRight(argList[0])
        retType = ctx.gen.subscript(expr, ctx, NIL)
      }
    ELSEIF methodName == "add" || methodName == "insert"
      # For C:
      # numberList.add(item)  ->  ZLa(numberList, -1, item, NULL)
      # numberList.add(item, i)  ->  ZLa(numberList, i, item, NULL)
      # pointerList.add(item)  ->  ZLa(pointerList, -1, 0, item)
      # pointerList.add(item, i)  ->  ZLa(pointerList, i, 0, item)
      # numberList.insert(item) -> ZListInsert(numberList, 0, item, NULL)
      # numberList.insert(item, i) -> ZListInsert(numberList, i, item, NULL)
      # pointerList.insert(item) -> ZListInsert(pointerList, 0, 0, item)
      # pointerList.insert(item, i) -> ZListInsert(pointerList, i, 0, item)
      #
      # For Java there is no difference between number and pointer:
      # list.add(item)       -> ZLa(list, -1, item)
      # list.add(item, i)    -> ZLa(list, i, item)
      # list.insert(item)    -> ZListInsert(list, 0, item)
      # list.insert(item, i) -> ZListInsert(list, i, item)
      IF Generate.checkArgCount(call, 1, 2, ctx) != FAIL
        IF methodName == "add"
          ctx.setDeclUsed(%listAdd)
          ctx.out.write("ZLa(")
        ELSE
          ctx.setDeclUsed(%listInsert)
          ctx.out.write("ZListInsert(")
        }
        Generate.generateVarname(objExpr, ctx, type)
        ctx.out.write(", ")

        # generate the index argument
        IF call.sizeArgument() > 1
          Zui.Expression arg1 = call.getArgument(1)
          Generate.genExpr(arg1, ctx, Type.anInt)
        ELSE
          IF methodName == "add"
            ctx.out.write("-1")  # add(item) appends to end of the list
          ELSE
            ctx.out.write("0")   # insert(item) inserts before start of the list
          }
        }
        ctx.out.write(", ")

        # generate the pointer or integer value
        IF type.itemType != NIL
          Zui.Expression arg0 = call.getArgument(0)
          Generate.genExpr(arg0, ctx, type.itemType)
        }

        # finish up
        ctx.out.write(")")
      }
      retType = ListStuff.newList(type)
    ELSEIF methodName == "extend" || methodName == "concat"
      # List.extend(list)
      # List.concat(list)
      IF Generate.checkArgCount(call, 1, 1, ctx) != FAIL
        ctx.setDeclUsed(%listExtend)
        IF methodName == "extend"
          ctx.out.write("ZListExtend(")
        ELSE
          ctx.setDeclUsed(%listConcat)
          ctx.out.write("ZListConcat(")
        }
        Generate.generateVarname(objExpr, ctx, type)
        ctx.out.write(", ")
        # type of both lists should be equal
        Zui.Expression arg0 = call.getArgument(0)
        Generate.genExpr(arg0, ctx, type)
        IF methodName != "extend"
          # Need to set the item type for the new list.
          IF type.itemType != NIL && !type.itemType.isValueType()
            ctx.out.write(", 1")
          ELSE
            ctx.out.write(", 0")
          }
        }
        ctx.out.write(")")
      }
      retType = ListStuff.newList(type)
    ELSEIF methodName == "clear" && call.sizeArgument() == 0
      ctx.setDeclUsed(%listClear)
      ctx.out.write("ZListClear(")
      Generate.generateVarname(objExpr, ctx, type)
      ctx.out.write(")")
      retType = ListStuff.newList(type)
    ELSEIF methodName == "find" || methodName == "has"
      IF Generate.checkArgCount(call, 1, 1, ctx) != FAIL
        IF methodName == "has"
          ctx.out.write("(")
        }
        ctx.out.write("(")
        Generate.generateVarname(objExpr, ctx, type)
        ctx.out.write(").a.indexOf(")
        Generate.genExprDoConv(call.getArgument(0), ctx, type.itemType)
        ctx.out.write(")")
        IF methodName == "has"
          ctx.out.write(">= 0)")
        }
      }
      retType = methodName == "has" ? Type.aBool : Type.anInt
    ELSEIF methodName == "remove"
           || (methodName == "clear" && call.sizeArgument() == 1)
      IF Generate.checkArgCount(call, 0, 2, ctx) != FAIL
        bool removeOne
        bool hasArg

        IF !call.hasArgument()
          # mylist.remove()
          removeOne = TRUE
        ELSEIF call.sizeArgument() == 1
          # mylist.remove(index)
          removeOne = TRUE
          hasArg = TRUE
        }

        IF removeOne
          # mylist.remove() or mylist.remove(index) or mylist.clear(index)
          ctx.setDeclUsed(%listPopItem)
          ctx.out.write("ZListPopItem(")
          Generate.generateVarname(objExpr, ctx, type)
          ctx.out.write(", ")
          IF hasArg
            Zui.Expression arg0 = call.getArgument(0)
            Generate.genExpr(arg0, ctx, Type.anInt)
          ELSE
            ctx.out.write("-1")
          }
          IF methodName == "remove"
            ctx.out.write(", 1)")
            retType = type.itemType
          ELSE
            ctx.out.write(", 0)")
            retType = type
          }
        ELSE
          # mylist.remove(start, end)
          ctx.setDeclUsed(%listPopList)
          ctx.out.write("ZListPopList(")
          Generate.generateVarname(objExpr, ctx, type)
          ctx.out.write(", ")
          Zui.Expression arg0 = call.getArgument(0)
          Generate.genExpr(arg0, ctx, Type.anInt)
          ctx.out.write(", ")
          Zui.Expression arg1 = call.getArgument(1)
          Generate.genExpr(arg1, ctx, Type.anInt)
          ctx.out.write(")")
          retType = ListStuff.newList(type)
        }
      }
    ELSEIF methodName == "sliceWrap"
      IF Generate.checkArgCount(call, 1, 2, ctx) != FAIL
        # mylist.slice(start, end)
        ctx.setDeclUsed(%listSlice)
        ctx.out.write("ZListSliceWrap(")
        Generate.generateVarname(objExpr, ctx, type)
        ctx.out.write(", ")
        Zui.Expression arg0 = call.getArgument(0)
        Generate.genExpr(arg0, ctx, Type.anInt)
        IF call.sizeArgument() > 1
          ctx.out.write(", ")
          Zui.Expression arg1 = call.getArgument(1)
          Generate.genExpr(arg1, ctx, Type.anInt)
        ELSE
          # slice(start) == slice(start, -1)
          ctx.out.write(", -1")
        }
        ctx.out.write(")")
        retType = ListStuff.newList(type)
      }
    ELSEIF methodName == "sort"
      string sortFunc
      IF Generate.checkArgCount(call, 0, 1, ctx) == OK && type.itemType != NIL
        Type.Enum ttype = type.itemType.getTtype()
        SWITCH ttype
          CASE Type.Enum.string
            sortFunc = "undefined"
          CASE Type.Enum.int
          CASE Type.Enum.int8
          CASE Type.Enum.int16
          CASE Type.Enum.int32
          CASE Type.Enum.nat
          CASE Type.Enum.byte
          CASE Type.Enum.nat16
          CASE Type.Enum.nat32
          CASE Type.Enum.float
          CASE Type.Enum.float32
          CASE Type.Enum.float80
          CASE Type.Enum.float128
            sortFunc = "function(a, b) { return a - b; }"
            BREAK
          CASE Type.Enum.object
          CASE Type.Enum.iobject
          CASE Type.Enum.dyn
            # TODO: list<dyn>
            #IF type.itemType.ttype == Type.Enum.dyn
            #  ctx.setDeclUsed(%dynListSort)
            #  fname = "ZdynListSort"
            #}
            Declaration compDecl = Generate.findCompare(type.itemType, ctx)
            IF compDecl == NIL && ctx.doError()
              ctx.error("Compare() function not found", call.getPos())
            ELSE
              sortFunc = "function(a, b) { return a.Compare(b); }"
            }
          DEFAULT
            IF ctx.doError()
              ctx.error("sort() is not supported for \(ttype)", call.getPos())
            }
        }

        ctx.setDeclUsed(%listSort)
        ctx.out.write("ZListSort(")
        Generate.generateVarname(objExpr, ctx, type)
        # ctx.out.write(", ")
        # ctx.out.write(sortFunc)
        ctx.out.write(", ")
        IF call.hasArgument()
          Generate.genExpr(call.getArgument(0), ctx, Type.aBool)
        ELSE
          ctx.out.write("true")
        }
        ctx.out.write(")")

        retType = ListStuff.newList(type)
      }
    ELSEIF methodName == "join"
      IF Generate.checkArgCount(call, 0, 1, ctx) == FAIL
        # nothing
      ELSEIF type.itemType != NIL
        # mylist.join()
        string fname
        ctx.setDeclUsed(%listJoin)
        ctx.out.write("ZListJoin(")
        Generate.generateVarname(objExpr, ctx, type)
        ctx.out.write(", ")
        IF call.hasArgument()
          Zui.Expression arg0 = call.getArgument(0)
          Generate.genExprDoConv(arg0, ctx.copyNoOut(), Type.aString)
          ZuiExpressionExt arg0Ext = arg0
          IF arg0Ext.conversion == Conversion.nat2string
                 || arg0Ext.conversion == Conversion.int2string
            # join(separator-char)
            ctx.out.write("String.fromCharCode(")
            Generate.genExprDoConv(arg0, ctx, Type.anInt)
            ctx.out.write(")")
            ctx.setDeclUsed(Declaration.asString)
          ELSE
            # join(separator-string)
            Generate.genExprDoConv(arg0, ctx, Type.aString)
          }
        ELSE
          # join()
          ctx.out.write("' '")
        }
        ctx.out.write(")")
        retType = Type.aString
      }
    ELSEIF methodName == "map" || methodName == "keyMap"
      IF Generate.checkArgCount(call, 1, 1, ctx) != FAIL
        IF methodName == "map"
          ctx.setDeclUsed(%listMap)
          ctx.out.write("ZListMap(")
        ELSE
          ctx.setDeclUsed(%listKeyMap)
          ctx.out.write("ZListKeyMap(")
        }
        Generate.generateVarname(objExpr, ctx, type)

        ctx.out.write(", ")
        Zui.Expression arg = argList[0]
        Generate.genFuncArg(arg, methodName == "map" ? NIL : Type.anInt,
                                                           type.itemType, ctx)

        ctx.out.write(")")
        retType = ListStuff.newList(type)
      }
    ELSEIF methodName == "copy"
      IF Generate.checkArgCount(call, 0, 0, ctx) != FAIL
        ctx.setDeclUsed(%listCopy)
        ctx.out.write("ZListCopy(")
        Generate.generateVarname(objExpr, ctx, type)
        ctx.out.write(")")
        retType = ListStuff.newList(type)
      }
    ELSEIF methodName == "size" || methodName == "Size"
      IF Generate.checkArgCount(call, 0, 0, ctx) != FAIL
        ctx.setDeclUsed(%listSize)
        ctx.out.write("ZlistSize(")
        Generate.generateVarname(objExpr, ctx, type)
        ctx.out.write(")")
      }
      retType = Type.anInt
    ELSE
      IF ctx.doError()
        ctx.error("Method " .. methodName .. "() not supported for List",
                                                              call.getPos())
      }
    }
    IF retType == NIL
      RETURN Type.anUnknown
    }
    RETURN retType
  }

  PROC writeListAlloc(ContainerType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    list<Zui.Expression> args = call.getArgumentList()
    IF args.Size() == 2
      ctx.setDeclUsed(%newListInit)
      IF type.itemType != NIL
        ctx.out.write("ZnewListInit(")
        Generate.genExprDoConv(args[0], ctx, Type.anInt)
        ctx.out.write(", ")
        ctx.out.write(WriteJava.getTypeName(type.itemType, ctx))
        ctx.out.write(", ")
        Generate.genExprDoConv(args[1], ctx, type.itemType)
        ctx.out.write(")")
      }
    ELSE
      ctx.out.write("{a: [], itemType: ")
      ctx.out.write(WriteJava.getTypeName(type.itemType, ctx))
      ctx.out.write("}")
    }
  }

  # Set dependencies between used items.  Called before marking Main() as
  # used.
  PROC addDependencies(WriteJava gen)
    Declaration.itemToString.addDependsOnCond(%listToString, Declaration.list,
                                                                          gen)
    %listAdd.addDependsOn(WriteJava.throw)
  }

  # Keep track of used items.
  Declaration.C %listToString = NEW("listToString")
  Declaration.C %listGet = NEW("listGet")
  Declaration.C %toNat32 = NEW("toNat32")
  Declaration.C %listGetIdx = NEW("listGetIdx")
  Declaration.C %listAdd = NEW("listAdd")
  Declaration.C %listInsert = NEW("listInsert")
  Declaration.C %newListInit = NEW("newListInit")
  Declaration.C %listExtend = NEW("listExtend")
  Declaration.C %listConcat = NEW("listConcat")
  Declaration.C %listClear = NEW("listClear")
  Declaration.C %listPopItem = NEW("listPopItem")
  Declaration.C %listPopList = NEW("listPopList")
  Declaration.C %listSlice = NEW("listSlice")
  Declaration.C %listSort = NEW("listSort")
  Declaration.C %listJoin = NEW("listJoin")
  Declaration.C %listMap = NEW("listMap")
  Declaration.C %listKeyMap = NEW("listKeyMap")
  Declaration.C %listCopy = NEW("listCopy")
  Declaration.C %listSize = NEW("listSize")
  Declaration.C %listCompare = NEW("listCompare")
  Declaration.C %listEqual = NEW("listEqual")

  PROC initCodeWriters(list<CodeWriter> codeWriters)
    # static list add function, able to check if the list object is null.
    codeWriters.add(NEW(%listAdd,
      PROC (WriteJava gen, IO.File fd)
        # TODO: Normal append could be optimized.
        fd.write(''"
/* List add */
static <Ti> ZList<Ti> ZLa(ZList<Ti> head, long after, Ti val) {
  if (head == null) ZthrowNil("Invoking add() on NIL list");
  if (after == -1 || after >= head.list.size()) {
    head.list.add(0, val);
  } else {
    if (after < 0) {
      int before = head.list.size() + (int)after + 1;
      if (before < 0) {
        before = 0;
      }
      head.list.add(before, val);
    } else {
      head.list.add((int)after + 1, val);
    }
  }
  return head;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%newListInit,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZnewListInit(len, type, val) {
  var l = [];
  for (var i = 0; i < len; ++i) {
    l.push(val);
  }
  return {a: l, itemType: type};
}
"'')
      }))

    codeWriters.add(NEW(%listInsert,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListInsert(head, before, val) {
  if (head == null) ZthrowNil("Invoking insert() on NIL list");
  if (before >= 0) {
    if (before > head.a.length) {
      head.a.push(val);
    } else {
      head.a.splice(before, 0, val);
    }
  } else {
    var idx = head.a.length + before;
    if (idx < 0) {
      idx = 0;
    }
    head.a.splice(idx, 0, val);
  }
  return head;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%toNat32,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZtoNat32(nr) {
 if (nr < 0 || nr > 4294967295) {
  nr = nr & 4294967295;
 }
 if (nr < 0) nr += 4294967295;
 return nr
}
"'')
      }))

    codeWriters.add(NEW(%listGetIdx,
      PROC (WriteJava gen, IO.File fd)
        string throwOutOfRange = DeclStore.getPName("MEModule",
                                                           "FthrowOutOfRange")
        fd.write(''"
function ZListGetIdx(head, idx) {
  if (idx >= 0) {
    if (idx >= head.a.length) "'' .. throwOutOfRange .. ''"(idx, 'Index out of range');
    return idx;
  }
  var i = head.a.length + idx;
  if (i < 0) "'' .. throwOutOfRange .. ''"(idx, 'Index out of range');;
  return i;
}
"'')
      }).setDependencies([["MEModule", "FthrowOutOfRange"]]))

    codeWriters.add(NEW(%listGet,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
public static <Ti> Ti ZListGet(ZList<Ti> head, long idx) {
 if (head == null) ZthrowNil("Accessing NIL list");
 if (idx >= 0) {
  if (idx >= head.list.size()) return null;
  return head.list.get((int)idx);
 }
 int i = head.list.size() + (int)idx;
 if (i < 0) return null;
 return head.list.get(i);
}
"'')
      }))

    codeWriters.add(NEW(%listToString,
      PROC (WriteJava gen, IO.File fd)
        string stringWriter = DeclStore.getPName("MIOModule", "CStringWriter")
        fd.write(''"
public static <Ti> String ZListToString(ZList<Ti> head, boolean useq) {
 if (head == null) return "NIL";
 ++tosNr;
 return ZListToStringGa(head, useq);
}
public static <Ti> String ZListToStringGa(ZList<Ti> head, boolean useq) {
 "'' .. stringWriter .. " sw = new " .. stringWriter .. ''"();
 sw.write("[");
 if (head.tosNr == tosNr) {
  sw.write("recursive-list");
 } else {
  head.tosNr = tosNr;
  for (int i = 0; i < head.list.size(); ++i) {
   if (i > 0) sw.write(", ");
   sw.write(ZitemToString(head.list.get(i), head.itemType, useq));
  }
  head.tosNr = 0;
 }
 sw.write("]");
 return sw.toString();
}
"'')
      }).setDependencies([Declaration.itemToString]))

    codeWriters.add(NEW(%listConcat,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListConcat(head, head2) {
  if (head == null) ZthrowNil("Invoking concat() on NIL list");
  var chead = {a: head.a.slice(), itemType: head.itemType};
  if (head2 == null) return chead;
  for (var i in head2.a) {
    chead.a.push(head2.a[i]);
  }
  return chead;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listExtend,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListExtend(head, head2) {
  if (head == null) ZthrowNil("Invoking extend() on NIL list");
  if (head2 == null) return head;
  for (var i in head2.a) {
    head.a.push(head2.a[i]);
  }
  return head;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listClear,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListClear(head) {
  if (head == null) ZthrowNil("Invoking clear() on NIL list");
  head.a = [];
  return head;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listPopItem,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListPopItem(head, idx, remove) {
  if (head == null) ZthrowNil(remove ? "Invoking remove() on a NIL list" : "Invoking clear() on a NIL list");
  if (head.a.length == 0) return null;
  if (idx == -1) return head.a.pop();
  var i = idx;
  if (idx < 0) {
    i = head.a.length + idx;
  }
  if (i >= 0 && i < head.a.length) {
    var a = head.a.splice(i, 1);
    if (remove) return a[0];
    return head;
  }
  if (remove) return null;
  return head;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listPopList,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListPopList(head, i1, i2) {
 if (head == null) ZthrowNil("Invoking remove() on NIL list");
 var idx1 = i1;
 if (i1 < 0) {
  idx1 = head.a.length + i1;
 }
 if (idx1 < 0) idx1 = 0;
 if (idx1 >= head.a.length) idx1 = head.a.length - 1;
 var idx2 = i2;
 if (i2 < 0) {
  idx2 = head.a.length + i2;
 }
 if (idx2 < 0) idx2 = 0;
 if (idx2 >= head.a.length) idx2 = head.a.length - 1;
 if (idx1 > idx2) return [];
 var res = {a: head.a.slice(idx1, idx2 + 1), itemType: head.itemType};
 var na = head.a.slice(0, idx1);
 if (idx2 + 1 < head.a.length) na = na + head.a.slice(idx2 + 1);
 head.a = na;
 return res;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listSort,
      PROC (WriteJava gen, IO.File fd)
        # TODO: make sort work.
        fd.write(''"
public static <Ti> ZList<Ti> ZListSort(ZList<Ti> head, boolean asc) {
 if (head == null) ZthrowNil("Invoking sort() on NIL list");
 // Collections.sort(head.list);
 // if (!asc) Collections.reverse(head.list);
 return head;
}
"'')
      }).setDependencies([WriteJava.throw, WriteJava.collections]))

    codeWriters.add(NEW(%listJoin,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListJoin(head, sep) {
 if (head == null) ZthrowNil("Invoking join() on NIL list");
 ++tosNr;
 var result = [];
 for (var i = 0; i < head.a.length; ++i) {
  result.push(ZitemToString(head.a[i], head.itemType, 0));
 }
 return result.join(sep);
}
"'')
      }).setDependencies([WriteJava.throw, Declaration.itemToString]))

    codeWriters.add(NEW(%listMap,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListMap(head, f) {
 if (head == null) ZthrowNil("Invoking map() on NIL list");
 for (var i = 0; i < head.a.length; ++i) {
  head.a[i] = f(head.a[i]);
 }
 return head;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listKeyMap,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListKeyMap(head, f) {
 if (head == null) ZthrowNil("Invoking keyMap() on NIL list");
 for (var i = 0; i < head.a.length; ++i) {
  head.a[i] = f(i, head.a[i]);
 }
 return head;
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listCopy,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListCopy(head) {
 if (head == null) ZthrowNil("Invoking copy() on NIL list");
 return {a: head.a.slice(), itemType: head.itemType};
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listSize,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
static <Ti> long ZlistSize(ZList<Ti> head) {
 return head == null ? 0 : head.list.size();
}
"'')
      }))

    codeWriters.add(NEW(%listSlice,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListSliceWrap(head, i1, i2) {
 if (head == null) return null;
 var idx1 = i1;
 var idx2 = i2;
 if (i1 < 0) {
   idx1 = head.a.length + i1;
 }
 if (idx1 < 0) idx1 = 0;
 if (i2 < 0) {
   idx2 = head.a.length + i2;
 }
 if (idx2 < 0) idx2 = 0;
 if (idx1 > idx2) return {a: [], itemType: head.itemType};
 return {a: head.a.slice(idx1, idx2 + 1), itemType: head.itemType};
}
"'')
      }).setDependencies([WriteJava.throw]))

    codeWriters.add(NEW(%listEqual,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListEqual(headl, headr) {
 if (headl == null || headr == null) ZthrowNil("Comparing with NIL list");
 if (headl.a.length != headr.a.length) return 0;
 for (var n = 0; n < headl.a.length; ++n) {
  if (!ZitemEqual(headl.itemType, headl.a[n], headr.itemType, headr.a[n])) return 0;
 }
 return 1;
}
"'')
      }).setDependencies([Declaration.itemEqual]))

    codeWriters.add(NEW(%listCompare,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZListCompare(headl, headr) {
 if (headl == null || headr == null) ZthrowNil("Comparing with NIL list");
 var tot = headl.a.length;
 if (headr.a.length < tot) tot = headr.a.length;
 for (var n = 0; n < tot; ++n) {
  v = ZitemEqual(headl.itemType, headl.a[n], headr.itemType, headr.a[n]);
  if (v != 0) return v;
 }
 if (headl.a.length == headr.a.length) return 0;
 return headl.a.length > headr.a.length ? 1 : -1;
}
"'')
      }).setDependencies([Declaration.itemEqual]))

  }

  PROC writeBody(WriteJava gen, IO.File fd)
    IF !gen.isDeclUsed(Declaration.list)
      RETURN
    }
    fd.write(''"
static class ZList<Ti> {
  final public ArrayList<Ti> list;
  final public ZType itemType;
  public int tosNr = 0;
  public ZList(ZType itemType) {
    this.list = new ArrayList<Ti>();
    this.itemType = itemType;
  }
"'')
    IF gen.isDeclUsed(%listAdd)
      fd.write(''"
  /* List add */
  public ZList<Ti> ZLa(Ti val) {
    return ZLa(list.size(), val);
  }

  public ZList<Ti> ZLa(long after, Ti val) {
    if (after == -1 || after >= list.size()) {
      list.add(0, val);
    } else {
      if (after < 0) {
        int before = list.size() + (int)after + 1;
        if (before < 0) {
          before = 0;
        }
        list.add(before, val);
      } else {
        list.add((int)after + 1, val);
      }
    }
    return this;
  }
"'')
    }
    fd.write(''"
}
"'')
  }

}
