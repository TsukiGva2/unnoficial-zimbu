#
# The Zimbu compiler written in Zimbu
#
# WriteJava class and module: Methods are invoked from Generate for each
# statement and expression to generate JavaScript code.
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#
# TODO: This file was copied from the Javascript version, much of it still
# needs to be redone for Java.

# Mapping Zimbu types to Java:
# - status:        boolean, true is OK, false is FAIL.
# - array:         ?
# - list:          Java List
# - dict:          ZDict
# - varargs:       ?
# - tuple:         ?
# - string:        String
# - byteString:    Array where each item is one byte
# - varString:     ?
# - varByteString: ?
# - callback:      ?
# - enum:          int or long
# - type:          ZType
# - dyn:           ?

IMPORT.PROTO ../parser/zui.proto

IMPORT WriteArrayJava.zu
IMPORT WriteDictJava.zu
IMPORT WriteListJava.zu

IMPORT ../Arguments.zu
IMPORT ../BitsType.zu
IMPORT ../BitsValueType.zu
IMPORT ../CallbackType.zu
IMPORT ../ClassType.zu
IMPORT ../CodeWriter.zu
IMPORT ../CommonFlags.zu
IMPORT ../ContainerType.zu
IMPORT ../Conversion.zu
IMPORT ../DeclStore.zu
IMPORT ../Declaration.zu
IMPORT ../DictStuff.zu
IMPORT ../EnumType.zu
IMPORT ../EnumValueType.zu
IMPORT ../ExprArg.zu
IMPORT ../ExprEval.zu
IMPORT ../ForLoopInfo.zu
IMPORT ../Generate.zu
IMPORT ../MethodRefType.zu
IMPORT ../MethodType.zu
IMPORT ../MethodScope.zu
IMPORT ../ModuleScope.zu
IMPORT ../ModuleType.zu
IMPORT ../MultipleType.zu
IMPORT ../Output.zu
IMPORT ../ReferenceType.zu
IMPORT ../Report.zu
IMPORT ../Resolve.zu
IMPORT ../SContext.zu
IMPORT ../Scope.zu
IMPORT ../SwitchScope.zu
IMPORT ../SymUse.zu
IMPORT ../TargetLang.zu
IMPORT ../TopScope.zu
IMPORT ../TryScope.zu
IMPORT ../Type.zu
IMPORT ../TupleType.zu
IMPORT ../UsedFile.zu
IMPORT ../ValueType.zu
IMPORT ../WriteCommon.zu
IMPORT ../ZimbuFile.zu
IMPORT ../ZuiCodeBlockExt.zu
IMPORT ../ZuiExpressionExt.zu
IMPORT ../ZuiMethodCallExt.zu
IMPORT ../ZuiStatementExt.zu

# The methods that are implemented for the Resolve.I interface are commented
# in resolve.zu.
CLASS WriteJava EXTENDS WriteCommon IMPLEMENTS Resolve.I
                           @public @items=public   # TODO: restrict visibility
  TargetLang $targetLang

  NEW()
    $writing = TRUE
    $targetLang.java = TRUE
  }

  FUNC $getLangName() string @replace
    RETURN "Java"
  }

  FUNC $getTargetLang() TargetLang @replace
    RETURN $targetLang
  }

  FUNC $thisName(bool insideNew) string
    IF insideNew
      # We create a new object with this name.
      RETURN newThisName
    }
    # Use the Javascript mechanism to access the current object.
    RETURN "this"
  }

  PROC $writeThisName(SContext ctx)
    ctx.out.write(ctx.scope.getThisName())
  }

  PROC $writeClosureThis(SContext ctx)
    ctx.out.write(" var \(cbThisName) = \(ctx.scope.getThisName());\n")
  }

  PROC $writeTrueArgument(Output out)
    out.write(", true")
  }

  PROC $writeFalseArgument(Output out)
    out.write(", false")
  }

  # Write statement and line end, usually ";\n".
  PROC $statementLineEnd(Output out)
    out.write(";\n")
  }

  # Write code for the end of a scope.
  PROC $writeScopeEnd(bool writeLabel, bool willJump,
               list<Zui.Statement> statements, Zui.Position pos, SContext ctx)
    # Call Finish for any objects located on the stack.
    # For a method scope it's done in $writeBeforeReturn().
    IF ctx.scope ISNOTA MethodScope
      Zui.Statement lastStmt
      IF statements != NIL && statements.Size() > 0
        lastStmt = statements[-1]
      }
      $writeScopeEndFinish(lastStmt == NIL ? pos : lastStmt.getPos(),
                                                               ctx.scope, ctx)
    }
  }

  # Write code to jump to the end of the scope.
  PROC $writeJumpToLabel(SContext ctx)
  }

  # Return TRUE if an abstract method method is not to be generated.
  FUNC $skipAbstractMethod() bool
    RETURN FALSE
  }

  # Return TRUE if a method from the parent is to be written in a child class.
  FUNC $doWriteParentMethod(Declaration decl) bool
    # This is only needed for NEW(), so that the new statement is done on the
    # right class.
    RETURN decl.type.ttype == Type.Enum.new
  }

  # Generate the interface member lookup table, when needed.
  PROC $interfaceMemberTable(Declaration decl, Declaration itf, SContext ctx)
  }

  # Write interface member lookup tables for a class.
  PROC $writeIMTTables(Declaration decl, set<string> imtDone, SContext ctx)
  }

  # Write object declaration table for a class.
  PROC $writeToTable(Declaration decl, SContext ctx)
    ClassType thisClass = decl.type.getClassType(ctx)
    Output out = ctx.outs.typeOut
    out.write("static ZType ")
    out.write(thisClass.pName)
    out.write("__T = new ZType(390, \"\(thisClass.name)\");\n")
  }

  FUNC $getCS(ZimbuFile zimbuFile) ZimbuFile.CodeSpecific
    RETURN zimbuFile.java
  }

  PROC $mainHead(MethodType method, SContext ctx)
    # TODO: use the specified exe name from the -o flag.
    ctx.out.write(''"
 public static void main(String[] args) {
  ZdoInit(args);

  ZexitCode = Fmain();

  // beforeExit();
 }

 static long Fmain() {
"'')
  }

  PROC $mainMiddle(SContext ctx)
  }

  PROC $mainEnd(SContext ctx)
    ctx.out.write(" }\n}\n")
  }

  # Allocate a new object.
  PROC $writeAlloc(ClassType class, Declaration finishMethod,
                                                     Output out, SContext ctx)
    $writeAlloc(class.pName, finishMethod, out, ctx)
  }

  # Allocate a new object.
  PROC $writeAlloc(string typeName, Declaration finishMethod,
                                                     Output out, SContext ctx)
    out.write("new " .. typeName .. "()")
  }

  PROC $writeObjectInit(Declaration initDecl, ClassType classType,
                                               Declaration dest, SContext ctx)
    ctx.out.write(initDecl.pName)
    ctx.out.write("(null)")
  }

  # Not-allocated variables are not fully supported in Javascript.
  # Only works for variables on the stack.
  FUNC $supportsNoAlloc() bool
    RETURN FALSE
  }

  PROC $writeNoAllocClear(string typeName, ClassType classType,
                          Declaration initMethod, Declaration finishMethod,
                          Declaration dest, SContext ctx)
    $writeNoAllocClear(typeName, initMethod, finishMethod, dest.pName, ctx)
  }

  # Write a call to clear an object that is not allocated.
  PROC $writeNoAllocClear(string typeName, Declaration initMethod,
                      Declaration finishMethod, string destName, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    IF finishMethod == NIL
      THROW "writeNoAllocClear() should not be called"
    }
    Output out = ctx.out

    IF initMethod == NIL
      $writeAlloc(typeName, NIL, ctx.out, ctx)
    ELSE
      out.write(initMethod.pName)
      out.write("(null)")
    }
  }

  PROC $callFinish(Declaration decl, int reason, Zui.Position pos, SContext ctx)
    $setDeclUsed(Declaration.hasFinish)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("ZFinish(")
    ctx.out.write(decl.pName)
    ctx.out.write(", ")
    ctx.out.write(reason)
    ctx.out.write(");\n")
  }

  PROC $writeNoAllocInit(Declaration dest, SContext ctx)
    IF ctx.out.writing
       THROW "writeNoAllocInit() should not be called"
    }
  }

  # Allocate a new string from an array.
  PROC $writeNewString(Zui.MethodCall call, int &undef, SContext ctx)
    Output out = ctx.out
    out.write("String.valueOf.apply(null, (")
    list<Zui.Expression> args = call.getArgumentList()
    ContainerType array = Generate.genExpr(args[0], ctx, Type.anArray)
    IF array == NIL || array.itemType == NIL || !array.itemType.isIntType()
      ctx.error("First argument must be an array of int or nat", args[0])
    }
    out.write(").a")
    IF args.Size() >= 2
      out.write(".slice(")
      Generate.genExpr(args[1], ctx, Type.anInt)
      IF args.Size() == 3
        out.write(", ")
        Generate.genExpr(args[2], ctx, Type.anInt)
        out.write(" + 1")
      }
      out.write(")")
    }
    out.write(")")
  }

  # Allocate a new array for |type|.
  PROC $writeArrayAlloc(ContainerType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    WriteArrayJava.writeArrayAlloc(type, noAllocName, call, undef, ctx)
  }

  PROC $writeListAlloc(ContainerType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    WriteListJava.writeListAlloc(type, noAllocName, call, undef, ctx)
  }

  # Write the code to declare a callback type.
  PROC $writeCallbackDecl(CallbackType type, Zui.Position pos, SContext ctx)
  }

  # Allocate a new callback for |type|.
  PROC $writeCallbackAlloc(CallbackType type,
                           string noAllocName,
                           Generate.CallbackInfo cbInfo,
                           Zui.MethodCall call,
                           int &undef,
                           SContext ctx)
    list<Zui.Expression> args = call.getArgumentList()
    int argOffset = cbInfo != NIL ? 0 : 1
    IF args.Size() != type.arguments.Size() + argOffset
      ctx.error("Expected " .. (type.arguments.Size() + argOffset)
                        .. " arguments, found " .. args.Size(), call.getPos())
      RETURN
    }
    Output out = ctx.out

    # Variables passed by value require defining a scope, otherwise Javascript
    # uses the value later, when the callback is invoked.
    # Do this for object.method().
    Zui.Expression methodExpr = cbInfo != NIL ? call.getName() : args[0]
    bool extraScope
    bool passObject
    IF methodExpr.getType() == Zui.ExprType.eMEMBER
      Type leftType = Generate.genExpr(methodExpr.getLeft(), ctx.copyNoOut())
      Type.Enum ttype = leftType?.getTtype()
      IF ttype == Type.Enum.object || ttype == Type.Enum.iobject
        extraScope = TRUE
        passObject = TRUE
      }
    }
    IF argOffset < args.Size()
      # It's not easy to tell whether the arguments use something from the
      # outer scope, use an extra scope if there are any arguments.
      extraScope = TRUE
    }

    IF extraScope
      out.write("(function(")
      string comma = ""
      IF passObject
        out.write("aM")
        comma = ", "
      }
      FOR i IN argOffset UNTIL args.Size()
        out.write(comma)
        out.write("b" .. i)
        comma = ", "
      }
      out.write(") { return ")
    }

    # Arguments from caller passed on to called function.
    string comma = ""
    string passed = ""
    int argName = 'a'
    FOR arg IN type.methodType.arguments
      passed ..= comma
      passed ..= argName.asString()
      comma = ", "
      ++argName
    }

    out.write("function(")
    out.write(passed)
    out.write(") { return ")

    # Using "this" doesn't work here, use the special temp var instead.
    string saveThisName = ctx.scope.getThisName()
    ctx.scope.thisNameString = cbThisName

    # the function name
    IF passObject
      out.write("aM.")
      Type methodType
      IF cbInfo != NIL
        methodType = cbInfo.methodType
      ELSE
        methodType = Generate.genExpr(methodExpr, ctx.copyNoOut(),
                                         type.calledMethodType.getMethodRef())
      }
      IF methodType == NIL
        Report.internal("methodType is NIL", call.getPos())
      ELSEIF methodType.jsMName == NIL
        Report.internal("jsMName of method is NIL", call.getPos())
      }
      out.write(methodType?.jsMName)
    ELSEIF cbInfo == NIL
      Generate.genExpr(methodExpr, ctx, type.calledMethodType.getMethodRef())
    ELSE
      IF cbInfo.methodType.pName == NIL
        Report.internal("pName of method is NIL", call.getPos())
      }
      out.write(cbInfo.methodType.pName)
    }
    out.write("(")
    out.write(passed)

    # extra arguments
    FOR i IN argOffset UNTIL args.Size()
      out.write(comma)
      out.write("b" .. i)
      comma = ", "
    }
    out.write("); }")

    IF extraScope
      out.write("; })(")
      comma = ""
      IF passObject
        Generate.genExpr(methodExpr.getLeft(), ctx)
        comma = ", "
      }
      FOR i IN argOffset UNTIL args.Size()
        out.write(comma)
        Generate.genExpr(args[i], ctx, type.arguments[i - 1].type)
        comma = ", "
      }
      out.write(")")
    }

    ctx.scope.thisNameString = saveThisName
  }

  # Allocate a new closure for |type|.
  PROC $writeClosureAlloc(CallbackType type,
                          MethodType method,
                          bool typeCast,
                          Zui.Expression objectExpr,
                          int &undef,
                          Output curOut,
                          SContext ctx)
    Output out = ctx.out
    IF !out.writing
      RETURN
    }

    out.write("function(")
    IO.StringWriter callArgs = NEW()
    int cnt = 1
    FOR l IN method.arguments
      IF cnt > 1
        callArgs.write(", ")
      }
      callArgs.write("a" .. cnt)
      ++cnt
    }
    string callArgsString = callArgs.ToString()
    out.write(callArgsString)
    out.write(") { return ")
    string thisName
    IF type.calledMethodType.getClassType(ctx) != NIL
          || (objectExpr != NIL && objectExpr.getType() == Zui.ExprType.eTHIS)
      # For a class method use this1.name(), so that "this1" is defined inside
      # the called method.  Using "this" doesn't work.
      thisName = cbThisName
    ELSEIF type.getClass() != NIL && (ctx.scope.flags.insideNew
                                                || ctx.scope.flags.insideInit)
      # Inside NEW() and Init() closures are allocated for methods with USE
      # arguments.  Need to use "this0" there.
      thisName = newThisName
    }
    IF thisName != NIL || objectExpr != NIL
      IF thisName != NIL
        out.write(thisName)
      ELSE
        genExpr(objectExpr, ctx, method.classType.getValueType(ctx))
      }
      out.write(".")
      MethodType mtype = type.calledMethodType
      IF mtype.parentMethod != NIL
        # Use the original method name, it's inherited from the parent.
        mtype = mtype.parentMethod
      }
      out.write(mtype.jsMName)
    ELSE
      $namelessFuncUse(type.calledMethodType, ctx)
    }
    out.write("(")
    out.write(callArgsString)

    FOR l IN [method.useArguments, method.autoArguments]
      FOR arg IN l
        IF cnt > 1
          out.write(", ")
        ELSE
          ++cnt
        }
        IF arg.type ISA MethodRefType
          # PROC foo(USE funcName): generate callback decl for funcName
          Generate.generateMethodUse(undef, arg.type.getMethod(),
                                                    arg.type.getMethod(), ctx)
        ELSE
          Declaration argClass = arg.getClass()
          string varname = ""
          IF argClass != NIL && !arg.type.isAllocType(ctx)
            varname = ctx.scope.getThisName() .. "."
          }
          varname ..= arg.pName
          IF arg.type.ttype == Type.Enum.byRef || arg.type.isAllocType(ctx)
            $writeRef(varname, ctx)
          ELSE
            # We want the current value of the variable, not a value assigned
            # later.  The closure will pass the variable reference, which is
            # not what we want.  Store the current value and pass that.
            IF curOut != NIL
              string n = getUid(varname)
              curOut.writeIndent(ctx.scope.depth)
              curOut.write("int ")
              curOut.write(n)
              curOut.write(" = ")
              curOut.write(varname)
              curOut.write(";\n")
              varname = n
            }
            out.write(varname)
          }
        }
      }
    }
    out.write("); }")
  }

  # Write all the tuples needed for MultipleType (list of return types).
  PROC $writeMultipleDecls(SContext ctx)
    FOR t IN MultipleType.allTypes
      IF $isDeclUsed(t)
        writeTupleDecl(t.types.size(), ctx.outs.declOut)
      }
    }
  }

  # Write the code to declare a tuple type.
  PROC $writeTupleDecl(TupleType tupleType, Zui.Position zuiPos, SContext ctx)
    # Write the Tuple9 class, if not done already.
    writeTupleDecl(tupleType.types.size(), ctx.outs.declOut)

    # Whether tuple<>.ToString() is used.
    bool useTupleToString = $isDeclUsed(Type.aDyn)
                              || (tupleType.toStringDecl != NIL
                                       && $isDeclUsed(tupleType.toStringDecl))
    IF useTupleToString
      # Write function for tuple.ToString().
      $writeTupleToString(tupleType, zuiPos, ctx)
    }

    Output declOut = ctx.outs.declOut
    declOut.write("ZType " .. tupleType.pName .. "__T = new ZType(320, \""
                                             .. tupleType.typeName() .. "\", ")
    IF useTupleToString
      declOut.write(tupleType.pName .. "ToString")
    ELSE
      declOut.write("null")
    }
    declOut.write("];\n")
  }

  PROC $writeTupleAlloc(TupleType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    ctx.out.write("[")
    list<Zui.Expression> args = call.getArgumentList()
    IF args.Size() == 0
      # NEW() allocates with default values.
      FOR i IN 0 UNTIL type.types.Size()
        IF i > 0
          ctx.out.write(", ")
        }
        $defaultInit(type.types[i].type, ctx.out, ctx)
      }
    ELSEIF args.Size() != type.types.Size()
      ctx.error("Expected " .. (type.types.Size() + 1)
                        .. " arguments, found " .. args.Size(), call.getPos())
    ELSE
      # NEW(a1, a2) allocates and sets values.
      FOR i IN 0 UNTIL args.Size()
        IF i > 0
          ctx.out.write(", ")
        }
        Generate.genExpr(args[i], ctx, type.types[i].type)
      }
    }
    ctx.out.write("]")
  }

  PROC $callTupleToString(Zui.MethodCall call,
                                 Type type, Zui.Expression expr, SContext ctx)
    Output out = ctx.out
    out.write(type.getEffType().pName .. "ToString(")
    Generate.generateVarname(expr, ctx, type)
    out.write(")")
  }

  # Generate a function for tuple.ToString().
  PROC $writeTupleToString(TupleType tupleType, Zui.Position pos, SContext ctx)
    Output bodyOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    bodyOut.write("function " .. tupleType.pName .. ''"ToString(t) {
 if (!t) return 'NIL';
 var res = ['['];"'')
    FOR i IN 0 UNTIL tupleType.types.Size()
      IF i > 0
        bodyOut.write("\n res.push(', ');")
      }
      Type type = tupleType.types[i].type
      SContext newCtx = ctx.copyNewOut()
      int undef
      int t = getArgumentType(type, pos, &undef, newCtx)
      bodyOut.write("\n res.push(ZitemToString(t[\(i)], ")
      bodyOut.write(getTypeName(type, ctx))
      bodyOut.write(", 1));")
    }
    bodyOut.write(''"
 res.push(']');
 return res.join('');
}
"'')
    $setDeclUsed(Declaration.itemToString)
  }

  PROC $callTypeToString(Zui.Expression expr, SContext ctx)
    ctx.out.write("Ztype2string(")
    genExpr(expr, ctx, Type.aType)
    ctx.out.write(")")
  }

  PROC $callTypeName(Zui.Expression expr, SContext ctx)
    Generate.genExpr(expr, ctx)
    ctx.out.write("[1]")
  }

  PROC $writeNewThis(MethodType method, Declaration initMethod,
                     Declaration finishMethod, Zui.Position pos, SContext ctx)
    # Skip this for an abstract class.  A child will create the object and
    # then call this new() on the parent.
    IF !method.classType.isAbstract()
      ctx.out.writeIndent(1)
      ctx.out.write("if (\(newThisName) == null) \(newThisName) = ")
      IF initMethod == NIL
        $writeAlloc(method.classType, NIL, ctx.out, ctx)
      ELSE
        ctx.out.write(initMethod.pName)
        ctx.out.write("(null)")
      }
      ctx.out.write(";\n")
    }
  }

  PROC $writeRefThis(SContext ctx)
  }

  PROC $writeNewArg(bool useThis, ClassType classType, Declaration dest,
                    Declaration initMethod, Declaration finishMethod,
                    bool hasArg, SContext ctx)
    IF useThis
      # calling NEW() inside NEW(): pass the already constructed object
      ctx.out.write(ctx.scope.getThisName())
    ELSEIF classType != NIL
      # calling NEW() on a not allocated object: pass that object.
      ctx.out.write(dest.pName)
    ELSE
      # calling NEW() elsewhere: pass null so that a new object is
      # constructed.
      ctx.out.write("null")
    }
    IF hasArg
      ctx.out.write(", ")
    }
  }

  # Write the code that goes before writing " return r;" in a normal function.
  PROC $writeBeforeReturn(Zui.Position pos, SContext ctx)
    # If an object located on the stack has a Finish() method, call it.
    $writeScopeEndFinish(pos, ctx.scope, ctx)

    IF ctx.scope.methodScope != NIL
      IF ctx.scope.methodScope.hasDefer
        ctx.out.write(" ZdeferCall(deferLen);\n")
      }
      IF ctx.scope.methodScope.hasCtxAdd
        ctx.out.write(" ctxArr.length = ctxUsed;\n")
      }
    }
  }

  # For variables declared in the current scope, which are allocated on the
  # stack, call their Finish() method.
  PROC $writeScopeEndFinish(Zui.Position pos, Scope scope, SContext ctx)
    IF !$isDeclUsed(Declaration.hasFinish) || !scope.hasFinish
      RETURN
    }

    FOR declList IN scope.declDict?.values()
      FOR decl IN declList
        Declaration finish
        bool childHasFinish
        bool isIobj
        IF decl.type != NIL && decl.type.isNoAlloc()
          ClassType class = decl.type.getClassType(ctx)
          IF class != NIL
            isIobj = decl.type.getTtype() == Type.Enum.iobject
            finish = Generate.getFinishMethod(class.scope, ctx)
            IF finish == NIL && isIobj && class.hasFinishMethod(ctx)
              # Some child class has Finish().
              childHasFinish = TRUE
            }
          }
        }
        IF finish != NIL || childHasFinish
          ctx.out.writeIndent(ctx.scope.depth)
          ctx.out.write("ZFinish(" .. decl.pName .. ", 2);\n")
        }
      }
    }

    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("onStackList.length = onStackLen" .. scope.depth .. ";\n")
  }

  PROC $writeNewReturn(Zui.Position pos, SContext ctx)
    $writeBeforeReturn(pos, ctx)
    ctx.out.write(" return " .. newThisName .. ";\n")
  }

  # Write the name of this symbol, surrounding it with what is required to
  # access it.
  # When |top| is TRUE the symbol is the whole expression.
  # When |read| is TRUE the symbol is read from, not assigned to or called.
  # When |objectMember| is TRUE may prepend "THIS.".
  PROC $writeSymName(Declaration decl, Type type, Type destType,
                                     Resolve.SymNameFlags flags, SContext ctx)
    IF ctx.out.writing
      IF type.ttype == Type.Enum.byRef
        # Note: When writing this just returns the function, calling it must
        # be handled elsewhere.
        IF decl.pName == NIL
          Report.internal("pName is NIL for \(decl)")
        }
        ctx.out.write(decl.pName)
        IF flags.read
          ctx.out.write("(0,0)")
        }
      ELSEIF (type.ttype == Type.Enum.proc || type.ttype == Type.Enum.func)
                                                        && !flags.objectMember
        # using a method directly: "func = Class.method"
        string name
        IF decl.jsFName != NIL
          name = decl.jsFName
        ELSEIF decl.pName != NIL
          name = decl.pName
        ELSE
          Report.internal("jsFName and pNameis NIL for: \(decl)")
          name = "wrong"
        }
        # TODO: more arguments
        IF type.ttype == Type.Enum.proc
          ctx.out.write("new ProcRef0 { public void call() { \(name)()}")
        ELSE
          string retType = $vartypeString(decl.type.<MethodType>.returnType,
                                                 TRUE, TRUE, decl.zuiPos, ctx)
          ctx.out.write("new FuncRef0<\(retType) { public \(retType) call() { return \(name)()}")
        }
      ELSEIF decl.getClass() != NIL && !decl.type.isAllocType(ctx)
        IF flags.read && decl.type.isMethodOrRefType()
          # Calling an object method requires binding "this":
          #  $func -> Zbind(func, this)
          #  $var -> Zbind(this.var, this)
          ctx.out.write("Zbind(")
          IF decl.type.isMethodType()
            IF decl.jsFName == NIL || decl.jsFName == ""
              Report.internal("no jsFName for: \(decl)", decl.zuiPos)
            }
            ctx.out.write(decl.jsFName)
          ELSE
            IF decl.pName == NIL
              Report.internal("no pName for \(decl)")
            }
            ctx.out.write(ctx.scope.getThisName() .. "." .. decl.pName)
          }
          ctx.out.write(", " .. ctx.scope.getThisName() .. ")")
          ctx.setDeclUsed(%bind)
        ELSEIF decl.type.isMethodType()
          #  $func -> this.funcName
          IF decl.jsMName == NIL
            Report.internal("this.jsMName is NIL for \(decl)")
          }
          ctx.out.write(ctx.scope.getThisName() .. "." .. decl.jsMName)
        ELSE
          #  $var -> this.var
          IF decl.pName == NIL
            Report.internal("this.pName is NIL for \(decl)")
          }
          ctx.out.write(ctx.scope.getThisName() .. "." .. decl.pName)
        }
      ELSE
        ctx.out.write(decl.pName)
      }
    }
  }

  # Write the name of the variable |decl|.
  PROC $writeVarName(Declaration decl, SContext ctx)
    ctx.out.write(decl.pName)
  }

  PROC $namelessFuncUse(Declaration decl, SContext ctx)
    IF ctx.out.writing
      IF decl.jsMName != NIL
        ctx.out.write(decl.jsFName)
      ELSE
        # TODO: this should not be needed
        ctx.out.write(decl.pName)
      }
    }
  }

  PROC $namelessFuncReference(Declaration decl, ClassType class, SContext ctx)
    ctx.addUsedItem(decl)
  }

  # Using an object method as a function reference.  Need to allocate a
  # callback to store the object in.
  FUNC $objectCallbackUse(Declaration decl, Zui.Expression expr, SContext ctx
                         ) int
    MethodType methodType = decl.type
    CallbackType cb = methodType.getCallback(ctx)
    int undef
    $writeClosureAlloc(cb, methodType, TRUE, expr, &undef, ctx.out, ctx)
    RETURN 0
  }

  # Generate the type cast for a proc_ref or func_ref.
  PROC $refCast(Type type, Zui.Position pos, SContext ctx)
    # Javascript doesn't need a type cast.
    # (Vobj.Vmember)(arg1, arg2)
    ctx.out.write("(")
  }

  # Generate a type cast for a reference.
  PROC $refCast(SContext ctx)
  }

  # Generate an object initializer.
  PROC $objectInit(Zui.Expression initExpr, Declaration dest, SContext ctx)
    Type destType = dest?.type
    ClassType classType = destType?.getClassType(ctx)
    IF classType == NIL
      IF ctx.doError()
        ctx.error("Destination must be an object", initExpr.getPos())
      }
    ELSE
      string tmpName = getUid(ctx.scope.ToString())
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      ctx.outs.varOut.write(" var " .. tmpName .. ";\n")
      ctx.out.write("(" .. tmpName .. " = ")
      string separator = ", "
      Generate.generateEmptyNewCall(initExpr.getPos(), destType, ctx)

      SymUse symUse = NEW(initExpr.getPos(), ctx)
      ctx.addUsedItem(destType)
      FOR init IN initExpr.getInitItemList()
        string name = init.getName()
        Zui.Expression expr = init.getValue()
        Declaration decl = classType.findObjectMember(name, symUse,
                                                           :searchParent, TRUE)
        IF decl == NIL
          IF ctx.doError()
            ctx.error("Member not found in class: " .. name, expr.getPos())
          }
        ELSE
          ctx.out.write(separator .. tmpName .. "." .. decl.pName .. " = ")
          Generate.genExprDoConv(expr, ctx, decl.type)
          initExpr.<ZuiExpressionExt>.undefined +=
                                          expr.<ZuiExpressionExt>.undefined
          ctx.addUsedItem(decl)
        }
      }
      ctx.out.write(", " .. tmpName .. ")")
    }
  }

  FUNC $methodReturnType(Zui.Declaration decl, bool isNew, bool isInit,
                                                          SContext ctx) Type
    # Making everything public is the easiest.
    ctx.out.write("public ")

    Scope outer = ctx.scope.outer
    IF (outer != NIL && outer.scopeName == NIL)
              || outer ISA ModuleScope
              || outer.scopeType == Scope.Stype.shared
              || isNew
      ctx.out.write("static ")
    }

    IF decl.getType().getAttr().getAbstract()
      ctx.out.write("abstract ")
    }

    Type retType
    Zui.TypeEnum type = decl.getType().getType()
    IF isNew || isInit
      retType = ctx.scope.classType
      $vartype(retType, TRUE, decl.getPos(), ctx)
    ELSEIF type == Zui.TypeEnum.eFUNC
      Zui.MethodType method = decl.getType().getMethodDecl()
      retType = getFuncReturnType(method, ctx)
      IF retType != NIL
        $vartype(retType, TRUE, method.getReturnType(0).getName().getPos(), ctx)
      }
    ELSE
      ctx.out.write("void ")
    }

    RETURN retType
  }

  FUNC $hasThisArgument(Declaration decl, SContext ctx) bool
    RETURN ctx.scope.isClassScope() && decl.getClassName() != NIL
             && ctx.scope.insideBuiltin() && decl.type.<MethodType>.hasIfnil()
  }

  PROC $methodStart(Declaration decl, bool isNew, bool hasArguments,
                                                                 SContext ctx)
    IF decl.jsMName != NIL && !isNew
      ctx.out.write(decl.jsMName .. "(")
    ELSE
      ctx.out.write(decl.pName .. "(")
    }
    IF ctx.scope.isClassScope()
      IF isNew
        # NEW() and Init() use "thisO" as the first argument.
        $vartype(ctx.scope.classType, TRUE, decl.zuiDecl.getPos(), ctx)
        ctx.out.write(newThisName)
        IF hasArguments
          ctx.out.write(", ")
        }
      ELSEIF decl.type.<MethodType>.hasIfnil()
        # When using IFNIL we call with function(object, args)
        # instead of object.function(args).
        ctx.out.write("thisArg")
        IF hasArguments
          ctx.out.write(", ")
        }
      }
    }

    # If this is an Init() or EarlyInit() method we need a variable to hold
    # the result.
    IF decl.name == "Init" || decl.name == "EarlyInit"
                                                  && !ctx.scope.isClassScope()
      string pName = decl.pName
      string readyName
      IF decl.name[0] == 'E'
        pName ..= "__e"
        readyName = "EarlyReady"
      ELSE
        pName ..= "__r"
        readyName = "Ready"
      }
      IF decl.scopeName != NIL
        readyName = decl.scopeName .. "." .. readyName
      ELSE
        readyName = ctx.scope.name .. "." .. readyName
      }
      ctx.outs.declOut.write("static boolean \(pName) = false; // \(readyName)\n")
    }
  }

  PROC $writeReadyCheck(string readyName, string pName, Output out) @replace
    out.write("    if (!\(readyName)) {\n")
    out.write("      \(readyName) = \(pName)();\n")
    out.write("      done &= \(readyName) ? 1 : 0;\n")
    out.write("    }\n")
  }

  PROC $writeMethodCall(Declaration funcDecl, bool moreArgs, SContext ctx)
    # TODO: handle IFNIL here?
    IF funcDecl.getClassName() != NIL
      ctx.out.write(ctx.scope.getThisName())
      ctx.out.write(".")
    }
    IF funcDecl.jsMName != NIL
      ctx.out.write(funcDecl.jsMName)
    ELSE
      ctx.out.write(funcDecl.pName)
    }
    ctx.out.write("(")
  }

  # object.Type()
  PROC $callObjectType(Zui.MethodCall call, ClassType class, Type object,
                                            Zui.Expression expr, SContext ctx)
    IF object.getEffType().ttype == Type.Enum.object && class.parent == NIL
      ctx.out.write(class.pName)
      ctx.out.write("__T")
    ELSE
      ctx.out.write("(")
      Generate.generateVarname(expr, ctx, object)
      ctx.out.write(".__t)")
    }
  }

  # $Type()
  PROC $callObjectType(Zui.MethodCall call, ClassType class, SContext ctx)
    IF !class.hasCountExtends()
      ctx.out.write(class.pName)
      ctx.out.write("__T")
    ELSE
      ctx.out.write("(")
      ctx.out.write(ctx.scope.getThisName())
      ctx.out.write(".__t)")
    }
  }

  # object.ToString()
  PROC $callObjectToString(Zui.MethodCall call, ClassType class, Type object,
                                            Zui.Expression expr, SContext ctx)
    $setDeclUsed(%object2string)
    ctx.out.write("ZobjectToString(")
    Generate.generateVarname(expr, ctx, object)
    ctx.out.write(")")
  }

  # Add a DEFER'ed function to the defer list
  PROC $addDefer(Zui.MethodCall call, Generate.CallbackInfo cbInfo,
                                                                 SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("deferList.push(")
    int undef
    $writeCallbackAlloc(cbInfo.callback, NIL, cbInfo, call, &undef, ctx)
    ctx.out.write(");\n")
    IF ctx.scope.inTry()
      # When an exception is thrown after this only DEFER from called
      # methods are to be called in CATCH, not this one.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("tryDeferLen = deferList.length;\n")
    }
  }

  # Call to a function reference.
  FUNC $functionRefCall(Zui.MethodCall call,
                        Declaration decl, Zui.Expression expr,
                        string funcName, Type destType, SContext ctx
                       ) Type
    ctx.out.write("(")
    MethodType type

    IF expr != NIL
      Type funcType = Generate.genExpr(expr, ctx)
      IF funcType == NIL || (!funcType?.isMethodOrRefType() && ctx.doError())
        ctx.error("Method reference expected, got \(Type.typeName(funcType))",
                                                                         expr)
        RETURN Type.anUnknown
      }
      type = funcType?.getMethod()
    ELSE
      # When funcName is NIL call the method directly:  { => "foo" }()
      Type refType = decl.type
      IF refType == NIL
        ctx.error("Unknown reference type", call.getPos())
        RETURN Type.anUnknown
      }
      type = refType.getMethod()
      Type useType = funcName == NIL ? type : refType
      # Pass a FALSE for the "read" argument so that we get the name itself.
      $writeSymName(decl, useType, NIL, :objectMember, ctx)
    }

    ctx.out.write(")(")
    Generate.generateArgumentsCheck(call, funcName, ctx, type, destType)
    ctx.out.write(")")
    RETURN type.returnType
  }

  # Call to a method reference.
  FUNC $methodRefCall(Zui.MethodCall call,
                  Type mtype,
                  Type object,
                  Zui.Expression objExpr,
                  string pName,
                  Type destType,
                  SContext ctx) Type
    Output varnameOut = NEW(ctx.out.writing)
    SContext varnameCtx = ctx.copy(varnameOut)
    $refCast(mtype, objExpr.getPos(), varnameCtx)
    Declaration decl = Generate.generateVarname(objExpr, varnameCtx, object)
    $member(varnameOut, objExpr.getPos(), decl == NIL ? NIL : decl.type,
                                                       NIL, FALSE, pName, ctx)
    # TODO: handle callback with extra arguments
    ctx.out.write(")(")

    MethodType mt = mtype.getMethod()
    string methodName = call.getName().getRight().getName()
    Generate.generateArgumentsCheck(call, methodName, ctx, mt, destType)
    ctx.out.write(")")

    IF mt != NIL && mt.returnType != NIL
      RETURN mt.returnType
    }
    RETURN NIL
  }

  FUNC $objectCall(Zui.MethodCall call,
                   bool i_object_arg,
                   list<Declaration.C> arglist,
                   Declaration mdecl,
                   Type objectType,
                   Zui.Expression objExpr,
                   string pName,
                   Type destType,
                   SContext ctx) Type
    string methodName = call.getName().getRight().getName()
    MethodType methodType
    IF mdecl.type ISA CallbackType
      # The method is actually a callback:
      #     {object}->callback({object}->callback, {object}, args)
      # A bit like functionRefCall()
      methodType = mdecl.type.<CallbackType>.methodType
    ELSE
      # Normal method: method({object}, args)
      methodType = mdecl.type
    }
    Type retType = methodType.returnType

    bool dotnil
    bool init
    Zui.Expression nameExpr = call.getName()   # object.method()

    # Java is easy, it takes care of everything.
    #      object.method(arg) -> object.method(arg)
    # But for PARENT we need to do something else:
    #      PARENT.method() -> parentMethod.call(this)
    # TODO: PARENT.PARENT.method()
    IF objExpr.getType() == Zui.ExprType.ePARENT
      ctx.out.write(mdecl.jsFName .. ".call(this")
      IF call.hasArgument()
        ctx.out.write(", ")
      }
    ELSEIF methodType.hasIfnil()
      # If the method has IFNIL inside we pass the object as the first
      # argument:  object.method(arg) -> method(object, arg)
      ctx.out.write(mdecl.jsFName .. "(")
      Generate.generateVarname(objExpr, ctx, objectType)
      IF methodType.hasAnyArguments()
        ctx.out.write(", ")
      }
    ELSE
      string funcName

      IF mdecl == NIL
        Report.internal("no decl: " .. methodType.typeToString(),
                                                             objExpr.getPos())
        funcName = "MISSING"
      # TODO: this check should not be needed
      ELSEIF mdecl.jsMName == NIL
        funcName = mdecl.pName
      ELSE
        funcName = mdecl.jsMName
      }

      # For object?.method(arg)  generate:
      #    (var tmp = object, tmp ? tmp.method(arg) : 0)
      # For object.Init() generate:
      #    (var tmp = object, tmp.method(tmp))
      dotnil = nameExpr.hasDotnil() && nameExpr.getDotnil()
      init = methodName == "Init"
      string tmp
      # TODO: side effect of objExpr to be avoided.
      # Can't use comma operator in Java.
#      IF dotnil || init
#        tmp = getUid(ctx.scope.scopeName)
#        ctx.outs.varOut.writeIndent(ctx.scope.depth)
#        ctx.outs.varOut.write($vartypeString(objectType, TRUE,
#                                       objExpr.getPos(), ctx) .. tmp .. ";\n")
#        ctx.out.write("((" .. tmp .. " = ")
#      }

      Generate.generateVarname(objExpr, ctx, objectType)

      IF dotnil
        # ctx.out.write("), " .. tmp .. " != null ? ")
        # ctx.out.write(tmp)
        ctx.out.write(" != null ? ")
        Generate.generateVarname(objExpr, ctx, objectType)
      ELSEIF init
        # ctx.out.write("), " .. tmp)
      }
      ctx.out.write("." .. funcName .. "(")
      IF init
        # ctx.out.write(tmp)
        Generate.generateVarname(objExpr, ctx, objectType)
      }
    }
    Generate.generateArgumentsCheck(call, methodName, ctx, methodType, destType)
    ctx.out.write(")")
    IF dotnil
      ctx.out.write(" : ")
      $defaultInit(methodType.returnType, ctx.out, ctx)
      # ctx.out.write(")")
    ELSEIF init
      # ctx.out.write(")")
    }

    RETURN retType
  }

  # Write the code for a method using the member table:
  # "(type)(obj->mt[idx])"
  PROC $objectMethodName(Declaration mdecl, MethodType methodType,
            string objectExpr, ClassType class, bool objectIsInterface,
            SContext ctx)
    ctx.out.write(mdecl.pName)
  }

  PROC $usingIobjectMethod(Declaration mdecl,
                   list<Declaration.C> arglist,
                   Type objectType,
                   int &udef,
                   string methodName,
                   Zui.Position pos,
                   string baseFuncName,
                   SContext ctx)
  }


  # TODO: this should not be used in Java
  FUNC $generateVirtualFunc(VirtFuncArgs args, SContext ctx) Declaration
    IF $virtualFuncMap.has(args.funcKey)
      RETURN $virtualFuncMap.get(args.funcKey)
    }

    # Make a list with list of possible symbols for THIS and each argument.
    # altList[0] for A0 THIS
    # altList[1] for A1 arg 1
    # altList[1] for A2 arg 2
    # etc.
    # TODO: for Javascript different methods may end up being the same code,
    # e.g. "obj1.get()" and "obj2.get()" -> "A0.get()"
    list<list<Declaration>> altList = createAltList(args, ctx)
    IF altList == NIL
      RETURN NIL
    }

    # For every permutation find a matching function.
    # E.g. A0 is an i_object with 2 possible classes, A2 is an i_object with
    # three possible classes
    #        if (A0 instanceof Class1) {
    #          if (A2 instanceof ClassA) {
    #            return A0.func_obj0_obj0(A1, A2);
    #          } else if (A2 instanceof ClassB) {
    #            return A0.func_obj0_itf(A1, A2);
    #          } else if (A2 instanceof ClaccC) {
    #            return A0.func_obj0_itf(A1, A2);
    #          }
    #        } else if (A0 instanceof Class2) {
    #          if (A2 instanceof ClassA) {
    #            return A0.func_obj1_obj0(A1, A2);
    #          } else if (A2 instanceof ClassB) {
    #            return A0.func_obj1_itf(A1, A2);
    #          } else if (A2 instanceof ClaccC) {
    #            return A0.func_obj1_itf(A1, A2);
    #          }
    #        }
    #
    # Every possible class must have a matching method, either with that class
    # or with an interface.

    Output tmpOut = NEW()
    tmpOut.writing = ctx.out.writing
    string lastCall
    set<int> argNotNull = NEW()  # argument indices that can't be NIL
    int maxTmpIdx

    # depth indicates what to do when a matching func is found:
    # 0: -
    # 1: write "if" for A0
    # 2: -
    # 3: write "if" for A1
    # etc.
    int depth

    WHILE TRUE
      list<Declaration.C> argtry = NEW()
      Declaration mdecl = virtFuncFindMethod(args, altList, argtry, ctx)
      Type mtype = mdecl?.type
      IF mtype != NIL
        WHILE depth < 2 * altList.Size()
          int idx = depth / 2
          IF altList[idx].Size() > 1
            IF (depth & 1) == 0
              argNotNull.set(idx)
            ELSE
              int ifIdx = args.indexes[idx]
              IF ifIdx == 0
                tmpOut.write(" { if (")
              ELSE
                tmpOut.write(" } else if (")
              }
              Type type
              IF idx == 0
                type = altList[0][args.indexes[0]].type
              ELSE
                type = argtry[idx - 1].type
              }
              IF type.getClassType(ctx) != NIL
                type = type.getClassType(ctx)
              }
              IF $isDeclUsed(type)
                tmpOut.write("A" .. idx .. " instanceof " .. type.pName)
              ELSE
                tmpOut.write("false")  # TODO: skip the whole if block
              }
              tmpOut.write(") {\n")
            }
          }
          depth++
        }

        # Generate the function call only if it was marked as used.
        IF $isDeclUsed(mdecl)
          IO.StringWriter sw = NEW()
          sw.write("   ")
          IF mtype.ttype == Type.Enum.func
            sw.write("return ")
          }
          sw.write("A0." .. mdecl.jsMName .. "(")
          int tmpIdx
          list<Declaration.C> methodArgList = mtype.getArgList()
          FOR ai IN 0 UNTIL argtry.Size()
            IF args.callArglist[ai].type.ttype == Type.Enum.iobject
              ClassType srcClass = args.callArglist[ai].type.getClassType(ctx)
              ClassType destClass = methodArgList[ai].type.getClassType(ctx)
              IF argtry[ai].type.ttype != Type.Enum.iobject
                          && methodArgList[ai].type.ttype != Type.Enum.iobject
                # iobject -> object
                int idx = srcClass.childIndex(destClass, FALSE)
                IF idx < 0
                  ctx.error("Class type mismatch " .. srcClass.typeName()
                                          .. " to " .. destClass.typeName(),
                                                                     args.pos)
                }
              }
            }
            IF ai > 0
              sw.write(", ")
            }
            sw.write("A" .. (ai + 1))
          }
          sw.write(");")
          IF maxTmpIdx < tmpIdx
            maxTmpIdx = tmpIdx
          }

          # The call up to here is remembered for if there is only one method.
          lastCall = sw.ToString()
          tmpOut.write(lastCall)
          sw.clear()

          IF mtype.ttype != Type.Enum.func
            tmpOut.write(" return;")
          }
          tmpOut.write("\n")
        ELSE
          tmpOut.write("   return")
          IF mtype.ttype == Type.Enum.func
            tmpOut.write(" 0")
          }
          tmpOut.write(";\n")
        }
      }

      # Advance to the next class for the argument.
      depth = advanceToNextClass(altList, args, depth, tmpOut)
      IF depth <= 0
        BREAK
      }
    }

    $virtualDeclOut.writing = ctx.out.writing
    $virtualBodyOut.writing = ctx.out.writing

    Output headOut = NEW()
    headOut.writing = ctx.out.writing
    SContext virtualCtx = ctx.copy(headOut)

    # When writing use a short name instead of the function key name.
    string funcName = args.funcKey
    IF ctx.out.writing
      funcName = getUid(args.funcKey)
    }
    headOut.write("function " .. funcName .. "(")

    # produce the arguments: "(classType A0, arg1Type A1, arg2Type A2)"
    IF args.varType.ttype == Type.Enum.object
      $vartype(args.varType.getClassType(ctx), TRUE, args.pos, virtualCtx)
    ELSE
      $vartype(args.varType, TRUE, args.pos, virtualCtx)
    }
    headOut.write("A0")
    int argIdx = 1
    FOR d IN args.callArglist
      headOut.write(", ")
      headOut.write("A" .. argIdx)
      argIdx++
    }
    headOut.write(")")

    # Append the function body to virtualBodyOut.
    $virtualBodyOut.append(headOut)
    $virtualBodyOut.write(" { /* " .. args.funcKey .. " */\n")

    IF args.haveTwoMethods
      # The type of object matters.  When an argument is NIL we don't know
      # what method to call, thus throw an exception.
      IF argNotNull.Size() > 0
        FOR ai IN argNotNull.keys()
          string what
          IF ai == 0
            what = "object"
          ELSE
            what = "argument " .. ai
          }
          $setDeclUsed(Declaration.throwCstringNil)
          $virtualBodyOut.write(" if (A" .. ai
              .. " == null) ZthrowNil(\""
              .. args.methodName .. ": "
              .. what .. " is NIL, cannot select method to invoke\");\n")
        }
      }

      $virtualBodyOut.append(tmpOut)
      # If we get to the end something is wrong.
      string throwBadValue = DeclStore.getPName("MEModule", "FthrowBadValue")
      $virtualBodyOut.write(" " .. throwBadValue .. "(\""
              .. args.methodName .. ": cannot select method to invoke\");\n")
      $setDeclUsed(Declaration.throwCstringBadValue)
      # Avoid a compiler warning for missing return.
      IF args.retType == NIL || args.retType.ttype == Type.Enum.unknown
        $virtualBodyOut.write(" return;\n")
      ELSE
        $virtualBodyOut.write(" return ")
        $defaultInit(args.retType, $virtualBodyOut, ctx)
        $virtualBodyOut.write(";\n")
      }
    ELSE
      # There is only one method to call, do that directly here.
      $virtualBodyOut.write(lastCall)
      $virtualBodyOut.write("\n")
    }
    $virtualBodyOut.write("}\n")

    Declaration.C funcDecl = NEW(funcName)
    funcDecl.type = args.retType
    IF args.retType != NIL && args.retType.ttype == Type.Enum.object
      # It is possible that a child is found for a class later, then
      # the type changes from object to iobject and we need to come
      # back here to take care of that.
      ClassType ct = args.retType.getClassType(ctx)
      IF ct != NIL
        ct.scope.addScopeDependency(ctx.scope)
      }
    }

    IF ctx.out.writing
      $virtualFuncMap[args.funcKey] = funcDecl
    }
    RETURN funcDecl
  }

  # "object.member.(expr)(arg)" -> (expr).call(object.member, arg);
  FUNC $memberExpr(Zui.MethodCall call, Generate.CallbackInfo cbInfo,
                                             SContext ctx, Type destType) Type
    Zui.Expression nameExpr = call.getName()
    ZuiMethodCallExt callExt = call

    # Evaluate "(expr)": function pointer
    ctx.out.write("(")
    # TODO: when the expression has side effects need a temp var.
    genExpr(nameExpr.getRight(), ctx)

    ctx.out.write(")")
    ctx.out.write(".call(")

    # Evaluate "object.member", the THIS argument for the method.
    MethodType mt = callExt.typeObj.getMethod()
    Type exprType = genExpr(nameExpr.getLeft(), ctx,
                                               mt.classType.getValueType(ctx))

    # Evaluate "(arg)"
    list<Declaration.C> argList = callExt.typeObj.getArgList()
    IF argList != NIL && argList.Size() > 0
      ctx.out.write(", ")
      Generate.generateArgumentsCheck(call, "{expr}", ctx, argList, NIL,
                                                                     destType)
    }
    ctx.out.write(")")

    IF callExt.typeObj != NIL
      RETURN callExt.typeObj.getReturnType()
    }
    RETURN NIL
  }

  PROC $argWithType(bool first, Type type, Zui.Position pos,
                                                 string argName, SContext ctx)
    IF !first
      ctx.out.write(", ")
    }
    $vartype(type, TRUE, pos, ctx)
    ctx.out.write(argName)
  }

  FUNC $writeVarargs(Zui.MethodCall call, Type type, TupleType tupleType,
                  list<Zui.Expression> args, int startIndex, SContext ctx) int
    WriteArrayJava.writeVarargs(call, type, tupleType, args, startIndex, ctx)
    RETURN 0
  }

  # Return TRUE when forward declarations are to be written.
  FUNC $doWriteDecl() bool
    RETURN FALSE
  }

  FUNC $subscript(Zui.Expression expr, SContext ctx, Type destType) Type
    Zui.Expression left = expr.getLeft()
    Zui.Expression right = expr.getRight()

    # Get type of "expr".
    # TODO: this is a hack, it should be possible to use expr.typeObj
    Type type = genExpr(left, ctx.copyNoOut())

    Type ret
    IF type != NIL
      Type effType = type.getEffType()
      IF effType.ttype == Type.Enum.array
        ret = WriteArrayJava.generateSubscript(effType.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF effType.ttype == Type.Enum.list
        ret = WriteListJava.generateSubscript(effType.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF effType.ttype == Type.Enum.dict
        ret = WriteDictJava.generateSubscript(effType.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF effType.ttype == Type.Enum.stringval
          || effType.ttype == Type.Enum.string
          || effType.ttype == Type.Enum.byteString
          || effType.ttype == Type.Enum.varString
          || effType.ttype == Type.Enum.varByteString
        ctx.out.write("(")
        $genStringExpr(left, ctx, effType)
        ctx.out.write(").charAt((int)")
        genExpr(right, ctx, Type.anInt)
        ctx.out.write(")")
        ret = Type.anInt
      ELSEIF effType.ttype == Type.Enum.tuple
        # tupleVar[3]
        ret = $tupleSubscript(effType.<TupleType>, left, right, ctx)
      # TODO: multiple
      ELSEIF ctx.out.writing
        ctx.error("type does not (yet) allow subscript: "
                                                     .. type.typeName(), expr)
      }
    ELSEIF ctx.out.writing
      # Generate the error message for "expr"
      genExpr(left, ctx)
    }
    RETURN ret
  }

  FUNC $tupleSubscript(TupleType type, Zui.Expression left,
                                      Zui.Expression right, SContext ctx) Type
    bool dummy
    int idx = ExprEval.evalInt(right, ctx, TRUE, &dummy)
    IF idx < 0 || idx >= type.types.Size()
      IF ctx.doError()
        ctx.error("Subscript out of range: " .. idx
                       .. ", must be 0 .. " .. (type.types.Size() - 1), right)
      }
      RETURN NIL
    }
    RETURN $tupleItem(type, left, idx, ctx)
  }

  FUNC $varnameSubscript(Type type, Zui.Expression expr, bool lvalue,
                                             SContext ctx, Type destType) Type
    Type.Enum ttype = type?.getTtype()
    IF ttype == Type.Enum.tuple
      # tupleVar[3]
      RETURN $tupleSubscript(type.getEffType().<TupleType>,
                                         expr.getLeft(), expr.getRight(), ctx)
    }

    Type effType = type?.getEffType()
    IF effType != NIL && effType ISA ContainerType
      ContainerType cont = effType
      IF ttype == Type.Enum.array
        WriteArrayJava.generateSubscript(cont, expr, lvalue, ctx, destType)
      ELSEIF ttype == Type.Enum.list
        WriteListJava.generateSubscript(cont, expr, lvalue, ctx, destType)
      ELSEIF ttype == Type.Enum.dict
        WriteDictJava.generateSubscript(cont, expr, lvalue, ctx, destType)
      }
      RETURN cont?.itemType
    ELSE
      Generate.generateVarnamePart(expr.getLeft(), FALSE, ctx, destType)
      ctx.out.write("[")
      genExpr(expr.getRight(), ctx, Type.anInt)
      ctx.out.write("]")
    }
    RETURN NIL
  }

  # Generate a tuple member by index.
  FUNC $tupleItem(TupleType type, Zui.Expression left, int idx,
                                                            SContext ctx) Type
    ctx.out.write("(")
    genExpr(left, ctx, type)
    ctx.out.write(").a")
    ctx.out.write(idx + 1)
    RETURN type.types[idx].type
  }


  PROC $tupleItem(string tempName, int idx, Zui.Position pos, SContext ctx)
    ctx.out.write(tempName)
    ctx.out.write(".a")
    ctx.out.write(idx + 1)
  }

  PROC $multiReturnItem(Declaration tempDecl, int i,
                                   Zui.Position pos, Output out, SContext ctx)
    out.write(tempDecl.pName)
    out.write(".a\(i + 1)")
  }


  FUNC $useDictAssignFunction() bool
    RETURN TRUE
  }

  FUNC $dictAssign(string varname, string key, SContext ctx) string
    RETURN WriteDictJava.dictAssign(varname, key, ctx)
  }

  FUNC $funcCallForRef(Zui.Expression expr, Generate.LhsEntry entry,
                                                          SContext ctx) string
    IF Generate.isByRef(expr, ctx)
      # The variable passed in in a function(write, val) which returns the
      # value.
      RETURN entry.varname .. "(1, "
    }
    RETURN NIL
  }

  FUNC $dictGet(ContainerType type, Zui.Expression dictExpr,
                                                       Zui.Expression keyExpr,
                         Zui.Expression defExpr, SContext ctx, Type destType
                 ) Type
    RETURN WriteDictJava.generateGet(
                       type, dictExpr, keyExpr, defExpr, FALSE, ctx, destType)
  }

  # Generate accessing an object member |objDecl| of an interface |itfType|.
  PROC $iobjectMember(Declaration objDecl, Type itfType,
                      Zui.Expression expr, bool dotnil,
                      SContext ctx, Type destType, bool genVarname)
    # some.member
    string id
    IF dotnil
      # var?.member ->  ((id = var) ? id.member : null/0)
      id = getUid(ctx.scope.ToString())
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      ctx.outs.varOut.write($vartypeString(itfType, TRUE,
                                           expr.getPos(), ctx) .. id .. ";\n")
      ctx.out.write("((")
      ctx.out.write(id)
      ctx.out.write(" = ")
    }
    Zui.Expression left = expr.getLeft()
    IF genVarname
      Generate.generateVarnamePart(left, FALSE, ctx, destType)
    ELSE
      genExpr(left, ctx, destType)
    }
    IF dotnil
      ctx.out.write(") ? ")
      ctx.out.write(id)
    }
    ctx.out.write("." .. objDecl.pName)
    IF dotnil
      ctx.out.write(" : ")
      $defaultInit(destType, ctx.out, ctx)
      ctx.out.write(")")
    }
  }

  # Generate accessing an iobject member |objDecl| of an interface |itfType|.
  PROC $iobjectCallbackMember(Declaration methodDecl,
                       Declaration objDecl, Type itfType,
                      Zui.Expression expr, bool dotnil,
                      SContext ctx, Type destType, bool genVarname)
    $iobjectMember(objDecl, itfType, expr, dotnil, ctx, destType, genVarname)
  }

  FUNC $iobjectFuncUse(Declaration objDecl, Type itfType,
                                        Zui.Expression expr, SContext ctx) int
    genExpr(expr, ctx, Type.aParent)
    Output out = ctx.out
    out.write(".")
    MethodType mtype = objDecl.type
    IF mtype.parentMethod != NIL
      # Use the original method name, it's inherited from the parent.
      mtype = mtype.parentMethod
    }
    out.write(mtype.jsMName)
    RETURN 0
  }

  # Binary operator with int or bits values.
  FUNC $numberOp(Zui.Expression expr, SContext ctx, Type destType) Type
    ZuiExpressionExt exprExt = expr
    IF expr.getType() == Zui.ExprType.eDIVIDE
               && (exprExt.leftExprType == NIL
                               || exprExt.leftExprType.ttype == Type.Enum.int)
      # Javascript always uses float but in Zimbu "/" truncates.
      ctx.out.write("Math.floor")
    }
    RETURN numberOp(expr, ctx)
  }

  FUNC $stringConcat(Zui.Expression expr, string cast, SContext ctx) string
    ctx.out.write(" += ")
    RETURN ""
  }

  FUNC $varStringConcatAssign(Zui.Assignment assign, SContext ctx) int
    IF ctx.out.writing
      ctx.error("..= not implemented yet for varString", assign.getLhs())
    }
    RETURN 0
  }

  PROC $concatStringOp(Zui.Expression expr, SContext ctx, Type destType)
    $commonConcatStringOp(expr, %null2nil, ctx, destType)
  }

  PROC $concatVarStringOp(Zui.Expression expr, SContext ctx, Type destType)
    Type interType = destType == Type.aVarByteString
                                             ? Type.aByteString : Type.aString
    IF destType == Type.aVarString || destType == Type.aVarByteString
      ctx.out.write("[")
    }
    Generate.genExprDoConv(expr.getLeft(), ctx, interType)
    ctx.out.write(" + ")
    Generate.genExprDoConv(expr.getRight(), ctx, interType)
    IF destType == Type.aVarString || destType == Type.aVarByteString
      ctx.out.write("]")
    }
  }

  # A sequence of string concatenation operators.
  PROC $concatStringOp(list<Zui.Expression> concats,
                                                  SContext ctx, Type destType)
    $setDeclUsed(%null2nil)
    string plus = "Znull2nil("
    FOR expr IN concats
      ctx.out.write(plus)
      Generate.genExprDoConv(expr, ctx, destType)
      plus = ") + Znull2nil("
    }
    ctx.out.write(")")
  }

  # Generate code for a literal number.
  PROC $generateInt(Zui.Expression expr, SContext ctx)
    int n = expr.getNumber()
    IF expr.getType() == Zui.ExprType.eNAT
      # The nat was stored as an int, turn it back into a nat here.
      nat u = n
      ctx.out.write(u .. "L")
    ELSE
      ctx.out.write(n .. "L")
    }
  }

  # Generate code for a literal float number.
  PROC $generateFloat(Zui.Expression expr, SContext ctx)
    # With 64 bits there are about 16 significant digits.
    ctx.out.write(expr.getFnumber().ToString(".16g"))
  }

  PROC $writeByteString(byteString value, Output out)
    int i = 0
    WHILE i < value.Size()
      int c = value[i]
      # Handle limited set of special characters.
      IF c == '\n'
        out.write("\\n")
      ELSEIF c == '\r'
        out.write("\\r")
      ELSEIF c == '\t'
        out.write("\\t")
      ELSEIF c == '\''
        out.write("\\'")
      ELSEIF c == '\\'
        out.write("\\\\")
      ELSEIF c >= 0x20 && c < 0x7f
        # ASCII character
        out.write(c.asString())
      ELSE
        # other character: \xff
        out.write("\\x" .. c.toHex(2))
      }
      i++
    }
  }

  # Generate code for a string from a stringLiteral |expr|.
  # Also handle a op_concat expr that concats strings.
  PROC $literalStringValue(Zui.Expression expr, SContext ctx)
    ctx.out.write("\"")
    Generate.generateStringExpr(expr, ctx.out)
    ctx.out.write("\"")
  }

  # Generate code for a string value.
  PROC $writeStringValue(string value, SContext ctx)
    ctx.out.write("\"")
    WriteCommon.writeString(value, ctx.out)
    ctx.out.write("\"")
  }

  # Generate code for a byteString from a stringLiteral |expr|.
  # Also handle a op_concat expr that concats strings.
  PROC $literalByteStringValue(Zui.Expression expr, SContext ctx)
    ctx.out.write("'")
    $generateByteStringExpr(expr, ctx.out)
    ctx.out.write("'")
  }

  PROC $generateByteStringExpr(Zui.Expression expr, Output out)
    IF expr.getType() == Zui.ExprType.eSTRING
      $writeByteString(expr.getStringValue().asByteString(), out)
    ELSEIF expr.getType() == Zui.ExprType.eBYTESTRING
      $writeByteString(expr.getByteStringValue(), out)
    ELSE
      CHECK.true(expr.getType() == Zui.ExprType.eCONCAT)
      $generateByteStringExpr(expr.getLeft(), out)
      $generateByteStringExpr(expr.getRight(), out)
    }
  }

  # Generate code to set varByteString |dest| from a stringLiteral |expr|.
  PROC $varByteStringSetString(Zui.Expression expr, Declaration dest,
                                                                 SContext ctx)
    Output out = ctx.out
    out.write(dest.pName)
    out.write("[0] = ")
    $literalByteStringValue(expr, ctx)
  }

  PROC $incrdecrOp(Zui.Expression expr, SContext ctx)
    incrdecrOp(expr, ctx)
  }

  # "expr ISA classType" and "expr ISNOTA classType"
  PROC $isaOp(Zui.Expression expr, SContext ctx)
    IF ctx.out.writing
      Type rightType = $isaOpType(expr, ctx)
      IF rightType != NIL
        IF $isDeclUsed(rightType)
          ClassType rightClass = rightType.getClassType(ctx)
          string varName
          IF expr.getType() == Zui.ExprType.eISNOTA
            ctx.out.write("!")
          }
          ctx.out.write("(")
          IF Type.isInterfaceLike(rightType) && rightClass.implementers != NIL
            varName = getUid(ctx.scope.ToString() .. "x")
            ctx.out.write(varName ..  " = ")
          }
          genExpr(expr.getLeft(), ctx)

          string or = ""
          IF rightType.ttype == Type.Enum.interface
            # If rightType is an interface we only check implementers, not the
            # interface itself.
            ctx.out.write(", ")
          ELSE
            IF varName != NIL
              ctx.out.write(", " .. varName)
            }
            ctx.out.write(" instanceof ")
            ctx.out.write(rightClass.pName)
            or = " || "
          }
          IF varName != NIL
            FOR impl IN rightClass.implementers
              ctx.out.write(or)
              or = " || "
              ctx.out.write(varName .. " instanceof ")
              ctx.out.write(impl.pName)
            }
          }
          ctx.out.write(")")
        ELSEIF expr.getType() == Zui.ExprType.eISNOTA
          # The RHS type is not used, ISNOTA is always true.
          ctx.out.write("true")
        ELSE
          # The RHS type is not used, ISA is always false.
          ctx.out.write("false")
        }
      }
    }
  }

  PROC $booleanOp(Zui.Expression expr, bool isCompare, SContext ctx)
    bool isNot = expr.getType() == Zui.ExprType.eNOTEQUAL
              || expr.getType() == Zui.ExprType.eISNOT
              || expr.getType() == Zui.ExprType.eNOMATCH
              || expr.getType() == Zui.ExprType.eNOMATCHIC
    bool isMatch = expr.getType() == Zui.ExprType.eMATCH
                || expr.getType() == Zui.ExprType.eMATCHIC
                || expr.getType() == Zui.ExprType.eNOMATCH
                || expr.getType() == Zui.ExprType.eNOMATCHIC

    IF !isCompare && !isMatch
      # val == NAN and NAN == val need to use isNan().
      IF expr.getLeft().getType() == Zui.ExprType.eNAN
        IF expr.getType() == Zui.ExprType.eNOTEQUAL
          ctx.out.write("!")
        }
        $isNan(expr.getRight(), ctx)
        RETURN
      }
      IF expr.getRight().getType() == Zui.ExprType.eNAN
        IF expr.getType() == Zui.ExprType.eNOTEQUAL
          ctx.out.write("!")
        }
        $isNan(expr.getLeft(), ctx)
        RETURN
      }
    }

    string op = compareOp(expr)
    ZuiExpressionExt exprExt = expr
    IF exprExt.leftExprType == NIL
      # Avoid checking for NIL many times.
      exprExt.leftExprType = Type.anUnknown
    }
    IF exprExt.rightExprType == NIL
      # Avoid checking for NIL many times.
      exprExt.rightExprType = Type.anUnknown
    }

    IF isMatch
      bool isIgnoreCase = expr.getType() == Zui.ExprType.eMATCHIC
                       || expr.getType() == Zui.ExprType.eNOMATCHIC
      string new = DeclStore.getPName("MREModule__CRegex",
                                            isIgnoreCase ? "MNEW__1" : "MNEW")
      IF isNot
        ctx.out.write("!")
      }
      ctx.out.write("(")
      ctx.out.write(new)
      ctx.out.write("(null, ")
      genExpr(expr.getRight(), ctx, Type.aString)
      IF isIgnoreCase
        ctx.out.write(", 1).matches(")
      ELSE
        ctx.out.write(").matches(")
      }
      genExpr(expr.getLeft(), ctx, Type.aString)
      ctx.out.write("))")
      RETURN
    }

    IF exprExt.leftExprType.ttype == Type.Enum.dyn
                               || exprExt.rightExprType.ttype == Type.Enum.dyn
      IF isNot
        ctx.out.write("!")
      }
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
                               && exprExt.rightExprType.ttype == Type.Enum.dyn
        $writeFuncLeftRight(expr, isCompare ? "ZdynCompare" : "ZdynEqual",
                                                               Type.aDyn, ctx)
        IF isCompare
          ctx.out.write(op)
          ctx.out.write("0")
        }
        RETURN
      }
      ctx.out.write(isCompare ? "ZdynCompareOne(" : "ZdynEqualOne(")
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
        $wrapExpr(expr.getLeft(), ctx, Type.aDyn)
      ELSE
        $wrapExpr(expr.getRight(), ctx, Type.aDyn)
      }
      ctx.out.write(", ")
      Type other
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
        other = exprExt.rightExprType
        Generate.genTopExprDoConv(expr.getRight(), ctx, other)
      ELSE
        other = exprExt.leftExprType
        Generate.genTopExprDoConv(expr.getLeft(), ctx, other)
      }
      ctx.out.write(", ")
      ctx.out.write($getDynType(other, expr.getPos(), ctx))
      ctx.out.write(")")
      RETURN
    }

    Type.Enum ttype = exprExt.leftExprType.ttype
    string name
    SWITCH ttype
      CASE Type.Enum.object
        IF isNot
          ctx.out.write("!")
        }
        # Generate a call to left.Equal(right)
        Generate.generateEqualCall(expr, isCompare, ctx)
        IF isCompare
          ctx.out.write(op)
          ctx.out.write("0")
        }
        RETURN

      CASE Type.Enum.array
        $setDeclUsed(isCompare ? WriteArrayJava.arrayCompare
                                                   : WriteArrayJava.arrayEqual)
        name = "ZArray"
      CASE  Type.Enum.list
        $setDeclUsed(isCompare ? WriteListJava.listCompare
                                                     : WriteListJava.listEqual)
        name = "ZList"
      CASE Type.Enum.dict
        $setDeclUsed(isCompare ? WriteDictJava.dictCompare
                                                     : WriteDictJava.dictEqual)
        name = "ZDict"
    }
    IF name != NIL
      IF isNot
        ctx.out.write("!")
      }
      $writeFuncLeftRight(expr, name .. (isCompare ? "Compare" : "Equal"),
                                                                   NIL, ctx)
      IF isCompare
        ctx.out.write(op)
        ctx.out.write(" 0")
      }
      RETURN
    }

    ctx.out.write("(")
    IF ttype == Type.Enum.nilval || ttype == Type.Enum.iobject
      genExpr(expr.getLeft(), ctx, Type.aNil)
      ctx.out.write(op)
      genExpr(expr.getRight(), ctx, Type.aNil)
    ELSEIF ttype == Type.Enum.string || ttype == Type.Enum.string
      Generate.genExprDoConv(expr.getLeft(), ctx, Type.aString)
      ctx.out.write(".equals(")
      Generate.genExprDoConv(expr.getRight(), ctx, Type.aString)
      ctx.out.write(")")
    ELSE
      # TODO: this won't work for all types
      genExpr(expr.getLeft(), ctx, exprExt.leftExprType)
      ctx.out.write(op)
      genExpr(expr.getRight(), ctx, exprExt.rightExprType)
    }
    ctx.out.write(")")
  }

  PROC $andorOp(Zui.Expression expr, SContext ctx)
    andorOp(expr, ctx)
  }

  FUNC $parens(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    ctx.out.write("(")
    Type ret = Generate.genExprConv(expr.getRight(), ctx, exprArg)
    ctx.out.write(")")
    RETURN ret
  }

  FUNC $altOp(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    RETURN altOp(expr, ctx, exprArg)
  }

  FUNC $ifnilOp(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    string tmp = getUid(ctx.scope.ToString())
    ctx.out.write("((\(tmp) = ")

    Type typeL = Generate.genExprConv(expr.getLeft(), ctx, exprArg)
    ctx.out.write(") == null) ? (")
    ExprArg r = exprArg.copy()
    IF r.dest == NIL || !r.dest.type.typeDefined()
      # Helps for the argument of FOR.
      r.dest = typeL
    }
    Type typeR = Generate.genExprConv(expr.getRight(), ctx, r)
    ctx.out.write(") : \(tmp)")

    IF ctx.out.writing && typeL != NIL
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      ctx.outs.varOut.write($vartypeString(typeL, TRUE, expr.getPos(), ctx))
      ctx.outs.varOut.write("\(tmp);\n")
    }

    # TODO: if destType is NIL check typeL and typeR are the same type
    IF typeR == NIL || !typeR.typeDefined()
      typeR = typeL
    }
    IF typeR != NIL
      IF typeR.isValueType()
        ctx.error("Expected a reference", expr.getRight())
      }
      RETURN typeR
    }

    RETURN NIL
  }

  PROC $newVarByteString(string noAllocName, SContext ctx)
    # A varbytestring is represented as an array with one element, which is
    # the current string value.
    IF noAllocName == NIL
      ctx.out.write("['']")
    ELSE
      ctx.out.write(noAllocName)
      ctx.out.write(" = ['']")
    }
  }

  PROC $listInitStart(MethodType newFromList, Declaration dest,
                                                  SContext ctx, Type destType)
    ctx.out.write(newFromList.pName .. "(null, ")
  }

  PROC $listInitTail(SContext ctx)
    ctx.out.write(")")
  }

  PROC $dictInitStart(MethodType newFromDict, Declaration dest,
                                                  SContext ctx, Type destType)
    ctx.out.write(newFromDict.pName .. "(null, ")
  }

  PROC $dictInitTail(SContext ctx)
    ctx.out.write(")")
  }

  FUNC $newArrayInit(Zui.Expression expr, string noAllocName,
                                             Type destType, SContext ctx) Type
    RETURN WriteListJava.newListWithInit(expr, destType, ctx)
  }

  FUNC $newListInit(Zui.Expression expr, string noAllocName,
                                             Type destType, SContext ctx) Type
    RETURN WriteListJava.newListWithInit(expr, destType, ctx)
  }

  # tuple = [item, item]
  PROC $newTupleInit(Zui.Expression expr, string noAllocName,
                                             TupleType destType, SContext ctx)
    ctx.out.write("[")
    string comma = ""
    FOR idx IN 0 UNTIL destType.types.Size()
      ctx.out.write(comma)
      Zui.Expression item = expr.getListItem(idx)
      Generate.genExprDoConv(item, ctx, destType.types[idx].type)
      comma = ", "
    }
    ctx.out.write("]")
  }

  PROC $newDictInit(Zui.Expression expr, string noAllocName,
                            SContext ctx, ContainerType type, Type destType)
    WriteDictJava.generateNewDict(expr, ctx, type, destType)
  }

  PROC $writeDictAlloc(ContainerType type, string noAllocName,
                                            Zui.MethodCall call, SContext ctx)
    WriteDictJava.writeDictAlloc(type, noAllocName, call, FALSE,
                                                           call.getPos(), ctx)
  }

  FUNC $dictMethodCall(ContainerType type, Zui.MethodCall call,
                                                 SContext ctx, Type destType
                      ) Type
    RETURN WriteDictJava.generateMethodCall(type, call, ctx, destType)
  }

  FUNC $listMethodCall(ContainerType type, Zui.MethodCall call,
                                                 SContext ctx, Type destType
                      ) Type
    RETURN WriteListJava.generateMethodCall(type, call, ctx, destType)
  }

  FUNC $arrayMethodCall(ContainerType type, Zui.MethodCall call,
                                                 SContext ctx, Type destType
                      ) Type
    RETURN WriteArrayJava.generateMethodCall(type, call, ctx, destType)
  }

  # Bits assignment of |rhs| to |lhs|, of type |bitsMember|.
  # Return the number of undefined symbols in |lhs|.
  FUNC $bitsAssign(Zui.Expression lhs, Zui.Expression rhs,
                                     ValueType bitsMember, SContext ctx) int
    RETURN bitsAssign(lhs, rhs, bitsMember, ctx)
  }

  # A bool field in a BITS.
  PROC $bitsMemberBool(Zui.Expression left, ValueType memberType,
                                                                 SContext ctx)
    bitsMemberBool(left, memberType, ctx)
    ctx.out.write(" != 0")
  }

  # An int (or nat) member of a BITS
  PROC $bitsMemberInt(Zui.Expression left, ValueType memberType,
                                                                 SContext ctx)
    bitsMemberInt(left, memberType, ctx)
  }

  FUNC $expr(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    # First write the expression to a temporary output, so that we can wrap
    # the conversion around it when needed.
    Output exprOut = NEW()
    exprOut.writing = ctx.out.writing
    SContext exprOutCtx = ctx.copy(exprOut)
    Type type = Generate.genExprChecked(expr, exprOutCtx, exprArg)

    RETURN $conversion(expr, type, exprOut, ctx, exprArg)
  }

  FUNC $conversion(Zui.Expression expr, Type type,
                           Output exprOut, SContext ctx, ExprArg exprArg) Type
    # Detect the required conversion again.  It may change when producing a
    # method for multiple subclasses.
    Type typeConverted = Resolve.exprConversion(expr, type, ctx, exprArg)
    ZuiExpressionExt exprExt = expr

    # An expression may be visited more than once, check that the destination
    # type is specified.
    string close = ""
    IF exprArg.destType() != NIL
                              && exprArg.destType().ttype != Type.Enum.unknown
      SWITCH exprExt.conversion
        CASE Conversion.none
          BREAK

        CASE Conversion.string2varString
          ctx.setDeclUsed(%string2vs)
          ctx.out.write("Zstring2vs(")
          close = ")"

        CASE Conversion.string2byteString
          ctx.setDeclUsed(%string2bs)
          ctx.out.write("Zstring2bs(")
          close = ")"

        CASE Conversion.varString2string
          ctx.setDeclUsed(%varString2string)
          ctx.out.write("ZvarStringToString(")
          close = ")"

        CASE Conversion.varString2varByteString
          ctx.setDeclUsed(%string2bs)
          ctx.setDeclUsed(%string2vs)
          ctx.setDeclUsed(%varString2string)
          ctx.out.write("Zstring2vs(Zstring2bs(ZvarStringToString(")
          close = ")))"

        CASE Conversion.int2string
        CASE Conversion.nat2string
          ctx.out.write("\"\" + ")
          typeConverted = Type.aString
        CASE Conversion.float2string
          ctx.setDeclUsed(%float2string)
          ctx.out.write("Zfloat2string(")
          close = ")"
          typeConverted = Type.aString
        CASE Conversion.int2varString
          ctx.out.write("\"\" + ")
          typeConverted = Type.aVarString
        CASE Conversion.bool2string
          ctx.setDeclUsed(%bool2string)
          ctx.out.write("Zbool2string(")
          close = ")"
          typeConverted = Type.aString
        CASE Conversion.status2string
          ctx.setDeclUsed(%status2string)
          ctx.out.write("Zstatus2string(")
          close = ")"
          typeConverted = Type.aString
        CASE Conversion.object2iobject
        CASE Conversion.iobject2object
        CASE Conversion.iobject2iobject
        CASE Conversion.iobject2xobject
        CASE Conversion.iobjectCast
          # Typecast is sufficient.
          # TODO: Need to check the types at runtime?
          typeConverted = exprArg.destType()
          ctx.out.write("((")
          $vartype(typeConverted, FALSE, expr.getPos(), ctx)
          ctx.out.write(")")
          close = ")"
        CASE Conversion.iobject2noalloc
          close = $object2noalloc(exprArg.dest, type, ctx)
        CASE Conversion.callback2method
          # no-op
          typeConverted = type.getEffType().<CallbackType>.methodType

        CASE Conversion.bool2dyn
        CASE Conversion.status2dyn
        CASE Conversion.int2dyn
        CASE Conversion.int82dyn
        CASE Conversion.int162dyn
        CASE Conversion.int322dyn
        CASE Conversion.nat2dyn
        CASE Conversion.byte2dyn
        CASE Conversion.nat162dyn
        CASE Conversion.nat322dyn
        CASE Conversion.enum2dyn
        CASE Conversion.bits2dyn
        CASE Conversion.float2dyn
        CASE Conversion.string2dyn
        CASE Conversion.byteString2dyn
        CASE Conversion.tuple2dyn
        CASE Conversion.type2dyn
        CASE Conversion.object2dyn
        CASE Conversion.array2dyn
        CASE Conversion.list2dyn
        CASE Conversion.dict2dyn
        CASE Conversion.iobject2dyn
          # A dyn is stored as an array with two elements: the type and the
          # value.
          ctx.out.write("[")
          ctx.out.write($getDynType(type, expr.getPos(), ctx))
          ctx.out.write(", ")
          close = "]"

        CASE Conversion.dyn2bool
        CASE Conversion.dyn2status
        CASE Conversion.dyn2int
        CASE Conversion.dyn2int8
        CASE Conversion.dyn2int16
        CASE Conversion.dyn2int32
        CASE Conversion.dyn2nat
        CASE Conversion.dyn2byte
        CASE Conversion.dyn2nat16
        CASE Conversion.dyn2nat32
        CASE Conversion.dyn2enum
        CASE Conversion.dyn2float
        CASE Conversion.dyn2byteString
        CASE Conversion.dyn2tuple
        CASE Conversion.dyn2type
        CASE Conversion.dyn2object
        CASE Conversion.dyn2array
        CASE Conversion.dyn2list
        CASE Conversion.dyn2dict
        CASE Conversion.dyn2iobject
          $setDeclUsed(Declaration.convertFromDyn)
          ctx.out.write("ZdynToVal(")
          ctx.out.write($getDynType(exprArg.destType(), expr.getPos(), ctx))
          ctx.out.write(", ")
          close = ")"

        CASE Conversion.dyn2string
          $setDeclUsed(%dynToString)
          ctx.out.write("ZdynToString(")
          close = ")"

        DEFAULT
          IF ctx.out.writing
            ctx.error("Unsupported conversion for JavaScript: "
                                       .. exprExt.conversion.ToString(), expr)
          }
      }
    }

    ctx.out.append(exprOut)
    ctx.out.write(close)

    RETURN typeConverted == NIL ? type : typeConverted
  }

  # Return the name of the struct defining type |type|.
  # Similar to getArgumentType().
  FUNC $getDynType(Type type, Zui.Position pos, SContext ctx) string
    # Argument for item type
    RETURN getTypeName(type, ctx)
  }

  FUNC $object2iobject(ClassType symClass, ClassType destClass,
                  string destName, Zui.Position pos, Output out, SContext ctx
                      ) string
    RETURN ""
  }

  # Assign an object to an iobject that is not allocated.
  # This makes a shallow copy of the object, unless the source is an iobject.
  FUNC $object2noalloc(Declaration dest, Type type, SContext ctx) string
    IF type.isXobject(ctx) || type.getTtype() == Type.Enum.object
      $setDeclUsed(%clone)
      ctx.out.write("Zclone(")
      RETURN ")"
    ELSE
      RETURN ""
    }
  }

  FUNC $iobjectType(Zui.Expression lhs, Type type, Type exprType,
                                                             SContext ctx) int
    RETURN 0
  }

  # Write the file for IMPORT.ZWT.  It is JavaScript inside a HTML file.
  # Imported files are included in the current output.
  FUNC $writeZwtImport(UsedFile usedFile, SContext ctx,
                                                   Output.Group myOuts) string
    ZimbuFile zimbuFile = usedFile.zimbuFile
    # Use the module name for file name.
    string moduleName = zimbuFile.getModuleName()
    IO.mkdir(zimbuFile.outDir)
    string fname = $zwtFilename(zimbuFile)
    IO.print("Writing file " .. fname .. "...")

    IO.File fd = IO.fileWriter(fname)
    IF fd == NIL
      IO.print("ERROR: Cannot open file for writing: " .. fname)
      EXIT 1
    }

    # The header gets the document in $doc.
    fd.write(''"<html>
  <head>
    <script>
      var $wnd = parent;
      var $doc = $wnd.document;
      var $sheetIndex = 0;
      function $findSheetIndex() {
        for (i = 0; i < $doc.styleSheets.length; ++i) {
          if ($doc.styleSheets[i].title == 'zwt') {
            $sheetIndex = i;
            break;
          }
        }
      }
      $findSheetIndex();
"'')
    fd.write(''"
    </script>
  </head>
  <body>
    <script><!--
"'')

    $writeJavaCode(usedFile, ctx, myOuts, fd)

    # Initialize global variables.
    fd.write("\nZdoInit();\n")

    # The init() function is always invoked.
    # TODO: should this also invoke inits of imported modules?
    fd.write("\n" .. DeclStore.getPName("M" .. moduleName, "Finit") .. "();\n")

    fd.write("    --></script>\n  </body>\n</html>\n")

    fd.close()
    IO.print("Done.")

    RETURN fname
  }

  # Write the Javascript code.
  PROC $writeJavaCode(UsedFile usedFile, SContext ctx,
                                              Output.Group myOuts, IO.File fd)
    $writeTypeDecls(fd)

    # Type names for containers.
    FOR decl IN ContainerType.usedTypes
      IF $isDeclUsed(decl)
        Output dout = myOuts.typeOut
        dout.write("ZType " .. decl.pName .. "__T = new ZType(")
        SWITCH decl.type.ttype
          CASE Type.Enum.array
            dout.write("300")
          CASE Type.Enum.list
            dout.write("301")
          CASE Type.Enum.dict
            dout.write("302")
        }
        dout.write(", \"\(decl.name)\");\n")
      }
    }

    IF !myOuts.typeOut.head.empty()
      fd.write("// typedefs\n")
      myOuts.typeOut.head.write(fd)
    }

    fd.write("\n// structs\n")
    myOuts.structOut.head.write(fd)

    fd.write(''"
public static abstract class FuncRef0<T> {
  public abstract T call();
}
public static abstract class ProcRef0 {
  public abstract void call();
}
"'')

    fd.write("\n// declarations\n")
    FOR writer IN codeWriters
      IF writer.isUsed(THIS)
        IF writer.declString != NIL
          fd.print(writer.declString)
        }
        IF writer.produceJavaDecl != NIL
          writer.produceJavaDecl(THIS, fd)
        }
      }
    }

    string zcPosName = DeclStore.getPName("MZModule", "CPos")
    fd.write("static \(zcPosName) ZcallerPos = null;\n")
    fd.write("static long ZexitCode = 0;\n")

    # Write common functions.
    FOR p IN funcWriters
      p(THIS, fd)
    }

    myOuts.declOut.head.write(fd)

    fd.write("\n// builtin methods\n")

    # Write code fragments that were marked as used.
    FOR writer IN codeWriters
      IF writer.produceJava != NIL && writer.isUsed(THIS)
        writer.produceJava(THIS, fd)
      }
    }

    writeBodies(THIS, fd)

    WriteArrayJava.writeBody(THIS, fd)
    WriteListJava.writeBody(THIS, fd)
    WriteDictJava.writeBody(THIS, fd)

    fd.write("\n// bodies\n")
    myOuts.bodyOut.head.write(fd)

    $writeGlobInit(usedFile, ctx, myOuts, fd)

    IF Arguments.testMode
      $writeTestMethods(myOuts)
    }
  }

  PROC $writeGlobInit(UsedFile usedFile, SContext ctx,
                                        Output.Group outputs, IO.File outFile)
    outFile.write(''"
// INIT GLOBALS
static int globInit(int round) {
 int done = 1;
"'')
    MethodScope ms = usedFile.zimbuFile.initScope
    IF ms != NIL && ms.tempVars != NIL
      FOR decl IN ms.tempVars
        outFile.write(" var ")
        outFile.write(decl.pName)
        outFile.write(";\n")
      }
    }

    IF !outputs.earlyInitOut.empty()
      bool writeEarlyInitLead = outputs.earlyInitLead != NIL
      IF writeEarlyInitLead
        outFile.write(outputs.earlyInitLead)
      }
      outputs.earlyInitOut.writeToFile(outFile)
      IF writeEarlyInitLead
        outFile.write(" }\n")
      }
    }

    IF !outputs.initOut.empty()
      bool writeInitLead = outputs.initLead != NIL
      IF writeInitLead
        outFile.write(outputs.initLead)
      }
      outputs.initOut.writeToFile(outFile)
      IF writeInitLead
        outFile.write(" }\n")
      }
    }

    # See WriteC.mainHead() for comments about "round".
    outFile.write(''"
 return done;
}

static void ZdoInit(String[] args) {"'')
    outFile.write(''"
 int round = 0;
 globInit(round++);"'')

    # Write main() early init lines for libraries.  Must be after first
    # globInit().
    Output initOut = NEW()
    initOut.writing = TRUE
    FOR p IN mainEarlyInitWriters
      p(THIS, initOut)
    }
    initOut.writeToFile(outFile)

    outFile.write(''"
 globInit(round++);
 while (globInit(round++) == 0) {
  if (round == 1002) Zthrow("Early initialization not done within 1000 rounds");
 }"'')

    # Write main() init lines for libraries.
    initOut = NEW()
    initOut.writing = TRUE
    FOR p IN mainInitWriters
      p(THIS, initOut)
    }
    initOut.writeToFile(outFile)

    outFile.write(''"
 round = 2001;
 globInit(round++);
 while (globInit(round++) == 0) {
  if (round == 3002) Zthrow("Initialization not done within 1000 rounds");
 }
}
"'')
  }

  # Add function for inits to bodies
  PROC $writeInits(ZimbuFile import, Output.Group outputs)
    IF outputs.earlyInitOut.empty() && outputs.initOut.empty()
      RETURN
    }

    Output bodyOut = outputs.bodyOut
    bodyOut.write("static int \(import.initFunc)_round_done = -1;\n")
    bodyOut.write("static int " .. import.initFunc .. "(int round) {\n")
    bodyOut.write(" int done = 1;\n")

    # Write any temp variables used in init expressions.
    MethodScope ms = import.initScope
    IF ms != NIL && ms.tempVars != NIL
      FOR decl IN ms.tempVars
        bodyOut.write(" ")
        $vartype(decl.type, TRUE, decl.zuiDecl.getPos(), bodyOut, NIL)
        bodyOut.write(decl.pName)
        bodyOut.write(";\n")
      }
    }

    bodyOut.write(" if (\(import.initFunc)_round_done < round) {\n")
    bodyOut.write("  \(import.initFunc)_round_done = round;\n")

    IF !outputs.earlyInitOut.empty()
      IF outputs.earlyInitLead != NIL
        bodyOut.write(outputs.earlyInitLead)
      }
      bodyOut.append(outputs.earlyInitOut)
      IF outputs.earlyInitLead != NIL
        bodyOut.write("  }\n")
      }
    }

    IF !outputs.initOut.empty()
      IF outputs.initLead != NIL
        bodyOut.write(outputs.initLead)
      }
      bodyOut.append(outputs.initOut)
      IF outputs.initLead != NIL
        bodyOut.write("  }\n")
      }
    }

    bodyOut.write(" }\n")
    bodyOut.write(" return done;\n")
    bodyOut.write("}\n")
  }

  # Generate global items.
  PROC $writeGlobals(SContext ctx)
    # Generate tuple declarations.
    TupleType.generateTuples(ctx)

    # Generate tuple declarations for MultipleType
    $writeMultipleDecls(ctx)
  }

  # Write calling test methods to mainOut
  PROC $writeTestMethods(Output.Group outputs)
    IF $testMethods.size() == 0
      LOG.error("No test methods found")
    }

    SContext ctx = NEW(NIL, THIS, outputs)
    $mainHead(NIL, ctx)
    ctx.out.write(" boolean r = true;\n")
    ctx.out.write(" boolean t;\n")

    string runTest = DeclStore.getPName("MTESTModule", "FrunTest")
    string report = DeclStore.getPName("MTESTModule", "Freport")
    FOR ftm IN $testMethods
      string setUp = ftm.setUp == NIL ? "null" : ftm.setUp.pName
      string tearDown = ftm.tearDown == NIL ? "null" : ftm.tearDown.pName
      FOR tup IN ftm.testMethodsList
        ctx.out.write(" t = \(runTest)(\"\(ftm.filePname)\", \"\(tup[1])\", new FuncRef0<Boolean>() { public Boolean call() { return \(tup[0].pName)(); }}, \(setUp), \(tearDown));\n")
        ctx.out.write(" r = r && t;\n")
      }
    }

    ctx.out.write(" \(report)(r);\n")
    ctx.out.write(" return r ? 0 : 1;\n")
    $mainEnd(ctx)
  }

  # Write code from |outputs| into outFile.
  # This is for a whole program.
  PROC $writeFile(UsedFile usedFile, SContext ctx,
                                        Output.Group outputs, IO.File outFile)
    $writeImports(outFile)
    outFile.write("\npublic class \(Arguments.rootTail) {\n")
    $writeJavaCode(usedFile, ctx, outputs, outFile)
    outFile.write("\n// end of library code\n")

    # Generate Fmain().
    outFile.write("\n//\n// MAIN\n//\n")
    outputs.mainOut.writeToFile(outFile)
  }

  PROC $writeImports(IO.File outFile)
    # List is always used in backtrace.
    outFile.write("import java.util.List;\n")
    outFile.write("import java.util.ArrayList;\n")

    # StringBuffer is always used somewhere.
    outFile.write("import java.lang.StringBuffer;\n")

    IF $isDeclUsed(%javaDate)
      outFile.write("import java.util.Date;\n")
    }
    IF $isDeclUsed(%javaCalendar)
      outFile.write("import java.util.Calendar;\n")
    }

    IF $isDeclUsed(Declaration.dict)
      outFile.write("import java.util.HashMap;\n")
    }

    IF $isDeclUsed(%collections)
      outFile.write("import java.util.Collections;\n")
    }
  }

  # Write __T type declarations.
  PROC $writeTypeDecls(IO.File fd)
    # We do this similar to C, even though there might be better ways in Java.
    # A type is an object with the type number and optional name.
    fd.write(''"static class ZType {
  final public int nr;
  final public String name;
  public ZType(int nr) {
    this.nr = nr;
    this.name = "";
  }
  public ZType(int nr, String name) {
    this.nr = nr;
    this.name = name;
  }
}
static ZType bool__T = new ZType(21);
static ZType byte__T = new ZType(11);
static ZType float128__T = new ZType(83);
static ZType float32__T = new ZType(81);
static ZType float80__T = new ZType(82);
static ZType float__T = new ZType(80);
static ZType int16__T = new ZType(2);
static ZType int32__T = new ZType(3);
static ZType int8__T = new ZType(1);
static ZType int__T = new ZType(0);
static ZType nat16__T = new ZType(12);
static ZType nat32__T = new ZType(13);
static ZType nat__T = new ZType(10);
static ZType status__T = new ZType(22);
static ZType string__T = new ZType(200);
static ZType byteString__T = new ZType(201);
"'')
    IF $isDeclUsed(Declaration.varString)
      fd.write("static ZType varString__T = new ZType(310);\n")
    }
    IF $isDeclUsed(Declaration.varByteString)
      fd.write("static ZType varByteString__T = new ZType(311);\n")
    }
    fd.write("static ZType type__T = new ZType(101);\n")
    fd.write("static ZType cb__T = new ZType(330);\n")
    IF $isDeclUsed(Declaration.array)
      fd.write("static ZType array__T = new ZType(300);\n")
    }
    # (nearly) always used for backtrace.
    fd.write("static ZType list__T = new ZType(301);\n")
    IF $isDeclUsed(Declaration.dict)
      fd.write("static ZType dict__T = new ZType(302);\n")
    }
    IF $isDeclUsed(Type.aDyn)
      fd.write("static ZType dyn__T = new ZType(360);\n")
    }
    fd.write("static ZType iobj__T = new ZType(391);\n")
  }

  PROC $writeZutHeader(IO.File fd)
    # zut.context is a ZUT.Context singleton.
    # zut.eventConfig is an ZUT.EventConfig singleton.
    fd.print(''"
var $doc = window.document;
var zut = {};
"'')
  }

  PROC $writeZutFooter(IO.File fd)
    # The event handler used by ZUT.EventConfig.listen().
    fd.print(''"
zut.eventHandler = function(e, eventName, pName) {
  var event = e || window.event; // for old IE
  var el = event.target || event.srcElement; // for old IE
  if (el) {
    var controller;
    var action;
    var actionEl;
    while (el && el.getAttribute) {
      if (!action && el.getAttribute('zaction')) {
        var actions = el.getAttribute('zaction');
        var parts = actions.split(',');
        for (var i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf(eventName + ':') >= 0) {
            var colIdx = parts[i].indexOf(':');
            action = parts[i].substring(colIdx + 1).trim();
            actionEl = el;
            break;
          }
        }
      }
      if (action) {
        controller = el.getAttribute('zcontroller');
        if (controller) {
          var inst = el.zcontrollerInst;
          if (!inst) {
            var ctrlClass = window[controller];
            if (typeof ctrlClass != 'function') {
              alert('controller not registered: ' + controller);
              return;
            }
            inst = new ctrlClass();
            el.zcontrollerInst = inst;
          }
          var i = action.indexOf('.');
          if (i > 0) {
            action = action.substring(i + 1);
          }
          if (inst[action]) {
            var zutEvent = pName(actionEl, el, event);
            inst[action](zutEvent);
          } else {
            alert('action ' + action + ' does not exist on ' + controller);
          }
          return;
        }
      }
      el = el.parentNode;
    }
  }
};
"'')

    # TODO: only define handlers that are actually used.
    string clickPName = DeclStore.getPName("MZUTModule__CEvent__X",
                                                             "FnewClickEvent")
    fd.print(''"
zut.clickEventHandler = function(e) {
 zut.eventHandler(e, 'click', "'' .. clickPName .. ''");
}
"'')

    string keyDownPName = DeclStore.getPName("MZUTModule__CEvent__X",
                                                           "FnewKeyDownEvent")
    fd.print(''"
zut.keyDownEventHandler = function(e) {
 zut.eventHandler(e, 'keyDown', "'' .. keyDownPName .. ''");
}
"'')

    string keyUpPName = DeclStore.getPName("MZUTModule__CEvent__X",
                                                           "FnewKeyUpEvent")
    fd.print(''"
zut.keyUpEventHandler = function(e) {
 zut.eventHandler(e, 'keyUp', "'' .. keyUpPName .. ''");
}
"'')

    string keyPName = DeclStore.getPName("MZUTModule__CEvent__X",
                                                               "FnewKeyEvent")
    fd.print(''"
zut.keyEventHandler = function(e) {
 zut.eventHandler(e, 'key', "'' .. keyPName .. ''");
}
"'')

    string mouseMovePName = DeclStore.getPName("MZUTModule__CEvent__X",
                                                         "FnewMouseMoveEvent")
    fd.print(''"
zut.mouseMoveEventHandler = function(e) {
 zut.eventHandler(e, 'mouseMove', "'' .. mouseMovePName .. ''");
}
"'')

    string mouseOverPName = DeclStore.getPName("MZUTModule__CEvent__X",
                                                         "FnewMouseOverEvent")
    fd.print(''"
zut.mouseOverEventHandler = function(e) {
 zut.eventHandler(e, 'mouseOver', "'' .. mouseOverPName .. ''");
}
"'')

    string mouseOutPName = DeclStore.getPName("MZUTModule__CEvent__X",
                                                          "FnewMouseOutEvent")
    fd.print(''"
zut.mouseOutEventHandler = function(e) {
 zut.eventHandler(e, 'mouseOut', "'' .. mouseOutPName .. ''");
}
"'')

    string valueChangePName = DeclStore.getPName("MZUTModule__CEvent__X",
                                                       "FnewValueChangeEvent")
    fd.print(''"
zut.valueChangeEventHandler = function(e) {
 zut.eventHandler(e, 'valueChange', "'' .. valueChangePName .. ''");
}
"'')

    string onLoadPName = DeclStore.getPName("MZUTModule", "FonLoad")
    fd.print(''"
function zutOnload() {
 "'' .. onLoadPName .. ''"();
}
"'')

    string contextPName = DeclStore.getPName("MZUTModule", "CContext")
    string newContextPName = DeclStore.getPName(
                                            "MZUTModule__CContext", "MNEW__1")
    string newEventConfigPName = DeclStore.getPName(
                                           "MZUTModule__CEventConfig", "MNEW")
    # Create the global ZUT.Context and add it to the context, wrapped in a
    # dyn.
    fd.print(''"
zut.context = "'' .. newContextPName .. ''"(null);
CtxAdd("'' .. contextPName .. ''"__T, ["'' .. contextPName .. ''"__T, zut.context]);
zut.eventConfig = "'' .. newEventConfigPName .. ''"(null);

ZdoInit();
"'')
  }

  # Return the file name for ZWT output of |zimbuFile|.
  FUNC $zwtFilename(ZimbuFile zimbuFile) string
    RETURN "\(zimbuFile.outDir)/\(zimbuFile.getModuleName()).html"
  }

  # Write lines to "myOuts" to include the generated code for imported
  # files.
  # TODO: if the imported file is a .zwt file load the script file generated
  # for it.
  PROC $writeIncludeImport(ZimbuFile import, Scope scope, Output.Group myOuts)
    # Add function for inits to bodies
    $writeInits(import, import.java.outputs)

    # Include the imported files in the current file.
    string pre = "// including " .. import.rootName

    IF !import.java.outputs.typeOut.head.empty()
      myOuts.typeOut.write(pre .. " typedefs\n")
      myOuts.typeOut.append(import.java.outputs.typeOut)
    }

    myOuts.structOut.write(pre .. " structs\n")
    myOuts.structOut.append(import.java.outputs.structOut)

    myOuts.declOut.write(pre .. " declarations\n")
    myOuts.declOut.append(import.java.outputs.declOut)

    myOuts.bodyOut.write(pre .. " bodies\n")
    myOuts.bodyOut.append(import.java.outputs.bodyOut)

    IF !(import.java.outputs.earlyInitOut.empty()
                                         && import.java.outputs.initOut.empty())
      # Call the init function.
      myOuts.initOut.write(" done &= " .. import.initFunc .. "(round);\n")
    }
  }

  # Write after imports, before inits of the file itself.
  PROC $afterImports(Scope scope, Output.Group outs)
    $commonAfterImports(scope, outs)
  }

  # Write after inits of the file itself.
  PROC $afterGenerate(UsedFile usedFile, Output.Group outs, SContext ctx)
    $commonAfterGenerate(usedFile, outs, ctx)
  }

  FUNC $needWrite(ZimbuFile zimbuFile) bool
    IF zimbuFile.java.startedWrite
      RETURN FALSE
    }
    zimbuFile.java.startedWrite = TRUE
    RETURN TRUE
  }

  # Write class type declaration.
  PROC $writeClassDef(string name, string comment, Output typeOut)
    # no forward declarations are needed.
  }

  # Write class declaration. |structOut| has the body.
  PROC $writeClassDecl(ClassType classType, Output.Group outs,
                                               Output structOut, SContext ctx)
    # Causes problems for the IO module
    # IF Generate.getFinishMethod(classType.scope) != NIL
    #                                           && outs.structOut.writing
    #  ctx.error("Finish not supported in Javascript",
    #                     Declaration.find(classType.scope.getObjectDeclDict(),
    #                                                         "Finish").zuiPos)
    #}

    string name = classType.pName
    bool isException = classType.scope.scopeName == "MEModule__CException"
    Output out = ctx.outs.bodyOut
    IF classType.ttype == Type.Enum.interface
      out.write("interface ")
    ELSEIF classType.isAbstract()
      out.write("static abstract class ")
    ELSE
      out.write("static class ")
    }
    out.write(name)

    IF classType.parent != NIL
      out.write(" extends ")
      out.write(classType.parent.pName)
    ELSEIF isException
      out.write(" extends RuntimeException")
    }

    # For a non-abstract class list the interfaces that are implemented.
    # If the parent is abstract, also list interfaces that parents implement,
    # they were skipped there.
    IF !classType.isAbstract()
      ClassType ct = classType
      WHILE TRUE
        IF ct.interfaces != NIL
          bool didFirst
          FOR itf IN ct.interfaces
            IF $isDeclUsed(itf)
              IF didFirst
                out.write(", ")
              ELSE
                out.write(" implements ")
                didFirst = TRUE
              }
              out.write(itf.pName)
            }
          }
        }
        IF ct.parent == NIL || !ct.parent.isAbstract()
          BREAK
        }
        ct = ct.parent
      }
    }

    out.write(" { // \(classType.name)\n")
    IF isException || classType.scope.scopeName.startsWith("MEModule__C")
      # Use Error() to get the stack trace.  Need this in every constructor
      # that inherits from Exception.
#      out.write(''"
# var err = Error.apply(this, arguments);
# err.name = this.name = '"'' .. classType.name .. ''"';
# this.message = err.message;
# Object.defineProperty(this, 'stack', { get: function() { return err.stack } });
# return this;"'')
    }

    IF isException
      # Need an intermediate class to avoid changing Error itself.
#      outs.structOut.write(''"
#var ErrorInherit = function() {};
#ErrorInherit.prototype = Error.prototype;"'')
    }

#    outs.structOut.write("\n_ = " .. name .. ".prototype = ")
#    ClassType pc = classType.parent
#    IF pc != NIL
#      outs.structOut.write("new " .. pc.pName .. "();\n")
#    ELSEIF isException
#      # We make the E.Exception class inherit from the Javascript Error, so
#      # that the stack trace is reported.
#      outs.structOut.write("new ErrorInherit();\n")
#    ELSE
#      outs.structOut.write("{};\n")
#    }

    IF classType.getObjectDeclDict() != NIL
      # define the normal members
      FOR l IN classType.getObjectDeclDict().values()
        $writeClassMember(l, outs, ctx)
      }
    }

    FOR child IN classType.children
      IF child.parentFromAugments || child.parentFromGrows
        # The child won't be generated, include its members here.
        FOR l IN child.getObjectDeclDict().values()
          $writeClassMember(l, outs, ctx)
        }
      }
    }

    IF classType.scope.pieceMembers != NIL
      # define the @local piece members
      FOR l IN classType.scope.pieceMembers.values()
        $writeClassMember(l, outs, ctx)
      }
    }

    # Make a table of members for ZobjectToString().
    IF $isDeclUsed(Declaration.itemToString)
#      out.write("static To[] __to = [")
#      ClassType currentClass = classType
#      int count
#      WHILE currentClass != NIL
#        count = $writeToTableLines(currentClass, count, ctx)
#        FOR child IN currentClass.children
#          IF child.parentFromAugments || child.parentFromGrows
#            count = $writeToTableLines(child, count, ctx)
#          }
#        }
#        currentClass = currentClass.parent
#      }
#      out.write("];\n")

      # When used as an iobject the type will be obtained from __t.
      # Also when used in ISA, so just always add it.
      out.write("static ZType __t = ")
      out.write(classType.pName)
      out.write("__T;\n")
    }

    # Add the methods to the body output.
    out.append(structOut)
  }

  PROC $writeClassEnd(SContext ctx)
    ctx.outs.bodyOut.write("}\n\n")
  }

  PROC $writeClassMember(list<Declaration> l, Output.Group outs, SContext ctx)
    Output out = ctx.outs.bodyOut
    FOR decl IN l
      IF !decl.type.isMethodType()
              && decl.type.ttype != Type.Enum.ctype
              && decl.type.ttype != Type.Enum.jstype
        $vartype(decl.type, TRUE, decl.zuiDecl.getPos(), out, ctx)
        out.write(decl.pName .. " = ")
        $defaultInit(decl.type, out, ctx)
        out.write(";\n")
      }
    }
  }

  FUNC $writeToTableLines(ClassType classType, int countArg, SContext ctx) int
    int count = countArg
    IF classType.getObjectDeclDict() != NIL
      Output out = ctx.outs.bodyOut
      FOR l IN classType.getObjectDeclDict().values()
        FOR decl IN l
          IF !decl.type.isMethodType()
                       && decl.type.getTtype() != Type.Enum.ctype
                       && (!Generate.skipUnused() || ctx.gen.isDeclUsed(decl))
            IF count > 0
              out.write(", ")
            }
            out.write("['")
            out.write(decl.name)
            out.write("', '")
            out.write(decl.pName)
            out.write("', ")
            out.write(getTypeName(decl.type, ctx))
            out.write("]")
            ++count
          }
        }
      }
    }
    RETURN count
  }

  # Write the default init value for |sym|.
  PROC $defaultInit(Type type, Output out, SContext ctx)
    IF type.ttype == Type.Enum.bool || type.ttype == Type.Enum.status
      out.write("false")
    ELSEIF type.isValueType() && type.getTtype() != Type.Enum.tuple
                                      && type.getTtype() != Type.Enum.multiple
      out.write("0")
    ELSE
      out.write("null")
    }
  }

  PROC $writeBoolVal(string intVal, SContext ctx)
    ctx.out.write(intVal == "0" ? "false" : "true")
  }

  PROC $nil(Declaration dest, SContext ctx)
    Output out = ctx.out
    IF dest.type.isNoAlloc()
      ClassType ct = dest.type.getClassType(ctx)
      IF ct != NIL
        IF ct.hasFinishMethod(ctx)
          $setDeclUsed(%noAllocNil)
          out.write("ZnoAllocNil(")
          out.write(dest.pName)
          out.write(")")
          RETURN
        }
      }
    }
    out.write("null")
  }

  # Write the value used for INF.
  PROC $inf(SContext ctx)
    ctx.out.write("Number.POSITIVE_INFINITY")
  }

  # Write the value used for NINF.
  PROC $ninf(SContext ctx)
    ctx.out.write("Number.NEGATIVE_INFINITY")
  }

  # Write the value used for NAN.
  PROC $nan(SContext ctx)
    ctx.out.write("Number.NaN")
  }

  # Write an expression and wrap it, when needed, for reference counting.
  FUNC $wrapExpr(Zui.Expression expr, SContext ctx, Type destType) Type
    RETURN $wrapExprConv(expr, ctx, NEW(destType, FALSE))
  }

  # Write an expression and wrap it, when needed, for reference counting.
  FUNC $wrapExprConv(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    RETURN Generate.genExprConv(expr, ctx, exprArg)
  }

  bool $generatingArg

  # Generate argument expression.
  FUNC $genArg(Zui.Expression arg, SContext ctx, Type destType) Type
    $generatingArg = TRUE
    Type res
    IF destType == NIL
      res = Generate.genExpr(arg, ctx)
    ELSE
      res = Generate.genExpr(arg, ctx, destType)
    }
    $generatingArg = FALSE
    RETURN res
  }

  PROC $writeArgExpr(Zui.Expression arg, SContext ctx, Type destType)
    $generatingArg = TRUE
    Generate.genTopExprDoConv(arg, ctx, destType)
    $generatingArg = FALSE
  }

  PROC $member(Output varnameOut, Zui.Position pos,
           Type objType, Type retType, bool dotnil, string name, SContext ctx)
    IF dotnil
      # var?.member ->  ((var id = var) ? id.member : null)
      string id = getUid(ctx.scope.ToString())
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      ctx.outs.varOut.write("int " .. id .. ";\n")
      ctx.out.write("((")
      ctx.out.write(id)
      ctx.out.write(" = ")
      ctx.out.append(varnameOut)
      ctx.out.write(") ? ")
      ctx.out.write(id)
      ctx.out.write("." .. name)
      ctx.out.write(" : ")
      $defaultInit(retType, ctx.out, ctx)
      ctx.out.write(")")
    ELSE
      ctx.out.append(varnameOut)
      ctx.out.write("." .. name)
    }
  }

  PROC $toStringFuncCast(SContext ctx)
  }

  PROC $iobjectUseFunc(string what, Zui.Position pos, int &undef,
                                    Type type, Declaration func, SContext ctx)
    IF func != NIL
      ctx.out.write(func.pName)
    ELSE
      $nil(type, ctx)
    }
  }

  FUNC $varsInMethodScope() bool
    RETURN FALSE
  }

  # Write the declaration and init of a variable.
  PROC $declaration(Declaration.C decl,
                    Type typeType,
                    Zui.Statement stmt,
                    bool isShared,
                    Output initExprOut,
                    bool initIsConstant,
                    SContext ctx)
    IF decl.type.ttype == Type.Enum.ctype || decl.type.ttype == Type.Enum.jstype
      # Skip declaration of a C or JS type, it won't be used.
      RETURN
    }

    Scope           scope = ctx.scope
    Zui.Declaration zuiDecl = stmt.getDeclaration()

    bool staticVar = scope.scopeName == NIL
                  || scope ISA ModuleScope
                  || scope.scopeType == Scope.Stype.shared
                  || isShared
    bool initWithDecl = staticVar && initIsConstant

    # Inside a method we can write to "out".  At the module level we need
    # to write the init directly.
    # TODO: module inits should be done after defining everything in the
    # module.
    Output iOut = ctx.out
    IF ctx.outs.origBodyOut == NIL
      iOut = ctx.outs.varOut
    }
    IF isShared
      # A variable in a SHARED section is written among the declarations.
      iOut = ctx.outs.declOut
    }
    SContext iCtx = ctx.copy(iOut)

    # 1. Write the declaration.
    IF scope.outer != NIL && !isShared
      iOut.writeIndent(scope.depth)
    }
    IF staticVar
      iOut.write("static ")
    }
    $vardecl(decl, iCtx)

    # 2. Write the init or assignment. Arrays are not initialized by default.
    IF scope.isInitVar()
                  && (typeType.ttype != Type.Enum.array || initExprOut != NIL)
      iOut.write(" = ")

      # For Java we don't have special handling for isAllocType().
      IF initExprOut == NIL || (staticVar && !initWithDecl)
        # no assignment, default init: NIL, FALSE, zero
        $defaultInit(typeType, iOut, ctx)

        # Write the actual init in the function called during startup.
        IF initExprOut != NIL
          Output initOut
          IF (zuiDecl.getType().hasAttr()
                                && zuiDecl.getType().getAttr().getEarlyInit())
                     || ((decl.type.ttype == Type.Enum.object
                            || decl.type.ttype == Type.Enum.iobject)
                         && (decl.type.zuiAttr != NIL
                                        && decl.type.zuiAttr.getEarlyInit()))
            initOut = ctx.outs.earlyInitOut
          ELSE
            initOut = ctx.outs.initOut
          }
          initOut.write("   ")
          initOut.write(decl.pName)
          initOut.write(" = ")
          initOut.append(initExprOut)
          initOut.write(";\n")
        }
      ELSE
        # Write the code for the expression, generated by the caller.
        iOut.append(initExprOut)
      }
    }

    iOut.write(";")
    IF decl.pName[0] != 'V' && decl.pName[0] != 't'
      $declComment(scope.scopeName, zuiDecl.getName(), iOut)
    }
    iOut.write("\n")

    # If this is an object with a Finish() method, prepare for calling Finish
    # later.
    IF decl.type != NIL && decl.type.isNoAlloc()
      Declaration finish
      bool childHasFinish
      bool isIobj
      ClassType class = decl.type.getClassType(ctx)
      IF class != NIL
        isIobj = decl.type.getTtype() == Type.Enum.iobject
        finish = Generate.getFinishMethod(class.scope, ctx)
        IF finish == NIL && isIobj && class.hasFinishMethod(ctx)
          # Some child class has Finish().
          childHasFinish = TRUE
        }
      }
      IF finish != NIL || childHasFinish
        bool global = scope.outer == NIL || isShared
                                               || ctx.scope.methodScope == NIL

        IF !ctx.scope.hasFinish && !global
          ctx.scope.hasFinish = TRUE
          iOut.writeIndent(scope.depth)
          iOut.write("int onStackLen" .. scope.depth
                                                .. " = onStackList.length;\n")
        }
        iOut.writeIndent(scope.depth)
        iOut.write("onStackList.push(function() {ZFinish("
                   .. decl.pName .. ", " .. (global ? "1" : "2") .. ")});\n")
      }
    }
  }

  PROC $vardecl(Declaration.C decl, SContext ctx)
    $vartype(decl.type, TRUE, decl.zuiPos, ctx)

    # Output variable name.
    ctx.out.write(decl.pName)
  }

  PROC $vartype(Type type, bool useSpace, Zui.Position pos, SContext ctx)
    $vartype(type, useSpace, pos, ctx.out, ctx)
  }

  # Write the type of a variable or return value to |out|.
  # |pos| may be NIL.
  # When |useSpace| is TRUE add a space before the "*" or after the type.
  # Use that for declarations, use FALSE for type casts.
  # Note: |ctx| can be NIL
  PROC $vartype(Type type, bool useSpace,
                                   Zui.Position pos, Output out, SContext ctx)
    IF !out.writing
      RETURN
    }
    out.write($vartypeString(type, useSpace, pos, ctx))
  }

  PROC $vartype(Type type, bool useSpace, bool needObject,
                                               Zui.Position pos, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    ctx.out.write($vartypeString(type, useSpace, needObject, pos, ctx))
  }

  # Note: |ctx| can be NIL
  FUNC $vartypeString(Type type, bool useSpace,
                                        Zui.Position pos, SContext ctx) string
    RETURN $vartypeString(type, useSpace, FALSE, pos, ctx)
  }


  # When |needObject| is TRUE, use Integer instead of int, Long instead of
  # long, etc.
  # Note: |ctx| can be NIL
  FUNC $vartypeString(Type type, bool useSpace, bool needObject,
                                        Zui.Position pos, SContext ctx) string
    IF type == NIL || type.ttype == Type.Enum.unknown
      RETURN useSpace ? "void " : "void"
    }

    Type etype = type.getEffType()
    string maybeStar = useSpace ? " " : ""
    Type.Enum ttype = etype.getTtype()
    SWITCH ttype
      CASE Type.Enum.nilval
          RETURN useSpace ? "void " : "void"
      CASE Type.Enum.class
      CASE Type.Enum.classDotC
      CASE Type.Enum.object
      CASE Type.Enum.iobject
      CASE Type.Enum.interface
          ClassType classType = etype.getClassType(ctx)
          IF classType != NIL
            RETURN etype.getClassType(ctx).getClassName() .. maybeStar
          }
          IF ctx != NIL
            Report.internal("no class name for " .. etype.typeToString(), pos)
          }
      CASE Type.Enum.array
          RETURN $vartypeString(type.<ContainerType>.itemType,
                                                       FALSE, FALSE, pos, ctx)
                    .. "[]" .. maybeStar
      CASE Type.Enum.list
          RETURN "ZList<" .. $vartypeString(type.<ContainerType>.itemType,
                                   FALSE, TRUE, pos, ctx) .. ">" .. maybeStar
      CASE Type.Enum.dict
          RETURN "ZDict<" .. $vartypeString(type.<ContainerType>.keyType,
                                   FALSE, TRUE, pos, ctx)
                            .. ", "
                            .. $vartypeString(type.<ContainerType>.itemType,
                                   FALSE, TRUE, pos, ctx)
                            .. ">" .. maybeStar
      CASE Type.Enum.tuple
          RETURN $tupleTypeString(etype.<TupleType>.types, pos, ctx)
                                                                  .. maybeStar
      CASE Type.Enum.multiple
          RETURN $tupleTypeString(etype.<MultipleType>.types, pos, ctx)
                                                                  .. maybeStar
      CASE Type.Enum.proc
      CASE Type.Enum.func
      CASE Type.Enum.procRef
      CASE Type.Enum.funcRef
          string retType = "void"
          IF ttype == Type.Enum.func
            retType = $vartypeString(etype.<MethodType>.returnType,
                                                        FALSE, TRUE, pos, ctx)
          ELSEIF ttype == Type.Enum.funcRef
            retType = $vartypeString(etype.<MethodRefType>.method.returnType,
                                                        FALSE, TRUE, pos, ctx)
          }
          # TODO: more arguments.
          IF ttype == Type.Enum.proc || ttype == Type.Enum.procRef
            RETURN "ProcRef0" .. maybeStar
          }
          RETURN "FuncRef0<\(retType)>" .. maybeStar
      CASE Type.Enum.callback
          RETURN etype.pName .. maybeStar
      CASE Type.Enum.string
      CASE Type.Enum.stringval
      CASE Type.Enum.byteString
          RETURN "String" .. maybeStar
      CASE Type.Enum.varString
      CASE Type.Enum.varByteString
          ctx.setDeclUsed(%varByteStringType)
          RETURN "Ty" .. maybeStar
      CASE Type.Enum.byRef
          RETURN $vartypeString(etype.<ReferenceType>.reference,
                                                 FALSE, pos, ctx) .. maybeStar
      CASE Type.Enum.dyn
          RETURN "Tx" .. (useSpace ? " " : "")  # never use a star
      CASE Type.Enum.type
          RETURN "Tt" .. maybeStar

      CASE Type.Enum.bool
      CASE Type.Enum.status
          IF needObject
            RETURN useSpace ? "Boolean " : "Boolean"
          }
          RETURN useSpace ? "boolean " : "boolean"

      CASE Type.Enum.bits
      CASE Type.Enum.bitsValue
          bool big = ttype == Type.Enum.bits
                ? etype.<BitsType>.valueType == Type.Enum.int
                : etype.<BitsValueType>.bitsType.valueType == Type.Enum.int
          IF needObject
            RETURN big ? (useSpace ? "Long " : "Long")
                       : (useSpace ? "Integer " : "Integer")
          }
          RETURN big ? (useSpace ? "long " : "long")
                     : (useSpace ? "int " : "int")
      CASE Type.Enum.enum
      CASE Type.Enum.enumValue
          IF needObject
            RETURN useSpace ? "Integer " : "Integer"
          }
          RETURN useSpace ? "int " : "int"
      CASE Type.Enum.int
      CASE Type.Enum.intval
          IF needObject
            RETURN useSpace ? "Long " : "Long"
          }
          RETURN useSpace ? "long " : "long"
      CASE Type.Enum.int8
          RETURN useSpace ? "byte " : "byte"
      CASE Type.Enum.int16
          RETURN useSpace ? "short " : "short"
      CASE Type.Enum.int32
          IF needObject
            RETURN useSpace ? "Integer " : "Integer"
          }
          RETURN useSpace ? "int " : "int"
      CASE Type.Enum.nat
      CASE Type.Enum.natval
          IF needObject
            RETURN useSpace ? "Long " : "Long"
          }
          RETURN useSpace ? "long " : "long"  # TODO: not unsigned
      CASE Type.Enum.byte
          RETURN useSpace ? "byte " : "byte"  # TODO: not unsigned
      CASE Type.Enum.nat16
          RETURN useSpace ? "char " : "char"
      CASE Type.Enum.nat32
          IF needObject
            RETURN useSpace ? "Integer " : "Integer"
          }
          RETURN useSpace ? "int " : "int"  # TODO: not unsigned
      CASE Type.Enum.float
      CASE Type.Enum.floatval
      CASE Type.Enum.float80    # TODO
      CASE Type.Enum.float128   # TODO
          RETURN useSpace ? "double " : "double"
      CASE Type.Enum.float32
          RETURN useSpace ? "float " : "float"
      CASE Type.Enum.ctype
      CASE Type.Enum.jstype
          # TODO: throw error
          RETURN useSpace ? "String " : "String"
      CASE Type.Enum.javatype
          RETURN useSpace ? etype.getJavatypeName() .. " "
                                                     : etype.getJavatypeName()
    }

    IF ctx != NIL && ctx.doError()
      ctx.error("Declaration of unknown type " .. etype.typeName(), pos)
      #  LOG.reportStack()
    }
    RETURN useSpace ? "void " : "void"
  }

  FUNC $tupleTypeString(list<Declaration> types, Zui.Position pos,
                                                          SContext ctx) string
    string res = "Tuple\(types.size())<"
    bool didFirst
    FOR decl IN types
      IF didFirst
        res ..= ", "
      ELSE
        didFirst = TRUE
      }
      res ..= $vartypeString(decl.type, FALSE, FALSE, pos, ctx)
    }
    RETURN res .. ">"
  }

  FUNC $enum(Zui.Declaration zuiDecl, EnumType enumType, SContext ctx) int
    Output out = ctx.outs.declOut
    IF !$isDeclUsed(enumType) || !out.writing
      RETURN 0
    }

    bool useValueName = enumType.isValueNameUsed(ctx)
    IF useValueName && enumType.parent == NIL
      # Define the table with value names.
      out.write("var " .. enumType.pName .. " = [\n")
      FOR idx IN 0 UNTIL enumType.totalMemberCount
        Declaration.C item = enumType.getMember(idx)
        out.write(" \"" .. item.name .. "\",\n")
      }
      out.write("];\n")

      # Define function to get the value name for ToString().
      out.write("function \(enumType.pName)__name(n) {\n")
      out.write(" return (n < 0 || n >= ")
      out.write(enumType.pName)
      out.write(".length) ? \"INVALID\" : ")
      out.write(enumType.pName)
      out.write("[n];\n")
      out.write("};\n")
    }

    # Define the type.
    out.write("static ZType " .. enumType.pName .. "__T = new ZType(23, ")
    IF enumType.usedEnumName != NIL && $isDeclUsed(enumType.usedEnumName)
      out.write("\"\(enumType.name)\"")
    ELSE
      out.write("null")
    }
    IF useValueName
      out.write(", ")
      out.write("\(enumType.getRoot().pName)__name")
    }
    out.write(");\n")
    RETURN 0
  }

  FUNC $enumName(EnumValueType type, SContext ctx) string
    ctx.out.write(type.enumType.getRoot().pName)
    ctx.out.write("[")
    RETURN "]"
  }

  FUNC $enumFromString(EnumType type, SContext ctx) string
    ctx.setDeclUsed(%enumFromString)
    ctx.out.write("ZenumFromString(")
    ctx.out.write(type.pName)
    ctx.out.write(", ")
    RETURN ")"
  }

  # A bits declaration.
  PROC $bits(Zui.Declaration zuiDecl, BitsType bitsType, SContext ctx)
# TODO: not always needed, only when used in container
#    IF bitsType.usedBitsName != NIL && $isDeclUsed(bitsType.usedBitsName)
      Output out = ctx.outs.declOut
      out.write("static ZType " .. bitsType.pName .. "__T = new ZType(25, \"")
      out.write(bitsType.name)
      out.write("\");\n")
#    }
  }

  PROC $intAsByteString(Zui.Expression expr, SContext ctx)
    # TODO: is it possible to put a byte into a JavaScript string?
    ctx.out.write("String.valueOf(")
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSE
      genExpr(expr, ctx, Type.anInt)
    }
    ctx.out.write(")")
  }

  PROC $intAsString(Zui.Expression expr, SContext ctx)
    ctx.out.write("String.valueOf(")
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSE
      genExpr(expr, ctx, Type.anInt)
    }
    ctx.out.write(")")
  }

  PROC $stringFormat(Zui.Expression expr, Zui.Expression arg, SContext ctx)
    ctx.setDeclUsed(%stringFormat)
    ctx.setDeclUsed(%isdigit)
    ctx.out.write("ZStringFormat(")
    genExpr(expr, ctx, Type.aString)
    ctx.out.write(", ")
    genExpr(arg, ctx, Type.aString)
    ctx.out.write(")")
  }

  PROC $numberToString(Zui.Expression expr, Type type, SContext ctx)
    ctx.out.write("Long.toString(")
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSEIF type.ttype == Type.Enum.bits
      Type ret = genExpr(expr, ctx)
      IF ret.getTtype() != Type.Enum.bitsValue && ctx.doError()
        ctx.error("Expected bits value", expr)
      }
    ELSE
      genExpr(expr, ctx, type)
    }
    ctx.out.write(")")
  }

  PROC $intToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    IF format == NIL
      $numberToString(expr, type, ctx)
    ELSE
      ctx.setDeclUsed(%intFormat)
      ctx.out.write("ZintFormat(")
      genExpr(format, ctx, Type.aString)
      ctx.out.write(", ")
      genExpr(expr, ctx, type)
      ctx.out.write(")")
    }
  }

  PROC $natToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    # In Javascript all int and nat are the same.
    $intToString(expr, format, type, ctx)
  }

  PROC $floatSize(Zui.Expression expr, Type type, SContext ctx)
    # All floats are actually 64 bit in Java.  But let's try to keep this in
    # sync with C, it should be OK to return a lower number than the actual
    # size.
    SWITCH type.getTtype()
      CASE Type.Enum.float32
        ctx.out.write("4")
      DEFAULT
        ctx.out.write("8")
    }
  }

  PROC $floatToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    IF format == NIL
      ctx.setDeclUsed(%float2string)
      ctx.out.write("Zfloat2string(")
      genExpr(expr, ctx, type)
      ctx.out.write(")")
    ELSE
      ctx.setDeclUsed(%floatFormat)
      ctx.out.write("ZfloatFormat(")
      genExpr(expr, ctx, type)
      ctx.out.write(", ")
      genExpr(format, ctx, Type.aString)
      ctx.out.write(")")
    }
  }

  # float.isNan()
  PROC $isNan(Zui.Expression expr, SContext ctx)
    ctx.out.write("isNaN(")
    genExpr(expr, ctx, Type.aFloat)
    ctx.out.write(")")
  }

  # float.isInfinite()
  PROC $isInfinite(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%isInfinite)
    ctx.out.write("ZisInfinite(")
    genExpr(expr, ctx, Type.aFloat)
    ctx.out.write(")")
  }

  # Float function.
  PROC $floatMethod(string name, Zui.Expression expr, Zui.Expression arg,
                                                                 SContext ctx)
    IF name == "trunc"
      ctx.setDeclUsed(%trunc)
      ctx.out.write("Ztrunc(")
    ELSEIF name == "round"
      ctx.setDeclUsed(%round)
      ctx.out.write("Zround(")
    ELSEIF name == "toInt"
      ctx.setDeclUsed(%float2int)
      ctx.out.write("Zfloat2int(")
    ELSEIF name == "sinh"
      ctx.setDeclUsed(%sinh)
      ctx.out.write("Zsinh(")
    ELSEIF name == "cosh"
      ctx.setDeclUsed(%cosh)
      ctx.out.write("Zcosh(")
    ELSEIF name == "tanh"
      ctx.setDeclUsed(%tanh)
      ctx.out.write("Ztanh(")
    ELSEIF name == "log10"
      ctx.out.write("Math.log(")
    ELSE
      ctx.out.write("Math.")
      ctx.out.write(name)
      ctx.out.write("(")
    }
    genExpr(expr, ctx, Type.aFloat)
    IF arg != NIL
      ctx.out.write(", ")
      $genArg(arg, ctx, Type.aFloat)
    }
    ctx.out.write(")")
    IF name == "log10"
      ctx.out.write("/2.302585")
    }
  }

  # Function for int.Type()
  PROC $callType(Type type, SContext ctx)
    ctx.out.write(getTypeName(type, ctx))
  }

  # Function for enum.Type()
  PROC $callEnumType(EnumType type, Zui.Position pos, SContext ctx)
    ctx.out.write(type.pName .. "__T")
  }

  # Function for bits.Type()
  PROC $callBitsType(BitsType type, Zui.Position pos, SContext ctx)
    ctx.out.write(type.pName)
    ctx.out.write("__T")
  }

  # Function for tuple<>.Type()
  PROC $callTupleType(TupleType type, Zui.Position pos, SContext ctx)
    ctx.out.write(type.pName)
    ctx.out.write("__T")
  }

  # Function for dyn.Type()
  PROC $callDynType(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%dynType)
    ctx.out.write("ZdynType(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(")")
  }

  # Function for dyn.ToString()
  PROC $callDynToString(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%dynToString)
    ctx.out.write("ZdynToString(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(")")
  }

  # Function for dyn.Size()
  PROC $callDynSize(Zui.Expression expr, SContext ctx)
    ctx.out.write("ZdynSize(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(")")
  }

  # Function for type.Size()
  PROC $callTypeSize(Type type, SContext ctx)
    # Rather arbitrary.
    ctx.out.write("24")
  }

  # Function for Module.Type()
  PROC $callModuleType(ModuleType mt, Zui.Position pos, SContext ctx)
    ctx.out.write(mt.name)
    ctx.out.write("__T")
  }

  # Function for Class.Type()
  PROC $callClassType(ClassType ct, Zui.Position pos, SContext ctx)
    ctx.out.write(ct.pName)
    ctx.out.write("__T")
  }

  # Function to turn a bool into a string.
  PROC $boolToString(Zui.Expression expr,  list<Zui.Expression> args,
                                                                 SContext ctx)
    ctx.out.write("((")
    genExpr(expr, ctx, Type.aBool)
    IF args.Size() == 1
      IF args[0].getType() == Zui.ExprType.eSTRING
        IF args[0].getStringValue() == "1b"
          ctx.out.write(") ? '1' : '0')")
        ELSEIF args[0].getStringValue() == "b"
          ctx.out.write(") ? 'TRUE' : 'FALSE')")
        ELSEIF ctx.doError()
          ctx.error("format must be \"b\" or \"1b\"", args[0])
        }
      ELSE
        ctx.out.write(") ? (")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write(" == '1b' ? '1' : 'TRUE') : (")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write(" == '1b' ? '0' : 'FALSE'))")
      }
    ELSE
      ctx.out.write(") ? 'TRUE' : 'FALSE')")
    }
  }

  # Function to turn a bool into a string.
  PROC $statusToString(Zui.Expression expr, list<Zui.Expression> args,
                                                                 SContext ctx)
    ctx.out.write("((")
    genExpr(expr, ctx, Type.aStatus)
    IF args.Size() == 1
      IF args[0].getType() == Zui.ExprType.eSTRING
        IF args[0].getStringValue() == "1t"
          ctx.out.write(") ? \"1\" : \"0\")")
        ELSEIF args[0].getStringValue() == "t"
          ctx.out.write(") ? 'OK' : 'FAIL')")
        ELSEIF ctx.doError()
          ctx.error("format must be \"t\" or \"1t\"", args[0])
        }
      ELSE
        ctx.out.write(") ? (")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write(" == '1t' ? '1' : 'OK') : (")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write(" == '1t' ? '0' : 'FAIL'))")
      }
    ELSE
      ctx.out.write(") ? 'OK' : 'FAIL')")
    }
  }

  # Function to return the size of an int, int8, etc.
  PROC $intSize(Type type, SContext ctx)
    # All ints are actually floating point numbers in Java.  But let's try to
    # keep this in sync with C, it should be OK to return a lower number than
    # the actual size.
    SWITCH type.getTtype()
      CASE Type.Enum.intval
      CASE Type.Enum.int
      CASE Type.Enum.natval
      CASE Type.Enum.nat
          ctx.out.write("8")

      CASE Type.Enum.int8; ctx.out.write("1")
      CASE Type.Enum.int16; ctx.out.write("2")
      CASE Type.Enum.int32; ctx.out.write("4")

      CASE Type.Enum.byte; ctx.out.write("1")
      CASE Type.Enum.nat16; ctx.out.write("2")
      CASE Type.Enum.nat32; ctx.out.write("4")
      DEFAULT
        LOG.internal("int.Size() type not recognized: \(type.typeName())")
    }
  }

  # Function to return the size of a bool.
  PROC $boolSize(SContext ctx)
    ctx.out.write("1")
  }

  # Function to return the size of a status.
  PROC $statusSize(SContext ctx)
    ctx.out.write("1")
  }

  # Function to check if a number is a digit character.
  PROC $isDigit(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%isdigit)
    ctx.out.write("Zisdigit(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is a hex digit character.
  PROC $isHexDigit(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%isXdigit)
    ctx.out.write("ZisXdigit(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is an alphabetic character.
  PROC $isAlpha(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%isAlpha)
    ctx.out.write("ZisAlpha(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is a lower case character.
  PROC $isLower(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%isLower)
    ctx.out.write("ZisLower(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is an upper case character.
  PROC $isUpper(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%isUpper)
    ctx.out.write("ZisUpper(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to turn a number into a lower case character.
  PROC $intToLowerAscii(Zui.Expression expr, SContext ctx)
    string pname = getUid(ctx.scope.ToString())
    ctx.outs.varOut.writeIndent(ctx.scope.depth)
    ctx.outs.varOut.write("long " .. pname .. ";\n")
    ctx.out.write("((" .. pname .. " = ")
    genExpr(expr, ctx, Type.anInt)
    ctx.out.write("), " .. pname .. " >= 65 && " .. pname
                .. " <= 90 ? " .. pname .. " + 97 - 65 : " .. pname .. ")")
  }

  # Function to turn a number into an upper case character.
  PROC $intToUpperAscii(Zui.Expression expr, SContext ctx)
    string pname = getUid(ctx.scope.ToString())
    ctx.outs.varOut.writeIndent(ctx.scope.depth)
    ctx.outs.varOut.write("long " .. pname .. ";\n")
    ctx.out.write("((" .. pname .. " = ")
    genExpr(expr, ctx, Type.anInt)
    ctx.out.write("), " .. pname .. " >= 97 && " .. pname
                .. " <= 122 ? " .. pname .. " + 65 - 97 : " .. pname .. ")")
  }

  # Function make a number positive.
  PROC $intAbs(Zui.Expression expr, SContext ctx)
    ctx.out.write("Math.abs(")
    genExpr(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  PROC $writeCompare(Zui.Expression var_expr, list<Zui.Expression> args,
                                                      Type type, SContext ctx)
    IF type.isFloatType()
      $setDeclUsed(%floatCompare)
      ctx.out.write("ZfloatCompare(")
    ELSEIF type.isIntType() || type.getTtype() == Type.Enum.bool
                                        || type.getTtype() == Type.Enum.status
      ctx.out.write("Math.max(-1, Math.min(1, ")
      genExpr(var_expr, ctx, type)
      ctx.out.write(" - ")
      genExpr(args[0], ctx, type)
      ctx.out.write("))")
      RETURN
    ELSEIF type.ttype == Type.Enum.type
      $setDeclUsed(%typeCompare)
      ctx.out.write("ZtypeCompare(")
    ELSEIF ctx.out.writing
      Report.internal("Unsupported Compare(\(type.getTtype())) for JavaScript")
    }

    genExpr(var_expr, ctx, type)
    ctx.out.write(", ")
    genExpr(args[0], ctx, type)
    ctx.out.write(")")
  }

  PROC $writeEqual(Zui.Expression var_expr, list<Zui.Expression> args,
                                                      Type type, SContext ctx)
    string middle = " == "
    string end = ")"
    IF type.ttype == Type.Enum.dyn
      $setDeclUsed(Declaration.dynEqual)
      ctx.out.write("ZdynEqual")
      middle = ", "
    ELSEIF type.ttype == Type.Enum.string
      middle = ").equals("
      end = "))"
    }
    ctx.out.write("(")
    genExpr(var_expr, ctx, type)
    ctx.out.write(middle)
    genExpr(args[0], ctx, type)
    ctx.out.write(end)
  }

  PROC $someStringToInt(Zui.Expression expr, bool dotnil,
                list<Zui.Expression> args, SContext ctx, Type type, int radix)
    ctx.setDeclUsed(%parseInt)
    $someStringToInt("ZparseInt", expr, dotnil, args, ctx, type, radix)
  }

  PROC $someStringToInt(string name, Zui.Expression expr, bool dotnil,
                list<Zui.Expression> args, SContext ctx, Type type, int radix)
    ctx.out.write(name .. "(")
    IF type == Type.aVarString
      ctx.setDeclUsed(%varString2string)
      ctx.out.write("ZvarStringToString(")
    }
    genExpr(expr, ctx, type)
    IF type == Type.aVarString
      ctx.out.write(")")
    }
    ctx.out.write(", " .. radix)
    int flags = 0
    IF args.Size() == 0
      flags = 1  # throw exception when failure, otherwise return default
    }
    IF dotnil
      flags += 2 # NIL string does not throw an exception
    }
    ctx.out.write(", ")
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      genExpr(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $stringToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    $someStringToInt(expr, dotnil, args, ctx, Type.aString, radix)
  }
  PROC $varStringToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    $someStringToInt(expr, dotnil, args, ctx, Type.aVarString, radix)
  }

  PROC $someStringQuotedToInt(Zui.Expression expr,
                           list<Zui.Expression> args, bool dotnil, SContext ctx,
                                                       Type type, int radix)
    ctx.setDeclUsed(%parseQuotedInt)
    ctx.setDeclUsed(%parseInt)
    $someStringToInt("ZparseQuotedInt", expr, dotnil, args, ctx, type, radix)
  }

  PROC $stringQuotedToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    $someStringQuotedToInt(expr, args, dotnil, ctx, Type.aString, radix)
  }
  PROC $varStringQuotedToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    $someStringQuotedToInt(expr, args, dotnil, ctx, Type.aVarString, radix)
  }

  PROC $stringToFloat(Zui.Position pos, Zui.Expression expr, bool dotnil,
                      list<Zui.Expression> args, SContext ctx)
    IF args.Size() == 0
      ctx.out.write("parseFloat(")
      $genArg(expr, ctx, Type.aString)
      ctx.out.write(")")
    ELSE
      $setDeclUsed(%stringToFloat)
      ctx.out.write("ZstringToFloat(")
      $genArg(expr, ctx, Type.aString)
      ctx.out.write(", ")
      $genArg(args[0], ctx, Type.anIntRef)
      ctx.out.write(")")
    }
  }

  PROC $someStringToLower(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%tolower)
    ctx.out.write("Ztolower(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $someStringToLowerAscii(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%tolowerA)
    ctx.out.write("ZtolowerA(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $someStringToUpper(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%toupper)
    ctx.out.write("Ztoupper(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $someStringToUpperAscii(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%toupperA)
    ctx.out.write("ZtoupperA(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $stringToLowerAscii(Zui.Expression expr, SContext ctx, Type type)
    $someStringToLowerAscii(expr, ctx, type)
  }

  PROC $stringToUpperAscii(Zui.Expression expr, SContext ctx, Type type)
    $someStringToUpperAscii(expr, ctx, type)
  }

  PROC $stringToLower(Zui.Expression expr, SContext ctx, Type type)
    $someStringToLower(expr, ctx, type)
  }

  PROC $stringToUpper(Zui.Expression expr, SContext ctx, Type type)
    $someStringToUpper(expr, ctx, type)
  }

  PROC $varStringToLowerAscii(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%tolowerA)
    ctx.setDeclUsed(%varString2string)
    ctx.setDeclUsed(%string2vs)
    ctx.out.write("Zstring2vs(ZtolowerA(ZvarStringToString(")
    genExpr(expr, ctx, type)
    ctx.out.write(")))")
  }

  PROC $varStringToUpperAscii(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%toupperA)
    ctx.setDeclUsed(%varString2string)
    ctx.setDeclUsed(%string2vs)
    ctx.out.write("Zstring2vs(ZtoupperA(ZvarStringToString(")
    genExpr(expr, ctx, type)
    ctx.out.write(")))")
  }

  PROC $varStringToLower(Zui.Expression expr, SContext ctx, Type type)
    $someStringToLower(expr, ctx, type)
  }

  PROC $varStringToUpper(Zui.Expression expr, SContext ctx, Type type)
    $someStringToUpper(expr, ctx, type)
  }

  PROC $stringFindCharF(Zui.Expression var_expr, bool dotnil,
          list<Zui.Expression> args, SContext ctx, string funcname, Type dest)
    # TODO: throw exception when |dotnil| is FALSE and |expr| evaluates to
    # NIL.  And return NIL instead of '' when |dotnil| is TRUE.
    ctx.out.write("(")
    $genStringExpr(var_expr, ctx, dest)
    IF args.Size() == 2
      ctx.out.write(" )." .. funcname .. "(String.valueOf(")
      genExpr(args[0], ctx, Type.anInt)
      ctx.out.write("), ")
      genExpr(args[1], ctx, Type.anInt)
      ctx.out.write(")")
    ELSE                                      # s.find(int c)
      ctx.out.write(")." .. funcname .. "(String.valueOf(")
      genExpr(args[0], ctx, Type.anInt)
      ctx.out.write("))")
    }
  }

  PROC $stringFindChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "indexOf", Type.aString)
  }

  PROC $varStringFindChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "indexOf", Type.aVarString)
  }

  PROC $byteStringGetByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%getByteFromBS)
    ctx.out.write("ZgetByteFromBS(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    ctx.out.write(")")
  }

  PROC $byteStringGetChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%getCharFromBS)
    ctx.out.write("ZgetCharFromBS(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    ctx.out.write(", 1)")
  }

  PROC $byteStringGetCharSize(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%getCharFromBS)
    ctx.out.write("ZgetCharFromBS(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    ctx.out.write(", 0)")
  }

  PROC $byteStringFindByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "indexOf", Type.aByteString)
  }

  PROC $varByteStringFindByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "indexOf", Type.aVarByteString)
  }

  PROC $stringFindLastChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "lastIndexOf", Type.aString)
  }

  PROC $varStringFindLastChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "lastIndexOf", Type.aVarString)
  }

  PROC $byteStringFindLastByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "lastIndexOf", Type.aByteString)
  }

  PROC $varByteStringFindLastByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "lastIndexOf", Type.aVarByteString)
  }

  PROC $stringFindF(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx,
                                                 string funcname, Type dest)
    # TODO: throw exception when |dotnil| is FALSE and |expr| evaluates to
    # NIL.  And return NIL instead of '' when |dotnil| is TRUE.
    ctx.out.write("(")
    $genStringExpr(var_expr, ctx, dest)
    ctx.out.write(")." .. funcname .. "(")
    genExpr(args[0], ctx, Type.aString)
    IF args.Size() == 2
      ctx.out.write(", (int)")
      genExpr(args[1], ctx, Type.anInt)
    }
    ctx.out.write(")")
  }

  PROC $twoArgs(Zui.Expression var_expr, bool dotnil, list<Zui.Expression> args,
                                     Type varType, Type argType, SContext ctx)
    $genStringExpr(var_expr, ctx, varType)
    ctx.out.write(", ")
    genExpr(args[0], ctx, argType)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $stringCompare(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%stringCompare)
    ctx.out.write("ZstringCompare(")
    $twoArgs(var_expr, dotnil, args, Type.aString, Type.aString, ctx)
  }

  PROC $stringEqual(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%stringEqual)
    ctx.out.write("ZstringEqual(")
    $twoArgs(var_expr, dotnil, args, Type.aString, Type.aString, ctx)
  }

  PROC $byteStringCompare(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%stringCompare)
    ctx.out.write("ZstringCompare(")
    $twoArgs(var_expr, dotnil, args, Type.aByteString, Type.aByteString, ctx)
  }

  PROC $byteStringEqual(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%stringEqual)
    ctx.out.write("ZstringEqual(")
    $twoArgs(var_expr, dotnil, args, Type.aByteString, Type.aByteString, ctx)
  }

  PROC $stringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindF(var_expr, dotnil, args, ctx, "indexOf", Type.aString)
  }

  PROC $stringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindF(var_expr, dotnil, args, ctx, "lastIndexOf", Type.aString)
  }

  PROC $varStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindF(var_expr, dotnil, args, ctx, "indexOf", Type.aVarString)
  }

  PROC $varStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindF(var_expr, dotnil, args, ctx, "lastIndexOf", Type.aVarString)
  }

  PROC $byteStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%bstringFind)
    ctx.setDeclUsed(%string2bs)
    ctx.out.write("ZbstringFind(0, ")
    $twoArgs(var_expr, dotnil, args, Type.aByteString, Type.aString, ctx)
  }

  PROC $byteStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%bstringFind)
    ctx.setDeclUsed(%string2bs)
    ctx.out.write("ZbstringFind(1, ")
    $twoArgs(var_expr, dotnil, args, Type.aByteString, Type.aString, ctx)
  }

  PROC $varByteStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%bstringFind)
    ctx.setDeclUsed(%string2bs)
    ctx.out.write("ZbstringFind(0, ")
    $twoArgs(var_expr, dotnil, args, Type.aVarByteString, Type.aString, ctx)
  }

  PROC $varByteStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.setDeclUsed(%bstringFind)
    ctx.setDeclUsed(%string2bs)
    ctx.out.write("ZbstringFind(1, ")
    $twoArgs(var_expr, dotnil, args, Type.aVarByteString, Type.aString, ctx)
  }

  PROC $stringStartsWith(Zui.Expression var_expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, Type dest)
    ctx.setDeclUsed(%startsWith)
    ctx.out.write("ZstartsWith(")
    $genStringExpr(var_expr, ctx, dest)
    ctx.out.write(", ")
    $genStringExpr(args[0], ctx, dest)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $stringEndsWith(Zui.Expression var_expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, Type dest)
    ctx.setDeclUsed(%endsWith)
    ctx.out.write("ZendsWith(")
    $genStringExpr(var_expr, ctx, dest)
    ctx.out.write(", ")
    $genStringExpr(args[0], ctx, dest)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $stringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringStartsWith(var_expr, dotnil, args, ctx, Type.aString)
  }

  PROC $stringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringEndsWith(var_expr, dotnil, args, ctx, Type.aString)
  }

  PROC $varStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringStartsWith(var_expr, dotnil, args, ctx, Type.aVarString)
  }

  PROC $varStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringEndsWith(var_expr, dotnil, args, ctx, Type.aVarString)
  }

  PROC $byteStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringStartsWith(var_expr, dotnil, args, ctx, Type.aByteString)
  }

  PROC $byteStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringEndsWith(var_expr, dotnil, args, ctx, Type.aByteString)
  }

  PROC $varByteStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringStartsWith(var_expr, dotnil, args, ctx,  Type.aVarByteString)
  }

  PROC $varByteStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringEndsWith(var_expr, dotnil, args, ctx, Type.aVarByteString)
  }

  # Variant of genExpr() that turns a varString into a string.
  PROC $genStringExpr(Zui.Expression var_expr, SContext ctx, Type dest)
    IF dest == Type.aVarString || dest == Type.aVarByteString
      ctx.setDeclUsed(%varString2string)
      ctx.out.write("ZvarStringToString(")
    }
    genExpr(var_expr, ctx, dest)
    IF dest == Type.aVarString || dest == Type.aVarByteString
      ctx.out.write(")")
    }
  }

  PROC $stringSliceWrap(Zui.Expression var_expr, bool dotnil,
                               Zui.MethodCall call, SContext ctx, Type dest)
    ctx.setDeclUsed(%stringSliceWrap)
    ctx.out.write("ZSliceWrap(")
    $genStringExpr(var_expr, ctx, dest)
    ctx.out.write(", ")
    Generate.generateSliceArgs(call, dotnil, ctx)
    ctx.out.write(")")
  }

  PROC $stringSliceWrap(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSliceWrap(var_expr, dotnil, call, ctx, Type.aString)
  }

  PROC $varStringSliceWrap(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    ctx.setDeclUsed(%string2vs)
    ctx.out.write("Zstring2vs(")
    $stringSliceWrap(var_expr, dotnil, call, ctx, Type.aVarString)
    ctx.out.write(")")
  }

  PROC $byteStringSliceWrap(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSliceWrap(var_expr, dotnil, call, ctx, Type.aByteString)
  }

  PROC $varByteStringSliceWrap(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    ctx.setDeclUsed(%string2vs)
    ctx.out.write("Zstring2vs(")
    $stringSliceWrap(var_expr, dotnil, call, ctx, Type.aVarByteString)
    ctx.out.write(")")
  }

  PROC $varAdd(Zui.Expression var_expr, list<Zui.Expression> args,
                                       SContext ctx, Type valsym, Type varsym)
    ctx.setDeclUsed(%varStringAdd)
    ctx.out.write("ZvarStringAdd(")
    genExpr(var_expr, ctx, varsym)
    ctx.out.write(", ")
    genExpr(args[0], ctx, valsym)
    ctx.out.write(")")
  }

  PROC $varStringAdd(Zui.Expression var_expr, list<Zui.Expression> args,
                                                                 SContext ctx)
    $varAdd(var_expr, args, ctx, Type.aString, Type.aVarString)
  }

  PROC $varByteStringAdd(Zui.Expression var_expr, list<Zui.Expression> args,
                                                                 SContext ctx)
    $varAdd(var_expr, args, ctx, Type.aByteString, Type.aVarByteString)
  }

  PROC $stringSplitCommon(Zui.Expression var_expr, bool dotnil,
                       list<Zui.Expression> args, SContext ctx, Type destType)
    $setDeclUsed(%split)
    ctx.out.write("Zsplit(")
    $genStringExpr(var_expr, ctx, destType)
    ctx.out.write(", ")
    genExpr(args[0], ctx, destType)
    ctx.out.write(dotnil ? ", 1)" : ", 0)")
  }

  PROC $stringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
   $stringSplitCommon(var_expr, dotnil, args, ctx, Type.aString)
  }

  PROC $varStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
   $stringSplitCommon(var_expr, dotnil, args, ctx, Type.aVarString)
  }

  PROC $byteStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
   $stringSplitCommon(var_expr, dotnil, args, ctx, Type.aByteString)
  }

  PROC $varByteStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
   $stringSplitCommon(var_expr, dotnil, args, ctx, Type.aVarByteString)
  }

  PROC $stringSize(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%getSize)
    ctx.out.write("ZgetSize(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $byteStringSize(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%getBSize)
    ctx.out.write("ZgetBSize(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varStringSize(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%varStringSize)
    ctx.out.write("ZvarStringSize(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varByteStringSize(Zui.Expression expr, SContext ctx, Type type)
    $varStringSize(expr, ctx, type)
  }

  # Get the hash value of a byteString or string.
  PROC $byteStringHash(Zui.Expression expr, SContext ctx, Type type)
    IF ctx.doError()
      ctx.error("hash() not implemented yet", expr)
    }
    $setDeclUsed(%stringHash)
    ctx.out.write("ZstringHash(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  # Get the hash value of a varByteString or varString.
  PROC $varByteStringHash(Zui.Expression expr, SContext ctx, Type type)
    $byteStringHash(expr, ctx, type)
  }


  PROC $string2varString(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%string2vs)
    ctx.out.write("Zstring2vs(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $string2byteString(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%string2bs)
    ctx.out.write("Zstring2bs(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(")")
  }

  PROC $byteString2string(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%bs2string)
    ctx.out.write("Zbs2string(")
    $genArg(expr, ctx, Type.aByteString)
    ctx.out.write(")")
  }

  PROC $byteString2varString(Zui.Expression expr, SContext ctx)
    $string2varString(expr, ctx, Type.aByteString)
  }

  PROC $varString2string(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%varString2string)
    ctx.out.write("ZvarStringToString(")
    genExpr(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varString2varByteString(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%string2bs)
    ctx.setDeclUsed(%string2vs)
    ctx.setDeclUsed(%varString2string)
    ctx.out.write("Zstring2vs(Zstring2bs(ZvarStringToString(")
    genExpr(expr, ctx, Type.aVarString)
    ctx.out.write(")))")
  }

  PROC $varByteString2string(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%bs2string)
    ctx.setDeclUsed(%varString2string)
    ctx.out.write("Zbs2string(ZvarStringToString(")
    genExpr(expr, ctx, Type.aVarByteString)
    ctx.out.write("))")
  }

  PROC $varByteString2varString(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%bs2string)
    ctx.setDeclUsed(%varString2string)
    ctx.setDeclUsed(%string2vs)
    ctx.out.write("Zstring2vs(Zbs2string(ZvarStringToString(")
    genExpr(expr, ctx, Type.aVarByteString)
    ctx.out.write(")))")
  }

  # Turn a string into an array.
  PROC $stringToArray(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%stringToArray)
    ctx.out.write("ZStringToArray(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(")")
  }

  # Turn a byteString into an array.
  PROC $byteStringToArray(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%stringToArray)
    ctx.out.write("ZStringToArray(")
    $genArg(expr, ctx, Type.aByteString)
    ctx.out.write(")")
  }

  # Generate a switch() and return the type of the expression.
  FUNC $switch(Zui.Expression expr, Zui.CodeBlock block, SContext ctx) Type
    ctx.out.writeIndent(ctx.scope.depth)
    Type.Enum ttype = expr.<ZuiExpressionExt>.resultType?.getTtype()
    IF ttype == Type.Enum.type || ttype == Type.Enum.string
      IF block != NIL
        string name = block.<ZuiCodeBlockExt>.scope.<SwitchScope>.varName
        ctx.out.write("int ")
        ctx.out.write(name)
        ctx.out.write(" = ")
      }
    ELSE
      ctx.out.write("switch (")
    }
    Type switchType = genExpr(expr, ctx)
    IF ttype == Type.Enum.type || ttype == Type.Enum.string
      ctx.out.write(";\n")
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("while(1) ")
    ELSE
      ctx.out.write(") ")
    }
    RETURN switchType
  }

  FUNC $caseString(Zui.Expression expr, bool isMatch,
                                        bool caseFollows, SContext ctx) string
    Output out = ctx.out
    IF !out.writing
      RETURN ""
    }

    SwitchScope scope = ctx.scope
    Type.Enum ttype = scope.switchType?.getTtype()
    Type destType = scope.switchType
    string close = ""
    IF scope.useIf
      IF scope.wroteCase
        out.write(" || ")
      ELSE
        out.writeIndent(ctx.scope.depth)
        out.write("if (")
        scope.wroteCase = TRUE
        IF scope.didProceed
          out.write(scope.varName)
          out.write(" == Zproceed || ")
        }
      }
      IF isMatch
        IF Type.isRegex(expr.<ZuiExpressionExt>.resultType, ctx)
          out.write("(")
          destType = Type.regexType.getValueType(ctx)
          close = ").matches(\(scope.varName))"
        ELSE
          out.write("0 <= ")
          out.write(scope.varName)
          out.write(".search(new RegExp(")
          close = "))"
        }
      ELSE
        out.write(scope.varName)
        out.write(" == ")
      }
    ELSE
      out.writeIndent(ctx.scope.depth)
      out.write("case ")
      close = ":\n"
    }

    # First write the output to caseOut, so that we can check for
    # duplicate values and add a type cast when needed.
    Output caseOut = NEW()
    caseOut.writing = TRUE
    genExpr(expr, ctx.copy(caseOut), destType)
    out.append(caseOut)

    out.write(close)
    IF scope.useIf && !caseFollows
      out.write(")\n")
    }
    RETURN caseOut.ToString()
  }

  PROC $caseEnd(Zui.Position pos, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth - 1)
    ctx.out.write("break;\n")
  }

  PROC $writeProceed(Zui.Statement stmt, SContext ctx)
    IF stmt.getType() == Zui.StatementType.eCASE
      # We enter the next block by setting the switch variable equal to the
      # special "proceed" value.
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write(ctx.scope.<SwitchScope>.varName)
      ctx.out.write(" = Zproceed;\n")
    }
  }

  PROC $default(SContext ctx)
    SwitchScope scope = ctx.scope
    Type.Enum ttype = scope.switchType?.getTtype()
    IF !scope.useIf
      ctx.out.writeIndent(ctx.scope.depth - 1)
      ctx.out.write("default:\n")
    }
  }

  PROC $switchEnd(SContext ctx)
  }

  PROC $writeTtype(string name, Zui.Position pos, SContext ctx)
    string s = typeStructs.get(name, NIL)
    IF s == NIL
      ctx.error("Unsupported type: " .. name, pos)
    ELSE
      ctx.out.write(s)
    }
  }

  PROC $startBlock(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("{\n")
  }

  PROC $forBlockStart(ForLoopInfo info, SContext ctx)
    # When looping over an iterator, check that the object is not NIL.
    # Need to get the iterator first.
    bool hasIterator
    FOR i IN 0 UNTIL info.iters.Size()
      ForLoopInfo.Iter iter = info.iters[i]
      IF iter.iteratorType != NIL
        hasIterator = TRUE

        # Use $Iterator() or $KeyIterator() of the class.
        Type iterType = iter.varDecl.type
        Zui.Expression expr = info.forStmt.getIter(i)
        ClassType class = iterType.getClassType(ctx)
        IF class == NIL
          ctx.error("Missing Iterator class", expr)
          RETURN
        }
        IF class.templateTypes == NIL
          ctx.error("Missing I.Iterator template type", expr)
          RETURN
        }

        ctx.out.writeIndent(ctx.scope.depth)
        ctx.out.write("int ")
        ctx.out.write(iter.varDecl.pName)
        IF iter.iteratorMethod != NIL
          ctx.out.write("v")
        }
        ctx.out.write(" = ")
        $genArg(expr, ctx, NIL)
        ctx.out.write(";\n")
      }
    }

    IF hasIterator
      # "FOR x IN obj": do nothing if obj is NIL.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("if (")
      bool didOne
      FOR i IN 0 UNTIL info.iters.Size()
        ForLoopInfo.Iter iter = info.iters[i]
        IF iter.iteratorType != NIL
          IF didOne
            ctx.out.write(" && ")
          }
          didOne = TRUE
          ctx.out.write(iter.varDecl.pName)
          IF iter.iteratorMethod != NIL
            ctx.out.write("v")
          }
          ctx.out.write(" != null")
        }
      }
      ctx.out.write(")\n")
    }

    $startBlock(ctx)
  }

  FUNC $forStart(ForLoopInfo info,
                 Type toType, Type untilType, Type stepType,
                 SContext ctx
                ) list<Type>
    list<Type> itemTypes
    Zui.ForStatement stmt = info.forStmt

    FOR i IN 0 UNTIL info.iters.Size()
      ForLoopInfo.Iter iter = info.iters[i]
      Type iterType = iter.varDecl.type
      string iterVarName = iter.varDecl.pName
      Zui.Expression expr = stmt.getIter(i)
      Type itemType
      Type keyType

      IF iter.iteratorType != NIL
        ClassType class = iterType.getClassType(ctx)

        # Use $Iterator() or $KeyIterator() of the class.
        # Calling obj.Iterator() here.
        IF iter.iteratorMethod != NIL
          IF class == NIL
            # Error given previously
            RETURN [Type.anInt]
          }
          IF class.templateTypes == NIL
            # Error given previously
            RETURN [Type.anInt]
          }

          ctx.out.writeIndent(ctx.scope.depth + 1)
          ctx.out.write("int ")
          ctx.out.write(iter.varDecl.pName)
          ctx.out.write(" = ")
          ctx.out.write(iter.varDecl.pName .. "v")
          ctx.out.write(".")
          ctx.out.write(iter.iteratorMethod.name)
          ctx.out.write("()")
          ctx.out.write(";\n")
        }

        # I.KeyIterator<int, string> returns int + string..
        IF class.templateTypes.Size() > 1
          IF info.iters.Size() > 1
            ctx.error("Cannot use KeyIterator here", expr)
            RETURN [Type.anInt]
          }
          itemTypes = NEW()
          FOR decl IN class.templateTypes
            itemTypes.add(decl.type)
          }
        ELSE
          # I.Iterator<int> returns int.
          itemType = class.templateTypes[0].type
        }
      ELSE
        Type.Enum ttype = iterType.getTtype()
        SWITCH ttype
          CASE Type.Enum.array
          CASE Type.Enum.list
          CASE Type.Enum.dict
            # When key/item type is NIL must be an empty array/list/dict, use
            # int.
            ContainerType ct = iterType.getEffType()
            itemType = ct.itemType ?: Type.anInt

            # Use a separate set of items for List, so that a FOR loop over
            # other things doesn't drag in all the list stuff.
            ctx.out.writeIndent(ctx.scope.depth + 1)
            IF ttype == Type.Enum.dict
              ctx.out.write("ZforDict<> " .. iterVarName)
              ctx.setDeclUsed(%forDict)
              ctx.out.write(" = ZforDictNew(")
            ELSE
              string typeString = $vartypeString(itemType, FALSE, TRUE,
                                                           expr.getPos(), ctx)
              ctx.out.write("ZforList<\(typeString)> \(iterVarName)")
              ctx.setDeclUsed(%forList)
              ctx.out.write(" = new ZforList<\(typeString)>(")
            }
            genExpr(expr, ctx)
            ctx.out.write(");\n")

            IF info.forStmt.sizeLoopVar() > 1 && info.iters.Size() == 1
              IF ttype == Type.Enum.dict
                itemTypes = [ct.keyType ?: Type.anInt, itemType]
              ELSE
                itemTypes = [Type.anInt, itemType]
              }
              itemType = NIL
            }

          CASE Type.Enum.byteString
          CASE Type.Enum.string
          CASE Type.Enum.stringval
            # TODO: byteString is different
            ctx.setDeclUsed(%forString)
            ctx.out.writeIndent(ctx.scope.depth + 1)
            ctx.out.write("int " .. iterVarName .. " = ZforStringNew(")
            genExpr(expr, ctx, iterType)
            ctx.out.write(");\n")
            itemType = Type.anInt

          CASE Type.Enum.int
          CASE Type.Enum.int8
          CASE Type.Enum.int16
          CASE Type.Enum.int32
          CASE Type.Enum.nat
          CASE Type.Enum.byte
          CASE Type.Enum.nat16
          CASE Type.Enum.nat32
          CASE Type.Enum.natval
          CASE Type.Enum.intval
            IF toType == NIL && untilType == NIL
              ctx.error("Not supported: FOR on "
                                           .. iterType.ttype.ToString(), expr)
              RETURN NIL
            }
            ctx.setDeclUsed(%forRange)
            IF !simpleForLoop(stmt, ctx)
              ctx.out.writeIndent(ctx.scope.depth + 1)
              ctx.out.write("ZforRange " .. iterVarName .. " = new ZforRange(")
              genExpr(expr, ctx, Type.anInt)
              ctx.out.write(", ")
              IF toType != NIL
                genExpr(stmt.getTo(), ctx, Type.anInt)
                ctx.out.write(", 0, ")
              ELSE
                genExpr(stmt.getUntil(), ctx, Type.anInt)
                ctx.out.write(", 1, ")
              }
              IF stmt.hasStep()
                genExpr(stmt.getStep(), ctx, Type.anInt)
              ELSE
                ctx.out.write("1")
              }
              ctx.out.write(");\n")
            }
            itemType = Type.anInt

          CASE Type.Enum.enum
          CASE Type.Enum.enumValue
            ctx.setDeclUsed(%forEnum)
            ctx.out.writeIndent(ctx.scope.depth + 1)
            ctx.out.write("int " .. iterVarName .. " = ZforEnumNew(")
            EnumType et = iterType.<EnumType>
            IF et.members == NIL
              ctx.out.write(0 .. "")
            ELSE
              ctx.out.write(et.members.Size() .. "")
            }
            ctx.out.write(");\n")
            IF iterType ISA EnumType
              itemType = iterType.<EnumType>.getEnumValue()
            ELSE
              itemType = iterType
            }

          CASE Type.Enum.object
          CASE Type.Enum.iobject
            ctx.error("No iterator found for "
                                     .. iterType.getClassType(ctx).name, expr)

          DEFAULT
            ctx.error("Not supported: FOR on " .. iterType.typeName(), expr)
        }
      }

      IF itemType != NIL
        IF itemTypes == NIL
          itemTypes = NEW()
        }
        itemTypes.add(itemType)
      }
    }
    RETURN itemTypes
  }

  PROC $forLoop(ForLoopInfo info, list<Declaration> varList, SContext ctx)
    Output out = ctx.out
    IF !out.writing
      RETURN
    }
    Output declOut = NEW(TRUE)
    Output startOut = NEW(TRUE)
    Output contOut = NEW(TRUE)
    Output incOut = NEW(TRUE)
    Zui.ForStatement for = info.forStmt

    FOR idx IN 0 UNTIL info.iters.Size()
      ForLoopInfo.Iter iter = info.iters[idx]
      IF idx > 0
        contOut.write(" && ")
      }

      IF iter.iteratorType != NIL
        # it.hasNext() && (Vi = it.next(), 1)
        SContext contCtx = ctx.copy(contOut)
        $forLoopIteratorWhile(info, varList, idx,
              { name, i => name .. "[" .. i .. "]" }, contCtx)
        CONTINUE
      }

      string type = ""
      Declaration.C varDecl = varList[idx]
      string loopVarName = varDecl.pName
      string iterVarName = iter.varDecl.pName

      ENUM LoopType
        noIdx
        simple
        list
        dict
      }
      LoopType loopType

      bool usingKey = varList.Size() > info.iters.Size()

      SWITCH iter.varDecl.type.ttype
        CASE Type.Enum.array  # array works the same as list
        CASE Type.Enum.list
          loopType = LoopType.list
          type = "List"

        CASE Type.Enum.dict
          loopType = LoopType.dict
          type = "Dict"

        CASE Type.Enum.string
        CASE Type.Enum.stringval
        CASE Type.Enum.byteString  # TODO: separate handling?
          type = "String"

        CASE Type.Enum.enum
        CASE Type.Enum.enumValue
          type = "Enum"

        CASE Type.Enum.int
        CASE Type.Enum.int8
        CASE Type.Enum.int16
        CASE Type.Enum.int32
        CASE Type.Enum.nat
        CASE Type.Enum.byte
        CASE Type.Enum.nat16
        CASE Type.Enum.nat32
        CASE Type.Enum.natval
        CASE Type.Enum.intval
          IF simpleForLoop(for, ctx)
            loopType = LoopType.simple
          ELSE
            type = "Range"
          }

        DEFAULT
          Report.error("Type not supported: " .. iter.varDecl.type.typeName())
      }

      SWITCH loopType
        CASE LoopType.simple
            IF !startOut.empty()
              startOut.write(", ")
            }
            startOut.write(loopVarName .. " = ")
            SContext startCtx = ctx.copy(startOut)
            genExpr(for.getIter(0), startCtx, Type.anInt)
            bool isContextFree = TRUE
            contOut.write(loopVarName)
            IF !for.hasStep() || ExprEval.evalInt(for.getStep(), ctx,
                                                     TRUE, &isContextFree) > 0
              contOut.write(" <= ")
            ELSE
              contOut.write(" >= ")
            }
            SContext contCtx = ctx.copy(contOut)
            genExpr(for.getTo(), contCtx, Type.anInt)
            IF !incOut.empty()
              incOut.write(", ")
            }
            IF !for.hasStep()
              incOut.write("++" .. loopVarName)
            ELSE
              incOut.write(loopVarName .. " += ")
              SContext incCtx = ctx.copy(contOut)
              genExpr(for.getStep(), incCtx, Type.anInt)
            }

        CASE LoopType.noIdx
        CASE LoopType.list
        CASE LoopType.dict
          Declaration.C keyDecl = varList[0]
          IF usingKey
            varDecl = varList[1]
          }
          string pName = varDecl.pName

          IF !startOut.empty()
            startOut.write(", ")
          }
          IF usingKey
            IF loopType == LoopType.dict
              startOut.write("\(keyDecl.pName) = ZforDictNextKey(\(iterVarName)), ")
            ELSE
              startOut.write("\(keyDecl.pName) = \(iterVarName).idx, ")
            }
          }
          startOut.write("\(pName) = \(iterVarName).get()")
          contOut.write("\(iterVarName).cont()")
          IF !incOut.empty()
            incOut.write(", ")
          }
          incOut.write("\(pName) = \(iterVarName).next()")
          # IF type == "Range"
          #   incOut.write(", " .. pName)
          # }
          IF usingKey
            incOut.write(", " .. keyDecl.pName)
            IF loopType == LoopType.dict
              incOut.write(" = ZforDictNextKey(" .. iterVarName .. ")")
            ELSE
              incOut.write(" = " .. iterVarName .. ".idx")
            }
          }
      }
    }

    out.append(declOut)
    out.writeIndent(ctx.scope.depth + 1)
    out.write("for (")
    out.append(startOut)
    out.write("; ")
    out.append(contOut)
    out.write("; ")
    out.append(incOut)
    out.write(") {\n")
  }

  PROC $forEnd(ForLoopInfo info, Zui.Statement stmt, SContext ctx)
  }

  # A BREAK statement that jumps to a FINALLY.
  PROC $writeBreakGotoFinally(Scope s, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("break;\n")
  }

  # A BREAK statement that finishes a loop.
  PROC $writeBreak(Zui.Position pos, SContext ctx)
    Scope scope = ctx.scope
    WHILE scope != NIL
      $writeScopeEndFinish(pos, scope, ctx)
      IF scope.isBreakScope()
        BREAK
      }
      scope = scope.outer
    }
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("break;\n")
  }

  # A CONTINUE statement that jumps to a FINALLY.
  PROC $writeContinueGotoFinally(Scope s, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("continue;\n")
  }

  # A CONTINUE statement that finishes a loop.
  PROC $writeContinue(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("continue;\n")
  }

  # UNITL of a DO block.
  FUNC $until(Zui.Condition cond, SContext ctx) int
    RETURN until(cond, ctx)
  }

  FUNC $typecast(Type type, SContext ctx) string
    RETURN ""
  }

  FUNC $ptrTypecast(Type type, bool ptr, SContext ctx) string
    RETURN ""
  }


  PROC $throw(Zui.Statement stmt, bool hasNextStmt, Type type, SContext ctx)
    Output out = ctx.out
    IF !out.writing
      RETURN
    }

    out.writeIndent(ctx.scope.depth)
    bool throwString = type != NIL && (type.ttype == Type.Enum.string
                                         || type.ttype == Type.Enum.stringval)
    IF throwString
      $setDeclUsed(%throw)
      string newPos = DeclStore.getPName("MZModule__CPos", "MNEW__1")
      Z.Pos pos = ctx.zcPos(stmt.getPos())
      out.write("throw ZstringEx(\(newPos)(null, '\(pos.filename)', \(pos.lnum), \(pos.col)), ")
      genExpr(stmt.getExpr(), ctx)
      out.write(");\n")
    ELSE
      out.write("throw ")
      genExpr(stmt.getExpr(), ctx)
      out.write(";\n")
    }
  }

  PROC $try_block(Zui.Statement stmt, SContext ctx)
    IF $isDeclUsed(Declaration.defer)
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("int tryDeferLen = deferList.length;\n")
    }
    IF $isDeclUsed(Declaration.hasFinish)
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("int tryFinishLen = onStackList.length;\n")
    }
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("try\n")
  }

  PROC $try_block_end(Zui.Statement stmt, SContext ctx)
  }

  PROC $try_catch_start(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("catch (Exception ex) {\n")
    IF $isDeclUsed(Declaration.defer)
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write("ZdeferCall(tryDeferLen);\n")
    }
    IF $isDeclUsed(Declaration.hasFinish)
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write("ZFinishCall(tryFinishLen);\n")
    }
  }

  PROC $try_catch(Zui.Catch catch, bool first,
                                            list<Type> typeList, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    IF !first
      ctx.out.write("else ")
    }
    ctx.out.write("if (")
    string or = ""
    Declaration memAccess = DeclStore.getDecl("MEModule", "CMemoryAccess")
    Declaration exception = DeclStore.getDecl("MEModule", "CException")
    FOR type IN typeList
      # If the class is not marked used the exception cannot be created, thus
      # the result of the condition is always false.
      Type classType = type.getClassType(ctx)
      IF memAccess == NIL
        IO.print("Cannot find CMemoryAccess")
      ELSEIF classType IS memAccess
        # A MemoryAccess exception is not thrown, we get a Javascript
        # exception that is not an instance
        ctx.out.write(or)
        ctx.out.write("!(ex instanceof ")
        ctx.out.write(exception.pName)
        ctx.out.write(")")
        or = " || "
      ELSEIF $isDeclUsed(classType)
        ctx.out.write(or)
        ctx.out.write("ex instanceof ")
        ctx.out.write(classType.pName)
        or = " || "
      }
    }
    IF or == ""
      ctx.out.write("false")
    }
    ctx.out.write(") { /* CATCH */\n")
  }

  # Generate what comes after a list of CATCH parts.
  PROC $try_catch_end(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("else throw ex;\n")
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("}\n")
  }

  # Generate after a TRY without a CATCH.
  PROC $try_no_catch(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("catch (Exception ex) {\n")
    IF $isDeclUsed(Declaration.defer)
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write("ZdeferCall(tryDeferLen);\n")
    }
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("}\n")
  }

  PROC $topException(Declaration.C destDecl, Zui.Position pos,
                                              SContext ctx, SContext blockCtx)
    ctx.out.write("ex")
  }

  PROC $discardTopException(SContext ctx)
  }

  PROC $try_else(Zui.Statement stmt, SContext ctx)
    # TODO
  }

  PROC $try_finally(Zui.Statement stmt, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("finally\n")
  }

  PROC $try_end(Zui.Statement stmt, SContext ctx)
  }

  # Write the stack frame offset table.
  PROC $methodLeader(MethodType method, Output out, SContext ctx)
  }

  PROC $methodBodyStart(MethodType method, bool isNew, bool isInit,
                                               Zui.Position pos, SContext ctx)
    IF isInit
      ctx.out.writeIndent(1)
      ctx.out.write("if (!")
      ctx.out.write(newThisName)
      ctx.out.write(") ")
      ctx.out.write(newThisName)
      ctx.out.write(" = ")
      $writeAlloc(method.classType, NIL, ctx.out, ctx)
      ctx.out.write(";\n")
    }

    # When using CTX.add() need to get the current context length.
    IF method.scope?.hasCtxAdd
      ctx.out.write(" var ctxUsed = ctxArr.length;\n")
    }
    IF method.scope?.hasDefer
      ctx.out.write(" var deferLen = deferList.length;\n")
    }

    # Declare temp variables.
    IF method.scope?.tempVars != NIL
      FOR decl IN method.scope.tempVars
        IF !decl.inMethodScope
          ctx.out.write(" ")
          ctx.out.write($vartypeString(decl.type, TRUE, NIL, ctx))
          ctx.out.write(decl.pName)
          ctx.out.write(" = ")
          $defaultInit(decl.type.getValueType(ctx), ctx.out, ctx)
          ctx.out.write(";\n")
        }
      }
    }
  }

  # The expression that evaluates to TRUE when THIS is NIL.
  PROC $ifnilExpr(SContext ctx)
    IF ctx.scope.insideBuiltin() && !ctx.scope.isClassScope()
      ctx.out.write("if (Athis == null)\n")
    ELSE
      ctx.out.write("if (thisArg == null)\n")
    }
  }

  # What comes after the IFNIL statement.
  PROC $belowIfnil(SContext ctx)
    IF ctx.scope.insideBuiltin() && !ctx.scope.isClassScope()
      # In a builtin method Athis is passed and used.
      RETURN
    }
    MethodType method = ctx.scope.outerDecl.type

    ctx.out.writeIndent(ctx.scope.depth)
    string fname = ctx.scope.scopeName .. "X"
    ctx.out.write("return thisArg.")
    ctx.out.write(fname)
    ctx.out.write("(")

    IO.StringWriter args = NEW()
    string comma = ""
    FOR arg IN method.arguments
      args.write(comma)
      IF arg.pName == NIL
        args.write("A")
        args.write(arg.name)
      ELSE
        args.write(arg.pName)
      }
      comma = ", "
    }

    string arguments = args.ToString()
    ctx.out.write(arguments)
    ctx.out.write(")\n")
    ctx.out.write("}\n")
    ctx.out.write("function ")
    ctx.out.write(fname)
    ctx.out.write("(")
    ctx.out.write(arguments)
    ctx.out.write(") {\n")
  }

  PROC $beforeStatement(Zui.Statement stmt, SContext ctx)
    $beforeStatement(stmt.getPos(), stmt, ctx)
  }

  PROC $beforeStatement(Zui.Position pos, Zui.Statement stmt, SContext ctx)
    ZuiStatementExt stmtExt = stmt
    IF stmtExt.usesCallerPos
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("ZcallerPos = ")
      ctx.out.write(newPosString(pos, ctx))
      ctx.out.write(";\n")
    }
  }

  PROC $beforeStatement(Zui.Position pos, bool beforeCall, SContext ctx)
    Zui.Statement stmt = CTX.get(Zui.Statement.Type())
    IF stmt != NIL
      $beforeStatement(stmt.getPos(), stmt, ctx)
    }
  }

  PROC $beforeCallStatement(Zui.Position pos, SContext ctx)
  }

  PROC $afterStatement(Zui.Statement stmt, SContext ctx)
    ZuiStatementExt stmtExt = stmt
    IF stmtExt.usesCallerPos
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("ZcallerPos = null;\n")
    }
  }

  PROC $afterCall(SContext ctx)
  }

  PROC $writeRef(string varname, SContext ctx)
    # Use a function that returns the varname value.
    # If |write| is true assign |val| to the varname.
    ctx.out.write("function(write, val) {if (write) ")
    ctx.out.write(varname)
    ctx.out.write(" = val; return ")
    ctx.out.write(varname)
    ctx.out.write(";}")
  }

  # Write a variable increment or decrement as a statement.
  FUNC $writeIncDec(Zui.Statement stmt, SContext ctx) Declaration
    Output out = ctx.out
    Output varOut = NEW()
    varOut.writing = out.writing
    Declaration decl = Generate.generateLVarname(stmt.getExpr(), TRUE,
                                                 ctx.copy(varOut), Type.anInt)
    IF Generate.isByRef(stmt.getExpr(), ctx)
      # An argument passed by reference requires a function call:
      # f(1, f(0, 0) + 1)
      out.write(varOut.ToString())
      out.write("(1, ")
      out.write(varOut.ToString())
      out.write("(0, 0) ")
      IF stmt.getType() == Zui.StatementType.eINC
        out.write("+")
      ELSE
        out.write("-")
      }
      out.write(" 1)")
    ELSE
      IF stmt.getType() == Zui.StatementType.eINC
        out.write("++(")
      ELSE
        out.write("--(")
      }
      out.write(varOut.ToString())
      out.write(")")
    }
    RETURN decl
  }

  # Write a call statement, possibly dereferencing the return value.
  PROC $callStatement(Type retType, Output callOut, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.append(callOut)
    $statementLineEnd(ctx.out)
  }

  PROC $returnBefore(bool proc, bool multi, Zui.Position pos, SContext ctx)
    $writeBeforeReturn(pos, ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("return ")
    IF multi
      ctx.out.write("new \($vartypeString(ctx.scope.returnType,
                                                          FALSE, pos, ctx))(")
    }
  }

  PROC $returnAfter(Type returnType, bool writeScopeEnd,
                                               Zui.Position pos, SContext ctx)
    $writeBeforeReturn(pos, ctx)
  }

  PROC $jumpToReturn(Zui.Position pos, SContext ctx)
    # No need to take care of memory or exceptions.
    $writeBeforeReturn(pos, ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("return;\n")
  }

  # Whether a RETURN with more than one value is done in one line.
  FUNC $compactMultiReturn() bool
    RETURN TRUE
  }

  PROC $returnAfterMulti(SContext ctx)
    ctx.out.write(")")
  }

  # Write declaration for catch in try block.
  FUNC $declareInBlock() bool
    RETURN TRUE
  }

  # Extra argument for RETURN.
  # expr.undefined will be set.
  PROC $extraReturn(Zui.Expression expr, int idx, SContext ctx, Type destType)
  }

  PROC $jumpToOuterScope(Zui.Position pos, SContext ctx)
    # No need to take care of memory or exceptions.
    IF ctx.scope.returnType == NIL
      $jumpToReturn(pos, ctx)
    }
  }

  # Write code to exit, before evaluating the argument.
  PROC $exitBefore(Zui.Statement stmt, SContext ctx)
    $setDeclUsed(Declaration.exit)
    ctx.out.write("Zexit(")
    ctx.out.write(newPosString(stmt.getPos(), ctx))
    ctx.out.write(", ")
  }

  # Write code to exit, after evaluating the argument.
  PROC $exitAfter(bool lastStatement, SContext ctx)
    ctx.out.write(");\n")
  }

  PROC $writeBacktrace(Zui.MethodCall call, SContext ctx)
    ctx.out.write("null")
  }

  PROC $writeCallerPos(SContext ctx)
    ctx.out.write("ZcallerPos")
  }

  # Write a comment about declaring |name| in |scopeName|.
  PROC $declComment(string scopeName, string name, Output out)
    IF name != ""
      out.write(" // " .. scopeName.slice(1) .. "." .. name)
    }
  }

  # Return TRUE when a module needs to be generated.
  FUNC $doGenerateModule(SContext ctx) bool
    RETURN ctx.scope.usedAsZwt()
  }

  # Return TRUE when functions are written to bodyOut.
  FUNC $funcInBody() bool
    RETURN TRUE
  }

  # Use int for bool, status, and others in for loop.
  FUNC $useIntInForLoop() bool
    RETURN FALSE
  }

  # Return TRUE when interfaces are written.
  FUNC $writeInterface() bool
    RETURN TRUE
  }

  FUNC $prefixClassToNew() bool
    RETURN TRUE
  }

  PROC $moduleType(ModuleType mt, SContext ctx)
  }

  # Set dependencies between items.
  PROC $addDependencies()
    # Add dependencies for all the CodeWriters.
    CodeWriter.addDependencies(codeWriters, THIS)

    WriteArrayJava.addDependencies(THIS)
    WriteListJava.addDependencies(THIS)
    WriteDictJava.addDependencies(THIS)

    # TODO: used for backtrace now
    $setDeclUsed(Declaration.list)
  }

  # Set used flags for dependencies of used items.
  PROC $markUsed()
    IF $isDeclUsed(Declaration.throwOutOfRange)
      $setDeclUsed(DeclStore.getDecl("MEModule", "FthrowOutOfRange"))
    }
    $setDeclUsed(DeclStore.getDecl("MEModule__CNilAccess", "MNEW__p2__2"))

    # TODO: only when actually used
    $setDeclUsed(%throw)
    IF $isDeclUsed(Declaration.throwString)
      $setDeclUsed(DeclStore.getDecl("MZModule__CPos", "MNEW__1"))
    }

    IF Arguments.testMode
      # When testing TEST.runTest() will be used by code generated in
      # $writeTestMethods()
      $setDeclUsed(DeclStore.getDecl("MTESTModule", "FrunTest"))
      $setDeclUsed(DeclStore.getDecl("MTESTModule", "Freport"))
    }
  }

  SHARED

    FUNC Init() status
      initCodeWriters()
      RETURN OK
    }

    list<proc<WriteJava, Output>> mainEarlyInitWriters = NEW()
    list<proc<Resolve, Output>> mainInitWriters = NEW()

    string newThisName = "thisO"  # Name of "THIS" inside NEW()
    string cbThisName = "this1"   # Name of "THIS" inside a closure

    list<proc<WriteJava, IO.File>> funcWriters = NEW()

    # Declarations to keep track of used items.
    Declaration.C %collections = NEW("collections")

    Declaration.C %bind = NEW("bind")
    Declaration.C %forList = NEW("forList")
    Declaration.C %forDict = NEW("forDict")
    Declaration.C %forString = NEW("forString")
    Declaration.C %forRange = NEW("forRange")
    Declaration.C %forEnum = NEW("forEnum")
    Declaration.C %bool2string = NEW("bool2string")
    Declaration.C %float2string = NEW("float2string")
    Declaration.C %floatFormat = NEW("floatFormat")
    Declaration.C %status2string = NEW("status2string")
    Declaration.C %intFormat = NEW("intFormat")
    Declaration.C %stringFormat = NEW("stringFormat")
    Declaration.C %stringToArray = NEW("stringToArray")
    Declaration.C %dynToString = NEW("dynToString")
    Declaration.C %dynType = NEW("dynType")
    Declaration.C %stringSliceWrap = NEW("stringSliceWrap")
    Declaration.C %startsWith = NEW("startsWith")
    Declaration.C %isdigit = NEW("isdigit")
    Declaration.C %isInfinite = NEW("isInfinite")
    Declaration.C %trunc = NEW("trunc")
    Declaration.C %round = NEW("round")
    Declaration.C %float2int = NEW("float2int")
    Declaration.C %sinh = NEW("sinh")
    Declaration.C %cosh = NEW("cosh")
    Declaration.C %tanh = NEW("tanh")
    Declaration.C %isXdigit = NEW("isXdigit")
    Declaration.C %isAlpha = NEW("isAlpha")
    Declaration.C %isLower = NEW("isLower")
    Declaration.C %isUpper = NEW("isUpper")
    Declaration.C %endsWith = NEW("endsWith")
    Declaration.C %object2string = NEW("%object2string")
    Declaration.C %enumFromString = NEW("%enumFromString")
    Declaration.C %getSize = NEW("%getSize")
    Declaration.C %getBSize = NEW("%getBSize")
    Declaration.C %varStringSize = NEW("%varStringSize")
    Declaration.C %varStringAdd = NEW("%varStringAdd")
    Declaration.C %stringHash = NEW("%stringHash")
    Declaration.C %null2nil = NEW("%null2nil")
    Declaration.C %varString2string = NEW("%varString2string")
    Declaration.C %string2bs = NEW("%string2bs")
    Declaration.C %string2vs = NEW("%string2vs")
    Declaration.C %bs2string = NEW("%bs2string")
    Declaration.C %getByteFromBS = NEW("%getByteFromBS")
    Declaration.C %getCharFromBS = NEW("%getCharFromBS")
    Declaration.C %stringCompare = NEW("stringCompare")
    Declaration.C %stringEqual = NEW("stringEqual")
    Declaration.C %bstringFind = NEW("bstringFind")
    Declaration.C %split = NEW("split")
    Declaration.C %throw = NEW("throw")
    Declaration.C %stringToFloat = NEW("stringToFloat")
    Declaration.C %tolower = NEW("tolower")
    Declaration.C %tolowerA = NEW("tolowerA")
    Declaration.C %toupper = NEW("toupper")
    Declaration.C %toupperA = NEW("toupperA")
    Declaration.C %parseInt = NEW("parseInt")
    Declaration.C %parseQuotedInt = NEW("parseQuotedInt")
    Declaration.C %floatCompare = NEW("floatCompare")
    Declaration.C %typeCompare = NEW("typeCompare")
    Declaration.C %noAllocNil = NEW("%noAllocNil")
    Declaration.C %clone = NEW("clone")
    Declaration.C %varByteStringType = NEW("varByteStringType")

    Declaration %javaDate = NEW("javaDate")          # Date
    Declaration %javaCalendar = NEW("javaCalendar")  # Calendar

    # Return the list of items that can be used in >>> uses().
    FUNC getUsesDeclarations() list<Declaration>
      RETURN [%javaDate, %javaCalendar]
    }

    list<CodeWriter> codeWriters = NEW()

    PROC initCodeWriters()
      # Initialize |codeWriters| with all the code fragments we can write.
      # This keeps all the dependencies, typedefs and structure declarations
      # in one place.
      # Order matters: functions which are written without a declaration need
      # to be written before they are used.

      codeWriters.add(NEW(%bind,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zbind(fn, o) {
 if (!fn) return null;
 return function() { return fn.apply(o, arguments); };
}
"'')
        }))

      codeWriters.add(NEW(Declaration.hasFinish,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZFinish(o, rsn) {
 if (o && o.Finish) {
  try {
   o.Finish(rsn);
   } catch (e) {
  }
 }
}
static void ZFinishCall(int len) {
 while (onStackList.size() > len) {
  ProcRef0 cb = onStackList.remove(onStackList.size() - 1);
  try {
   cb.call();
  } catch Exception e {
  }
 }
}
"'')
        }).setDecl("List<ProcRef0) onStackList = new ArrayList<>();"))

      codeWriters.add(NEW(Declaration.usesCtx,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
var ctxArr = [];
function CtxGet(t) {
 for (i = ctxArr.length; --i >= 0; )
  if (ctxArr[i][0] == t) {
   if (ctxArr[i].length == 3) return ctxArr[i][2].call(ctxArr[i][1]);
   return ctxArr[i][1];
  }
 return null;
}
function CtxAdd(t, o) {
 ctxArr[ctxArr.length] = [t, o];
}
function CtxAddProvider(t, o, p) {
 ctxArr[ctxArr.length] = [t, o, p];
}
"'')
        }))

      codeWriters.add(NEW(Declaration.proceed,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
var Zproceed = "proceed";
"'')
        }))

      codeWriters.add(NEW(%forList,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
static class ZforList<Ti> {
 public List<Ti> list;
 public int idx;
 public ZforList(ZList<Ti> list) {
  this.list = list.list;
  this.idx = 0;
 }
 public Ti get() {
  if (list != null && idx < list.size()) {
   return list.get(idx);
  }
  return null;
 }
 public boolean cont() {
   return list != null && idx < list.size();
 }
 public Ti next() {
  ++idx;
  if (list != null && idx < list.size()) {
   return list.get(idx);
  }
  return null;
 }
}
"'')
        }))

      codeWriters.add(NEW(%forDict,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZforDictNew(d) {
 var f = {};
 f['dict'] = d;
 f['idx'] = 0;
 var l = [];
 if (d) for (var key in d) if (key.charAt(0) == 58) l.push(key);
 f['keys'] = l;
 return f;
}
function ZforDictGet(f) {
 if (f.dict != null && f.idx < f.keys.length)
  return f.dict[f.keys[f.idx]][1];
 return null;
}
function ZforDictCont(f) {
  return f.dict != null && f.idx < f.keys.length;
}
function ZforDictNext(f) {
 ++f.idx;
 if (f.dict != null && f.idx < f.keys.length)
  return f.dict[f.keys[f.idx]][1];
 return null;
}
function ZforDictNextKey(f) {
 if (f.dict != null && f.idx < f.keys.length)
  return f.dict[f.keys[f.idx]][0];
 return null;
}
"'')
        }).setDependencies([WriteDictJava.dictKeys]))

      codeWriters.add(NEW(%forString,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZforStringNew(p) {
  var f = {};
  f['string'] = p;
  f['idx'] = 0;
  return f;
}
function ZforStringGet(f) {
  if (f.string != null && f.idx < f.string.length)
    return f.string.charAt(f.idx);
  return null;
}
function ZforStringCont(f) {
  return f.string != null && f.idx < f.string.length;
}
function ZforStringNext(f) {
  ++f.idx;
  if (f.string != null && f.idx < f.string.length)
    return f.string.charAt(f.idx);
  return null;
}
"'')
        }))

      codeWriters.add(NEW(%forRange,
        PROC (WriteJava gen, IO.File fd)
          # FOR x IN start TO end [STEP step]
          fd.write(''"
static class ZforRange {
 public long idx;
 public long last;
 public long step;
 public ZforRange(long start, long last, long until, long step) {
  this.idx = start;
  if (until != 0) {
    this.last = last - (step > 0 ? 1 : -1);
  } else {
    this.last = last;
  }
  this.step = step;
 }
 public long get() {
  return idx;
 }
 public boolean cont() {
  return step > 0 ? (idx <= last) : (idx >= last);
 }
 public long next() {
  idx += step;
  return idx;
 }
}
"'')
        }))

      codeWriters.add(NEW(%forEnum,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZforEnumNew(count) {
  var f = {};
  f['count'] = count;
  f['idx'] = 0;
  return f;
}
function ZforEnumGet(f) {
  return f.idx;
}
function ZforEnumCont(f) {
  return f.idx < f.count;
}
function ZforEnumNext(f) {
  ++f.idx;
  return f.idx;
}
"'')
        }))

      codeWriters.add(NEW(%enumFromString,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZenumFromString(pName, str) {
 var i = pName.indexOf(str);
 if (i < 0) return 0;
 return i;
}
"'')
        }))

      codeWriters.add(NEW(%throw,
        PROC (WriteJava gen, IO.File fd)
          string newException = DeclStore.getPName("MEModule__CException",
                                                                       "MNEW")
          string newPosException = DeclStore.getPName("MEModule__CException",
                                                                    "MNEW__1")
          string nilException = DeclStore.getPName("MEModule__CNilAccess",
                                                                "MNEW__p2__2")
          fd.write(''"
static void ZaddError(Exception e, String msg) {
}
static void Zthrow(String msg) {
 // Zthrow "'' .. newException .. ''"(null, msg);
}
static void ZthrowNil(String msg) {
 // Zthrow "'' .. nilException .. ''"(null, msg);
}
static String ZstringEx(String pos, String msg) {
 // return "'' .. newPosException .. ''"(null, pos, msg);
 return "";
}
"'')
        }))

      codeWriters.add(NEW(%bool2string,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zbool2string(n) {
  return n == 0 ? "FALSE" : "TRUE";
}
"'')
        }))

      codeWriters.add(NEW(%float2string,
        PROC (WriteJava gen, IO.File fd)
          # Keep the format consistant with C printf("%g").
          # TODO: make this more efficient
          fd.write(''"
String Zfloat2string(double n) {
 if (n == Double.POSITIVE_INFINITY) return "inf";
 if (n == Double.NEGATIVE_INFINITY) return "-inf";
 if (Double.isNaN(n)) return "nan";
// var se;
// if (n <= -0.0001 && n > -0.001 || n >= 0.0001 && n < 0.001) se = n.toFixed(9);
// else if (n <= -0.001 && n > -0.01 || n >= 0.001 && n < 0.01) se = n.toFixed(8);
// else if (n <= -0.01 && n > -0.1 || n >= 0.01 && n < 0.1) se = n.toFixed(7);
// else if (n <= -0.1 && n > -1.0 || n >= 0.1 && n < 1.0) se = n.toFixed(6);
// else if (n <= -1.0 && n > -10.0 || n >= 1.0 && n < 10.0) se = n.toFixed(5);
// else if (n <= -10.0 && n > -100.0 || n >= 10.0 && n < 100.0) se = n.toFixed(4);
// else if (n <= -100.0 && n > -1000.0 || n >= 100.0 && n < 1000.0) se = n.toFixed(3);
// else if (n <= -1000.0 && n > -10000.0 || n >= 1000.0 && n < 10000.0) se = n.toFixed(2);
// else if (n <= -10000.0 && n > -100000.0 || n >= 10000.0 && n < 100000.0) se = n.toFixed(1);
// else {
//  se = n.toExponential(5);
//  if (se.indexOf('+', se.length - 2) >= 0 || se.indexOf('-', se.length - 2) >= 0) se = se.substring(0, se.length - 1) + '0' + se.substring(se.length - 1);
//  var ei = se.toLowerCase().indexOf('e');
//  var si = ei;
//  while (si > 2 && se[si - 1] == '0') --si;
//  if (se[si - 1] == '.') --si;
//  if (si < ei) se = se.substring(0, si) + se.substring(ei);
// }
// var sn = n + '';
// if (sn.length < se.length) return sn;
// if (n < 10000) {
//  while (se.substring(se.length - 1) == '0') {
//   se = se.substring(0, se.length - 1);
//  }
// }
 return Double.toString(n);
}
"'')
        }))

      codeWriters.add(NEW(%floatFormat,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZfloatFormat(n, fmt) {
 if (n == Infinity) return 'inf';
 if (n == -Infinity) return '-inf';
 if (isNaN(n)) return 'nan';
 var i = 0;
 var width = -1;
 var prec = 6;
 if (Zisdigit(fmt.charAt(0))) {
  width = parseInt(fmt, 10);
  while (Zisdigit(fmt.charAt(i))) ++i;
 }
 if (fmt[i] == '.') {
  ++i;
  prec = parseInt(fmt.substring(i), 10);
  while (Zisdigit(fmt.charAt(i))) ++i;
 }
 var type = fmt[i];
 if (type == 'g' || type == 'G') {
  var exp = Math.log(n) / 2.302585;
  if (n < 0.00001 || exp > prec) {
   type = type == 'g' ? 'e' : 'E';
   prec--;
  } else {
   type = type == 'g' ? 'f' : 'F';
   prec -= exp;
   if (prec <= 0) prec = 1;
  }
 }
 var s;
 if (type == 'f' || type == 'F') {
  s = n.toFixed(prec);
  if (fmt[i] == 'g' || fmt[i] == 'G') {
   while (s.substring(s.length - 1) == '0') {
    s = s.substring(0, s.length - 1);
   }
  }
 } else if (type == 'e' || type == 'E') {
  s = n.toExponential(prec);
  if (fmt[i] == 'E') s = s.toUpperCase();
  if (s.indexOf('+', s.length - 2) >= 0) s = s.substring(0, s.length - 1) + '0' + s.substring(s.length - 1);
  if (fmt[i] == 'g' || fmt[i] == 'G') {
   var ei = s.toLowerCase().indexOf('e');
   var si = ei;
   while (si > 2 && s[si - 1] == '0') --si;
   if (si < ei) s = s.substring(0, si) + s.substring(ei);
  }
 } else {
  return 'INVALID format: ' + fmt;
 }
 while (s.length < width) {
  s = ' ' + s;
 }
 return s;
}
"'')
        }))

      codeWriters.add(NEW(%status2string,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zstatus2string(n) {
  return n == 0 ? "FAIL" : "OK";
}
"'')
        }))

      codeWriters.add(NEW(%intFormat,
        PROC (WriteJava gen, IO.File fd)
          string throwBadValue = DeclStore.getPName("MEModule",
                                                             "FthrowBadValue")
          fd.write(''"
static String ZintFormat(String fmt, long nr) {
 if (fmt == null) ZthrowNil("ToString(): format is NIL");
 int c = fmt.charAt(fmt.length() - 1);
 if (c != 'd' && c != 'x') {
  "'' .. throwBadValue .. ''"("ToString(): format must end in 'd' or 'x'");
 }
 boolean padzero = fmt.charAt(0) == '0';
 boolean hasdot = false;
 if (fmt.charAt(0) == '.') {
  padzero = true;
  hasdot = true;
  fmt = fmt.substring(1);
 }
 long absNr = nr < 0 ? -nr : nr;
 int pad = Integer.parseInt(fmt);
 if (nr < 0 && !hasdot) --pad;
 String res = c == 'x' ? Long.toHexString(absNr) : Long.toString(absNr);
 if (pad > 0) {
  while (res.length() < pad) {
   res = (padzero ? "0" : ' ') + res;
  }
 }
 if (nr < 0) return "-" + res;
 return res;
}
"'')
        }).setDependencies([["MEModule", "FthrowBadValue"]])
          .setDependencies([%throw]))

      codeWriters.add(NEW(%stringFormat,
        PROC (WriteJava gen, IO.File fd)
          string throwBadValue = DeclStore.getPName("MEModule",
                                                             "FthrowBadValue")
          fd.write(''"
function ZStringFormat(str, fmt) {
 if (str == null || fmt == null) return str;

 var minlen = -1;
 var maxType = 0;
 var ellipses = 0;
 var elliptext;
 var maxlen = -1;
 var startIdx = 0;
 var fill = 0;
 var twoparts = 0;
 var len;
 var pp;
 var res;

 var fmtlen = fmt.length;
 if (fmt[fmtlen - 1] != 's') {
  "'' .. throwBadValue .. ''"("ToString(): format must end in 's'");
 }
 var charlen = str.length;
 var endIdx = charlen;
 var idx = 0;
 if (fmt[idx] == '-') ++idx;
 if (Zisdigit(fmt.charAt(idx))) {
  minlen = parseInt(fmt.substr(idx));
  while (Zisdigit(fmt.charAt(idx))) {
   ++idx;
  }
 }
 if (fmt[idx] == '.') {
  var ellipidx = idx;
  ++idx;
  if (fmt[idx] == '.') { ellipses += 2; ++idx; }
  if (fmt[idx] == '.') { ++ellipses; ++idx; }
  if (fmt[idx] == '-' || fmt[idx] == '+') { maxType = fmt[idx]; ++idx}
  if (ellipses) elliptext = fmt.substr(ellipidx, ellipidx + ellipses);
  if (Zisdigit(fmt.charAt(idx))) {
   maxlen = parseInt(fmt.substr(idx));
   if (charlen > maxlen) {
    if (maxType == '-') startIdx = charlen - maxlen;
    else if (maxType == '+' || ellipses == 0) endIdx = maxlen;
    else {
     twoparts = 1;
     endIdx = maxlen / 2;
     startIdx = charlen - maxlen / 2;
    }
    if (minlen >= 0) fill = minlen - maxlen;
   }
  }
 } else {
  fill = minlen - charlen;
 }
 fill = fill < 0 ? 0 : fill;
 var res = [];
 if (ellipses && maxType == '-') {
  res.push(elliptext);
  startIdx += ellipses;
 }

 if (fmt[0] != '-') {
  while (--fill >= 0) res.push(' ');
 }
 if (twoparts) {
  if (ellipses && endIdx > 0) --endIdx;
  if (ellipses == 3 && endIdx > 0) --endIdx;
  res.push(str.substr(0, endIdx));
  if (ellipses && maxType == 0) {
   res.push(elliptext);
   ++startIdx;
  }
  res.push(str.substr(startIdx));
 } else {
  if (ellipses && maxType == '+') endIdx -= ellipses;
  res.push(str.substring(startIdx, endIdx));
 }
 if (ellipses && maxType == '+') res.push(elliptext);
 if (fill > 0) {
  while (--fill >= 0) res.push(' ');
 }
 return res.join('');
}
"'')
        }).setDependencies([%isdigit])
          .setDependencies([["MEModule", "FthrowBadValue"]]))

      codeWriters.add(NEW(%stringToArray,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZStringToArray(str) {
 var l;
 if (str == '') {
  l = [];
 } else {
  if (!str) return null;
  l = str.split('');
  for (var i = 0; i < str.length; ++i) l[i] = str.charAt(i);
 }
 return {a: l, itemType: nat32__T};
}
"'')
        }))

      codeWriters.add(NEW(Declaration.convertFromDyn,
        PROC (WriteJava gen, IO.File fd)
          string throwType = DeclStore.getPName("MEModule", "FthrowWrongTypeEx")
          fd.write(''"
function ZdynToVal(type, val) {
 if (!val || !val[0] || val[1] == null) return null;
 if (val[0] != type
   && !(val[0] == byte__T && (type == nat16__T || type == nat32__T || type == nat__T || type == int16__T || type == int32__T || type == int__T))
   && !(val[0] == nat16__T && (type == nat32__T || type == nat__T || type == int32__T || type == int__T))
   && !(val[0] == nat32__T && (type == nat__T || type == int__T))
   && !(val[0] == int8__T && (type == int16__T || type == int32__T || type == int__T))
   && !(val[0] == int16__T && (type == int32__T || type == int__T))
   && !(val[0] == int32__T && type == int__T)) "'' .. throwType .. ''"(null, type, val[0]);
 return val[1];
}
"'')
        }).setDependencies([["MEModule", "FthrowWrongTypeEx"]]))

      codeWriters.add(NEW(%dynToString,
        PROC (WriteJava gen, IO.File fd)
          # TODO: check type
          fd.write(''"
function ZdynToString(val) {
 if (!val || !val[0] || val[1] == null) return "NIL";
 ++tosNr;
 return ZitemToString(val[1], val[0], 0);
}
"'')
        }))

      codeWriters.add(NEW(%dynType,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZdynType(val) {
 if (!val || !val[0] || val[1] == null) return null;
 if (val[0] == iobj__T) return val[1].__t;
 return val[0];
}
"'')
        }))

      codeWriters.add(NEW(Declaration.dynSize,
        PROC (WriteJava gen, IO.File fd)
          # This code uses TYPE_NUMBERS, keep in sync!
          # TODO: make all number types return 8?
          fd.write(''"
function ZdynSize(arg) {
 if (!arg || !arg[0] || arg[1] == null) {
  return 0;
 }
 switch (arg[0][0]) {
  case 0:
  case 10: return 8;
  case 1:
  case 11: return 1;
  case 2:
  case 12: return 2;
  case 3:
  case 13: return 4;
  case 21:
  case 22: return 1;
  case 23: return 4;
  case 25: return 8;
  case 80:
  case 82:
  case 83: return 8;
  case 81: return 4;

  case 101: return 16;

  case 200:
  case 201: return arg[1].length;"'')
        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
  case 300: return arg[1].a.length;"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
  case 301: return arg[1].a.length;"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
  case 302: return arg[1].size;"'')
        }
        fd.write(''"
  case 310:
  case 311: return arg[1][0].length;

  case 360: return ZdynSize(arg[1]);

  case 390:
  case 391: if (arg[1].Size) return arg[1].Size();
            Zthrow('object does not support Size()');
 }
 return 0;
}
"'')
        }).setDependencies([Declaration.throwDyn]))

      codeWriters.add(NEW(%stringSliceWrap,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
static String ZSliceWrap(String str, long start, long end) {
 if (str == null) return null;
 long l = str.length();
 long is = start < 0 ? l + start : start;
 long ie = end < 0 ? l + end : end;
 if (is < 0) is = 0;
 if (is > l) is = l;
 if (ie < is - 1) ie = is - 1;
 if (ie >= l) ie = l - 1;
 return str.substring((int)is, (int)ie + 1);
}
"'')
        }))

      codeWriters.add(NEW(%getSize,
        PROC (WriteJava gen, IO.File fd)
          # Permissive Size(): returns zero for null
          fd.write(''"
static int ZgetSize(String s) {
 return s != null ? s.length() : 0;
}
"'')
        }))

      codeWriters.add(NEW(%getBSize,
        PROC (WriteJava gen, IO.File fd)
          # Permissive Size(): returns zero for null
          fd.write(''"
static int ZgetBSize(char[] s) {
 return s != null ? s.length : 0;
}
"'')
        }))

      codeWriters.add(NEW(%varStringSize,
        PROC (WriteJava gen, IO.File fd)
          # Permissive Size(): returns zero for null
          fd.write(''"
function ZvarStringSize(s) {
 return s ? s[0].length : 0;
}
"'')
        }))

      codeWriters.add(NEW(%varStringAdd,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZvarStringAdd(vs, s) {
 if (vs == null) ZthrowNil('using add() on NIL varString');
 vs[0] = vs[0] + s;
 return vs;
}
"'')
        }))

      codeWriters.add(NEW(%stringHash,
        PROC (WriteJava gen, IO.File fd)
          # TODO: implement
          fd.write(''"
static long ZstringHash(one) {
 return 1234;
}
"'')
        }))

      codeWriters.add(NEW(%null2nil,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
static String Znull2nil(String s) {
 return s == null ? "NIL" : s;
}
"'')
        }))

      codeWriters.add(NEW(%varString2string,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZvarStringToString(s) {
 return s ? s[0] : null;
}
"'')
        }))

      codeWriters.add(NEW(%string2vs,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zstring2vs(s) {
 return s == null ? null : [s];
}
"'')
        }))

      codeWriters.add(NEW(%string2bs,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
static char[] Zstring2bs(String str) {
 if (str == null) return null;
 // TODO: handle non-ASCII characters.
 return str.toCharArray();
}
"'')
        }))

      codeWriters.add(NEW(%bs2string,
        PROC (WriteJava gen, IO.File fd)
          # TODO: this is slow
          fd.write(''"
function Zbs2string(str) {
 if (str == null) return null;
 res = [];
 for (var i = 0; i < str.length; ++i) {
  var c = str.charAt(i);
  if (c <= 0x7f) {
   res.push(String.valueOf(c));
  } else if ((c & 0xe0) == 0xc0) {
   res.push(String.valueOf(((c & 0x1f) << 6) + (str.charAt(i + 1) & 0x3f)));
   ++i;
  } else if ((c & 0xf0) == 0xe0) {
   res.push(String.valueOf(((c & 0x0f) << 12) + ((str.charAt(i + 1) & 0x3f) << 6) + (str.charAt(i + 2) & 0x3f)));
   i += 2;
  } else if ((c & 0xf8) == 0xf0) {
   res.push(String.valueOf(((c & 0x07) << 18) + ((str.charAt(i + 1) & 0x3f) << 12) + ((str.charAt(i + 2) & 0x3f) << 6) + (str.charAt(i + 3) & 0x3f)));
   i += 3;
  } else {
   res.push('?');
  }
 }
 return res.join('');
}
"'')
        }))

      codeWriters.add(NEW(%getByteFromBS,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZgetByteFromBS(str, idx) {
 if (!str || idx >= str.length) return 0;
 return str.charAt(idx);
}
"'')
        }))

      codeWriters.add(NEW(%getCharFromBS,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZgetCharFromBS(str, idx, retchar) {
 if (str == null) return 0;
 if (idx < 0 || idx >= str.length) Zthrow('badvalue');
 var c = str.charAt(idx);
 if (c <= 0x7f) return retchar ? c : 1;
 if ((c & 0xc0) == 0x80) return -1;
 if ((c & 0xe0) == 0xc0) {
  return retchar ? (((c & 0x1f) << 6) + (str.charAt(idx + 1) & 0x3f)) : 2;
 }
 if ((c & 0xf0) == 0xe0) {
  return retchar ? (((c & 0x0f) << 12) + ((str.charAt(idx + 1) & 0x3f) << 6) + (str.charAt(idx + 2) & 0x3f)) : 3;
 }
 if ((c & 0xf8) == 0xf0) {
  return retchar ? (((c & 0x07) << 18) + ((str.charAt(idx + 1) & 0x3f) << 12) + ((str.charAt(idx + 2) & 0x3f) << 6) + (str.charAt(idx + 3) & 0x3f)) : 4;
 }
 return -1;
}
"'')
        }))

      codeWriters.add(NEW(%stringCompare,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZstringCompare(one, two, dotnil) {
 if (one == null) {
  if (two == null) return 0;
  if (dotnil) return -1;
  ZthrowNil("using Compare on NIL string");
 }
 if (two == null) ZthrowNil("Compare(): NIL argument");
 if (one == two) return 0;
 return one > two ? 1 : -1;
}
"'')
        }))

      codeWriters.add(NEW(%tolower,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Ztolower(str) {
 if (str == null) return null;
 return str.toLowerCase();
}
"'')
        }))

      codeWriters.add(NEW(%stringToFloat,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZstringToFloat(str, f) {
 if (str == null) {
  f(1, 0);
  return 0;
 }
 var r = parseFloat(str);
 var len = 0;
 while (str[len] == ' ') ++len;
 if (str[len] == '-') ++len;
 while (Zisdigit(str.charAt(len))) ++len;
 if (str[len] == '.') ++len;
 while (Zisdigit(str.charAt(len))) ++len;
 if (str[len] == 'e' || str[len] == 'E') {
  ++len;
  if (str[len] == '-') ++len;
  while (Zisdigit(str.charAt(len))) ++len;
 }
 f(1, len);
 return r;
}
"'')
        }).setDependencies([%isdigit]))

      codeWriters.add(NEW(%tolowerA,
        PROC (WriteJava gen, IO.File fd)
          # Unfortunately the Ascii version is slower.
          fd.write(''"
function ZtolowerA(str) {
 if (str == null) return null;
 if (/^[\x00-\x7F]*$/.test(str)) return str.toLowerCase();
 var chars = str.split('');
 var res = [];
 for (var i = 0; i < chars.length; ++i) {
  var c = chars[i];
  if (c.charAt(0) >= 128) res.push(c);
  else res.push(c.toLowerCase());
 }
 return res.join('');
}
"'')
        }))

      codeWriters.add(NEW(%toupper,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Ztoupper(str) {
 if (str == null) return null;
 return str.toUpperCase();
}
"'')
        }))

      codeWriters.add(NEW(%toupperA,
        PROC (WriteJava gen, IO.File fd)
          # Unfortunately the Ascii version is slower.
          fd.write(''"
function ZtoupperA(str) {
 if (str == null) return null;
 if (/^[\x00-\x7F]*$/.test(str)) return str.toUpperCase();
 var chars = str.split('');
 var res = [];
 for (var i = 0; i < chars.length; ++i) {
  var c = chars[i];
  if (c.charAt(0) >= 128) res.push(c);
  else res.push(c.toUpperCase());
 }
 return res.join('');
}
"'')
        }))

      codeWriters.add(NEW(%stringEqual,
        PROC (WriteJava gen, IO.File fd)
          # TODO: implement dotnil
          fd.write(''"
function ZstringEqual(one, two, dotnil) {
 if (one == null && two == null) return 1;
 if (one == null || two == null) return 0;
 return one == two;
}
"'')
        }))

      codeWriters.add(NEW(%bstringFind,
        PROC (WriteJava gen, IO.File fd)
          # TODO: make this more efficient
          fd.write(''"
function ZbstringFind(last, str, arg, dotnil) {
 if (str == null) {
  if (dotnil) return -1;
  ZthrowNil('NIL string');
 }
 if (arg == null) ZthrowNil('NIL argument');
 var barg = Zstring2bs(arg);
 return last ? str.lastIndexOf(barg) : str.indexOf(barg);
}
"'')
        }))

      codeWriters.add(NEW(%split,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zsplit(str, arg, dn) {
 if (str == null) {
  if (dn) return null;
  ZthrowNil("using split() on NIL string");
 }
 if (arg == null) ZthrowNil('split(): NIL argument');
 return {a: str.split(arg), itemType: string__T};
}
"'')
        }))

      codeWriters.add(NEW(%parseInt,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
static long ZparseInt(String val, int r, int t, long def) {
 if (val == null) {
  if (t >= 2) return def;
  ZthrowNil("NIL string");
 }
 int c = val.charAt(0);
 if ((r == 2 && c != '0' && c != '1') || (r == 16 && c == '-')) {
  if ((t & 1) != 0) Zthrow("badvalue");
  return def;
 }
 long res = Long.parseLong(val, r);
 // TODO: handle error
 // if (isNaN(res)) {
 //  if (t & 1) Zthrow("badvalue");
 //  return def;
 // }
 return res;
}
"'')
        }))

      codeWriters.add(NEW(%parseQuotedInt,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZparseQuotedInt(val, r, t, def) {
 if (val) val = val.replace(/['_]/g, '');
 return ZparseInt(val, r, t, def);
}
"'')
        }))


      codeWriters.add(NEW(%floatCompare,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZfloatCompare(l, r) {
 if (l == r) return 0;
 if (l < r) return -1;
 return 1;
}
"'')
        }))

      codeWriters.add(NEW(%typeCompare,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZtypeCompare(l, r) {
 if (l == r) return 0;
 if (l[0] > r[0]) return 1;
 return -1;
}
"'')
        }))

      codeWriters.add(NEW(%noAllocNil,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZnoAllocNil(o) {
 if (o && o.Finish) {
  try {
   o.Finish(3);
   } catch (e) {
  }
 }
 return null;
}
"'')
        }))

      codeWriters.add(NEW(%clone,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zclone(o) {
 if (!o) return null;
 var r = o.constructor();
 for (var attr in o) {
  r[attr] = o[attr];
 }
 return r;
}
"'')
        }))

      codeWriters.add(NEW(%isdigit,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zisdigit(val) {
 return val >= 48 && val <= 57;
}
"'')
        }))

      codeWriters.add(NEW(%isXdigit,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZisXdigit(val) {
 return val >= 48 && val <= 57 || val >= 97 && val <= 102 || val >= 65 && val <= 70;
}
"'')
        }))

      codeWriters.add(NEW(%isAlpha,
        PROC (WriteJava gen, IO.File fd)
          # TODO: Unicode characters
          fd.write(''"
function ZisAlpha(val) {
 return val >= 97 && val <= 122 || val >= 65 && val <= 90;
}
"'')
        }))

      codeWriters.add(NEW(%isLower,
        PROC (WriteJava gen, IO.File fd)
          # TODO: Unicode characters
          fd.write(''"
function ZisLower(val) {
 return val >= 97 && val <= 122;
}
"'')
        }))

      codeWriters.add(NEW(%isUpper,
        PROC (WriteJava gen, IO.File fd)
          # TODO: Unicode characters
          fd.write(''"
function ZisUpper(val) {
 return val >= 65 && val <= 90;
}
"'')
        }))

      codeWriters.add(NEW(WriteCommon.fixSign,
        PROC (WriteJava gen, IO.File fd)
          # Used for converting intN to int.  "mask" has all bits set, except
          # the lower ones that contain a positive value.  For int5 it is ~15.
          # When the topmost valid bit in "n" is set the value is negative and
          # needs to have all "mask" bits set.
          # TODO: support for 32 and 64 bit separately for efficiency
          fd.write(''"
function ZFixSign(n, mask) {
 if (n & mask)
  return n | mask;
 return n;
}
"'')
        }))

      codeWriters.add(NEW(%isInfinite,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZisInfinite(val) {
 return val == Number.POSITIVE_INFINITY || val == Number.NEGATIVE_INFINITY;
}
"'')
        }))

      codeWriters.add(NEW(%trunc,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Ztrunc(val) {
 return val > 0 ? Math.floor(val) : Math.ceil(val);
}
"'')
        }))

      codeWriters.add(NEW(%round,
        PROC (WriteJava gen, IO.File fd)
          # In C round(-1.5) returns -2, Math.round returns -1.  Fix that
          # here.
          fd.write(''"
function Zround(val) {
 return val > 0 ? Math.round(val) : -Math.round(-val);
}
"'')
        }))

      codeWriters.add(NEW(%float2int,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zfloat2int(val) {
 if (val == Number.POSITIVE_INFINITY) return 9223372036854775807;
 if (val == Number.NEGATIVE_INFINITY) return -9223372036854775808;
 if (isNaN(val)) return 0;
 return val > 0 ? Math.round(val) : -Math.round(-val);
}
"'')
        }))

      codeWriters.add(NEW(%sinh,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zsinh(val) {
 return (Math.exp(val) - Math.exp(-val)) / 2;
}
"'')
        }))

      codeWriters.add(NEW(%cosh,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Zcosh(val) {
 return (Math.exp(val) + Math.exp(-val)) / 2;
}
"'')
        }))

      codeWriters.add(NEW(%tanh,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function Ztanh(val) {
 if (val == Infinity) return 1;
 if (val == -Infinity) return -1;
 return (Math.exp(val) - Math.exp(-val)) / (Math.exp(val) + Math.exp(-val));
}
"'')
        }))

      codeWriters.add(NEW(%startsWith,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZstartsWith(big, small, dn) {
  if (small == null) ZthrowNil("startsWith(): NIL argument");
  if (big == null) {
   if (dn) return 0;
   ZthrowNil("using startsWith() on NIL string");
  }
  if (big.length < small.length) return 0;
  return big.substring(0, small.length) == small;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.exit,
        PROC (WriteJava gen, IO.File fd)
          string zcPosName = DeclStore.getPName("MZModule", "CPos")
          IF gen.isDeclUsed(Declaration.try)
            # When inside try/catch there may be a finally, so jump there.
            string throwExit = DeclStore.getPName("MEModule", "FthrowExit")
            fd.write(''"
static void Zexit("'' .. zcPosName .. ''" pos, long val) {
 "'' .. throwExit .. ''"(pos, val);
}
"'')
          ELSE
            # Simple: call exit().
            fd.write(''"
static void Zexit("'' .. zcPosName .. ''" pos, long val) {
 beforeExit();
 System.exit((int)val);
}
"'')
          }
        }).addCondDepends(Declaration.try, ["MEModule", "FthrowExit"]))
      codeWriters.add(NEW(Declaration.itemEqual,
        PROC (WriteJava gen, IO.File fd)
          # TODO: handle more types.
          # TODO: use Equal() on an object
          fd.write(''"
function ZitemEqual(typea, vala, typeb, valb) {"'')
          IF gen.isDeclUsed(Type.aDyn)
            fd.write(''"
 if (typea == dyn__T) {
  typea = vala[0];
  vala = vala[1];
 }
 if (typeb == dyn__T) {
  typeb = valb[0];
  valb = valb[1];
 }"'')
          }
          fd.write(''"
 if (typea[0] == typeb[0]) {
  switch (typea[0]) {
   case 0:
   case 1:
   case 2:
   case 3:
   case 10:
   case 11:
   case 12:
   case 13:
   case 22:
   case 80:
   case 81:
   case 82:
   case 83:
   case 200:
   case 201:
    return vala == valb;
   case 21:
    return !vala == !valb;
   case 23:
   case 25:
     return vala == valb && typea == typeb;
   case 24:
   case 101:
     return typea == typeb;"'')

        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
   case 300:
    return ZArrayEqual(vala, valb);"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
   case 301:
    return ZListEqual(vala, valb);"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
   case 302:
    return ZDictEqual(vala, valb);"'')
        }
        fd.write(''"
   case 310:
   case 311:
    ZthrowInternal("Sorry, varString/varByteString compare not implemented yet");
    return 0;

   case 320:
    ZthrowInternal("Sorry, tuple compare not implemented yet");
    return 0;

   case 330:
    ZthrowInternal("Sorry, proc/func compare not implemented yet");
    return 0;"'')

        fd.write(''"
   case 390:
    if (typea != typeb) return 0;
    if (vala.Equal) return vala.Equal(valb);
    if (vala.Compare) return vala.Compare(valb) == 0;
    ZthrowDyn("object does not support Equal() nor Compare()");

   case 391:
    /* TODO */
    ZthrowInternal("iobjec equal not supported yet");
    return aType == bType;
  }
 }
 if ((typea[0] < 20 || (typea[0] >= 80 && typea[0] < 100)) && (typeb[0] < 20 || (typeb[0] >= 80 && typeb[0] < 100))) return vala == valb;
 return false;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.dynEqual,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZdynEqual(a, b) {
 return ZitemEqual(a[0], a[1], b[0], b[1]);
}
function ZdynEqualOne(a, v, type) {
 return ZitemEqual(a[0], a[1], type, v);
}
"'')
        }).setDependencies([Declaration.itemEqual]))

      codeWriters.add(NEW(Declaration.itemCompare,
        PROC (WriteJava gen, IO.File fd)
          # TODO: handle more types.
          # TODO: use Compare() on an object
          fd.write(''"
function ZitemCompare(typea, vala, typeb, valb) {"'')
          IF gen.isDeclUsed(Type.aDyn)
            fd.write(''"
 if (typea == dyn__T) {
  typea = vala[0];
  vala = vala[1];
 }
 if (typeb == dyn__T) {
  typeb = valb[0];
  valb = valb[1];
 }"'')
          }
          fd.write(''"
 if (typea == typeb || ((typea[0] < 20 || (typea[0] >= 80 && typea[0] < 100)) && (typeb[0] < 20 || (typeb[0] >= 80 && typeb[0] < 100)))) {
  return vala == valb ? 0 : vala > valb ? 1 : -1;
 }
 return 1;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.dynEqual,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZdynEqual(a, b) {
 return ZitemEqual(a[0], a[1], b[0], b[1]);
}
function ZdynEqualOne(a, v, type) {
 return ZitemEqual(a[0], a[1], type, v);
}
"'')
        }).setDependencies([Declaration.itemEqual]))

      codeWriters.add(NEW(Declaration.dynCompare,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZdynCompare(a, b) {
 return ZitemCompare(a[0], a[1], b[0], b[1]);
}
function ZdynCompareOne(a, v, type) {
 return ZitemCompare(a[0], a[1], type, v);
}
"'')
        }).setDependencies([Declaration.itemCompare]))

      codeWriters.add(NEW(%endsWith,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
function ZendsWith(big, small, dn) {
  if (small == null) ZthrowNil("endsWith(): NIL argument");
  if (big == null) {
   if (dn) return 0;
   ZthrowNil("using endsWith() on NIL string");
  }
  if (big == null || small == null) return null;
  if (big.length < small.length) return 0;
  return big.substring(big.length - small.length) == small;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.itemToString,
        PROC (WriteJava gen, IO.File fd)
          # This code uses TYPE_NUMBERS, keep in sync!
          fd.write(''"
static int tosNr = 0;
static String ZitemToString(long val, ZType type, boolean useq) {
  switch (type.nr) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
    case 25:
      return Long.toString(val);
    case 23:
      // TODO
      return "enum value";
  }
  return "wrong";
}
static String ZitemToString(double val, ZType type, boolean useq) {
  switch (type.nr) {
    case 80:
    case 81:
    case 82:
    case 83:
      return Double.toString(val);
  }
  return "wrong";
}
static String ZitemToString(boolean val, ZType type, boolean useq) {
  switch (type.nr) {
    case 21: return val ? "TRUE" : "FALSE";
    case 22: return val ? "OK" : "FAIL";
  }
  return "wrong";
}
static String ZitemToString(String val, ZType type, boolean useq) {
  return val == null ? "NIL" : useq ? '"' + val + '"' : val;
}
static String ZitemToString(Object val, ZType type, boolean useq) {
  // TODO
  if (val == null) {
    return "NIL";
  }
  if (val instanceof String) {
    return useq ? '"' + (String)val + '"' : (String)val;
  }
  if (val instanceof Long) {
    return Long.toString((Long)val);
  }
  return "some object";
}
// static <T> String ZitemToString(ZArray<T> val, ZType type, boolean useq) {
//   return val == null ? "NIL" : ZArrayToStringGa(val, 1);
// }
// static <T> String ZitemToString(ZList<T> val, ZType type, boolean useq) {
//  return val == null ? "NIL" : ZListToStringGa(val, 1);
//}
static <Tk, Ti> String ZitemToString(ZDict<Tk, Ti> val, ZType type, boolean useq) {
  return val == null ? "NIL" : ZDictToStringGa(val, true, true);
}
// TODO
// static <T> String ZitemToString(ZDict<T> val, ZType type, boolean useq) {
//   switch (type.nr) {
//     case 310:
//     case 311: return val == null ? 'NIL' : useq ? '"' + val[0] + '"' : val[0];
//     case 320: if (val == null) return 'NIL';
//               if (type[2]) return type[2](val);
//               return '-tuple-';
//     case 330: return val == null ? 'NIL' : '-proc/func-';
//     case 360: return val == null ? 'NIL' : ZitemToString(val[1], val[0], useq);
//     case 390:
//     case 391: return ZobjectToString(val); 
//   }
//   return "unknown";
// }
"'')
        }).setDependencies([%object2string, %float2string]))

      codeWriters.add(NEW(%object2string,
        PROC (WriteJava gen, IO.File fd)
          fd.write(''"
static String ZobjectToString(Object obj) {
 if (obj == null) return "NIL";
// TODO
//  if (obj.ToString) return obj.ToString();
//  var res = ['{'];
//  for (var i = 0; i < obj.__to.length; ++i) {
//   if (i > 0) res.push(', ');
//   var name = obj.__to[i][0];
//   var pName = obj.__to[i][1];
//   var type = obj.__to[i][2];
//   res.push(name);
//   res.push(': ');
//   if (!type) res.push('no type for ' + name);
//   else res.push(ZitemToString(obj[pName], type, true));
//  }
//  res.push('}');
 return "object";
}
"'')
        }).setDependencies([Declaration.itemToString]))

      codeWriters.add(NEW(Declaration.typeToString,
        PROC (WriteJava gen, IO.File fd)
          # This code uses TYPE_NUMBERS, keep in sync!
          # TODO: class name, container item/key and typedef items.
          fd.write(''"
function Ztype2string(type) {
 if (!type) return '[unknown]';
 switch (type[0]) {
  case 0: return 'int';
  case 1: return 'int8';
  case 2: return 'int16';
  case 3: return 'int32';
  case 10: return 'nat';
  case 11: return 'byte';
  case 12: return 'nat16';
  case 13: return 'nat32';

  case 21: return 'bool';
  case 22: return 'status';
  case 23: return 'enum ' + type[1];
  case 24: return 'module ' + type[1];
  case 25: return 'bits ' + type[1];

  case 80: return 'float';
  case 81: return 'float32';
  case 82: return 'float80';
  case 83: return 'float128';

  case 101: return 'type';

  case 200: return 'string';
  case 201: return 'byteString';

  case 300: return type[1];
  case 301: return type[1];
  case 302: return type[1];

  case 310: return 'varString';
  case 311: return 'varByteString';

  case 320: return type[1];

  case 330: return 'proc/func';

  case 360: return 'dyn';

  case 390:
  case 391: return 'object of ' + type[1];
 }
 return '[unknown]';
}
  "'')
        }))

      codeWriters.add(NEW(Declaration.defer,
        PROC (WriteJava gen, IO.File fd)
          # Catch exceptions thrown by the callback, report them and continue.
          string ewrite = DeclStore.getPName("MEModule", "FwriteToStderr")
          fd.write(''"
var deferList = [];
function ZdeferCall(len) {
 while (deferList.length > len) {
  var item = deferList[deferList.length - 1];
  deferList.length--;
  try {
   item();
  } catch (Exception e) {
   "'' .. ewrite .. ''"(e);
  }
 }
}"'')
        }).setDependencies([["MEModule", "FwriteToStderr"]]))

      WriteArrayJava.initCodeWriters(codeWriters)
      WriteListJava.initCodeWriters(codeWriters)
      WriteDictJava.initCodeWriters(codeWriters)
    }  # end of initCodeWriters()

    # Write function bodies to |fd|.
    PROC writeBodies(WriteJava gen, IO.File fd)
    }

    FUNC genExpr(Zui.Expression expr, SContext ctx) Type
      RETURN Generate.genExpr(expr, ctx)
    }
    FUNC genExpr(Zui.Expression expr, SContext ctx, Type destType) Type
      RETURN Generate.genExpr(expr, ctx, destType)
    }

    array<bool> usedTuple = NEW(20)

    PROC writeTupleDecl(int n, Output out)
      IF usedTuple[n]
        RETURN
      }
      usedTuple[n] = TRUE

      out.write("static class Tuple\(n)<")
      FOR i IN 1 TO n
        IF i > 1
          out.write(", ")
        }
        out.write("T\(i)")
      }
      out.write("> {\n")
      FOR i IN 1 TO n
        out.write(" public T\(i) a\(i);\n")
      }
      out.write(" public Tuple\(n)(")
      FOR i IN 1 TO n
        IF i > 1
          out.write(", ")
        }
        out.write("T\(i) a\(i)")
      }
      out.write(") {\n")
      FOR i IN 1 TO n
        out.write("  this.a\(i) = a\(i);\n")
      }
      out.write(" }\n}\n")
    }

    # Write common arguments for ToString(): "type, useq"
    PROC containerToStringArgument(Type type, Zui.Position pos,
                                                 bool useQuotes, SContext ctx)
      int undef
      int typeNr = WriteJava.getArgumentType(type, pos, &undef, ctx)
      ctx.out.write(", ")
      ctx.out.write(typeNr)
      IF useQuotes
        ctx.out.write(", 1")
      ELSE
        ctx.out.write(", 0")
      }
    }

    FUNC getTypeName(Type type, SContext ctx) string
      IF type == NIL
        # Assume error is produced elsewhere.
        RETURN "unknown"
      }
      SWITCH type.getTtype()
        # Value types
        CASE Type.Enum.int
        CASE Type.Enum.natval
        CASE Type.Enum.intval
          RETURN "int__T"
        CASE Type.Enum.int8
          RETURN "int8__T"
        CASE Type.Enum.int16
          RETURN "int16__T"
        CASE Type.Enum.int32
          RETURN "int32__T"
        CASE Type.Enum.nat
          RETURN "nat__T"
        CASE Type.Enum.byte
          RETURN "byte__T"
        CASE Type.Enum.nat16
          RETURN "nat16__T"
        CASE Type.Enum.nat32
          RETURN "nat32__T"
        CASE Type.Enum.bool
          RETURN "bool__T"
        CASE Type.Enum.status
          RETURN "status__T"
        CASE Type.Enum.enumValue
          RETURN type.<EnumValueType>.enumType.pName .. "__T"
        CASE Type.Enum.bitsValue
          RETURN type.<BitsValueType>.bitsType.pName .. "__T"

        CASE Type.Enum.float
        CASE Type.Enum.floatval
          RETURN "float__T"
        CASE Type.Enum.float32
          RETURN "float32__T"
        CASE Type.Enum.float80
          RETURN "float80__T"
        CASE Type.Enum.float128
          RETURN "float128__T"

        # Reference types
        CASE Type.Enum.string
        CASE Type.Enum.stringval
          RETURN "string__T"
        CASE Type.Enum.byteString
          RETURN "byteString__T"
        CASE Type.Enum.varString
          RETURN "varString__T"
        CASE Type.Enum.varByteString
          RETURN "varByteString__T"
        CASE Type.Enum.tuple
          RETURN type.getEffType().pName .. "__T"
        CASE Type.Enum.iobject
          RETURN "iobj__T"
        CASE Type.Enum.object
  # TODO: not needed?
  #        string name = type.getClassType(ctx).name
  #        IF name == "thread"
  #          RETURN "&thread__T"
  #        }
          RETURN type.getClassType(ctx).pName .. "__T"

  #        CASE Type.Enum.iobject
  #          RETURN "TODO"
        CASE Type.Enum.array
        CASE Type.Enum.list
        CASE Type.Enum.dict
          Declaration usedType = type.getEffType().<ContainerType>.typeUsed(ctx)
          IF ctx.gen.isDeclUsed(usedType)
            RETURN usedType.pName .. "__T"
          }
          # Specific type is not used, no Type() call, only used in
          # ZitemToString().
          SWITCH type.getTtype()
            CASE Type.Enum.array
              RETURN "array__T"
            CASE Type.Enum.list
              RETURN "list__T"
            CASE Type.Enum.dict
              RETURN "dict__T"
          }

  #        CASE Type.Enum.procRef
  #        CASE Type.Enum.funcRef
  #          RETURN "TODO"
        CASE Type.Enum.dyn
          RETURN "dyn__T"
        CASE Type.Enum.type
          RETURN "type__T"
        CASE Type.Enum.callback
        CASE Type.Enum.procRef
        CASE Type.Enum.funcRef
          RETURN "cb__T"

        # TODO: why are these needed?
        CASE Type.Enum.ctype
          RETURN "c__T"
        CASE Type.Enum.jstype
          RETURN "js__T"
        CASE Type.Enum.javatype
          RETURN "java__T"

        DEFAULT
          IF ctx.out.writing
            Report.internal(type.typeName() .. " (\(type.getTtype())) not implemented yet for Java")
          }
      }
      RETURN "unknown"
    }

  }
}
