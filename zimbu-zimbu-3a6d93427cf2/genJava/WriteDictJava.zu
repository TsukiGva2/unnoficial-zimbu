#
# The Zimbu compiler written in Zimbu
#
# Stuff for Dict
#
# Copyright 2009-2012 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO ../parser/zui.proto

IMPORT ../CodeWriter.zu
IMPORT ../ContainerType.zu
IMPORT ../Declaration.zu
IMPORT ../DeclStore.zu
IMPORT ../DictStuff.zu
IMPORT ../ExprArg.zu
IMPORT ../Generate.zu
IMPORT ../ListStuff.zu
IMPORT ../Output.zu
IMPORT ../Report.zu
IMPORT ../SContext.zu
IMPORT ../Type.zu
IMPORT ../WriteCommon.zu
IMPORT WriteJava.zu

MODULE WriteDictJava @public @items=public       # TODO: restrict visibility

  # [key1: value1, key2: value2] ->
  #    ZDictAdd(false, ZDictAdd(false, ZnewDict(), key1, value1), key2, value2)
  # TODO: check for duplicate keys at compile time.
  # Return type of dict in |type|.
  PROC generateNewDict(Zui.Expression expr,
                             SContext ctx, ContainerType type, Type destType)
    WriteCommon.getDictTypes(expr, ctx, type, destType)

    IF expr.sizeDictItem() == 0
      # empty dict: [:]
      writeDictAlloc(type, NIL, NIL, expr.getOrderedDict(), expr.getPos(), ctx)
    ELSE
      IF type.keyType == NIL || type.itemType == NIL
        RETURN
      }

      # Write an add function head for each item.
      FOR item IN expr.getDictItemList() ?: []
        ctx.out.write("ZDictAdd(false, ")
      }

      # Create the dict.
      writeDictAlloc(type, NIL, NIL, expr.getOrderedDict(), expr.getPos(), ctx)

      # Write the end of the add function for each item.
      FOR item IN expr.getDictItemList() ?: []
        ctx.out.write(", ")
        # write the key argument
        genKeyArg(type, item.getKey(), ctx)
        ctx.out.write(", ")
        # write the value argument
        Generate.genExprDoConv(item.getValue(), ctx, type.itemType)
        ctx.out.write(")")
      }
    }
  }

  FUNC generateSubscript(ContainerType type, Zui.Expression expr, bool lvalue,
                                                 SContext ctx, Type destType
                        ) Type
    Type ret = generateGet(type,
                  expr.getLeft(), expr.getRight(), NIL, lvalue, ctx, destType)
    RETURN ret
  }

  FUNC generateGet(ContainerType type, Zui.Expression dictExpr,
                               Zui.Expression keyExpr, Zui.Expression defExpr,
                                      bool lvalue, SContext ctx, Type destType
                 ) Type
    IF lvalue
      Report.internal("Using wrong way to assign to dict")
    }
    IF defExpr == NIL
      ctx.setDeclUsed(%dictGet)
      ctx.out.write("ZDictGet(")
      Generate.genExpr(dictExpr, ctx)
      ctx.out.write(", ")
      Generate.genExprDoConv(keyExpr, ctx, type.keyType)
      ctx.out.write(")")
    ELSE
      ctx.setDeclUsed(%dictGetDef)
      ctx.out.write("ZDictGetDef(")
      Generate.genExpr(dictExpr, ctx)
      ctx.out.write(", ")
      Generate.genExprDoConv(keyExpr, ctx, type.keyType)
      ctx.out.write(", ")
      Generate.genExprDoConv(defExpr, ctx, type.itemType)
      ctx.out.write(")")
    }
    IF type.itemType != NIL
      RETURN type.itemType
    }
    RETURN destType
  }

  FUNC dictAssign(string varname, string key, SContext ctx) string
    ctx.out.write("ZDictAdd(true, ")
    ctx.out.write(varname)
    ctx.out.write(", ")
    ctx.out.write(key)
    ctx.out.write(", ")
    RETURN ")"
  }

  FUNC generateMethodCall(ContainerType type, Zui.MethodCall call,
                                                 SContext ctx, Type destType
                         ) Type
    Type retType
    Zui.Expression name = call.getName()
    CHECK.true(name.getType() == Zui.ExprType.eMEMBER)
    string methodName = name.getRight().getName()
    Zui.Expression object = name.getLeft()
    list<Zui.Expression> argList = call.getArgumentList()
    bool dotnil = name.hasDotnil() && name.getDotnil()

    IF methodName == "ToString"
      IF Generate.checkArgCount(call, 0, 1, ctx) == OK
        ctx.setDeclUsed(%dictToString)
        ctx.out.write("ZDictToString(")
        # Write the object and arguments for key and item type.
        Generate.generateVarname(object, ctx, type)
        WriteJava.oneToStringArgument(type.keyType, call, TRUE, ctx)
        WriteJava.oneToStringArgument(type.itemType, call, TRUE, ctx)
        # TODO: format argument
        ctx.out.write(")")
        retType = Type.aString
      }
    ELSEIF methodName == "Type"
      ctx.out.write(type.typeUsed(ctx).pName)
      ctx.out.write("__T")
      retType = Type.aType
    ELSEIF methodName == "isOrdered"
      ctx.gen.setDeclUsed(%dictIsOrdered)
      ctx.out.write("ZDictIsOrdered(")
      Generate.genExpr(object, ctx, type)
      ctx.out.write(")")
      retType = Type.aBool
    ELSEIF methodName == "get"
      IF Generate.checkArgCount(call, 1, 2, ctx) == OK
        retType = ctx.gen.dictGet(type, object, argList[0],
                     call.sizeArgument() > 1 ? argList[1] : NIL,
                                                                ctx, destType)
      }
    ELSEIF methodName == "has"
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        ctx.setDeclUsed(%dictHas)
        ctx.out.write("ZDictHas(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        genKeyArg(type, argList[0], ctx)
        ctx.out.write(")")
        retType = Type.aBool
      }
    ELSEIF methodName == "add" || methodName == "set"
      IF Generate.checkArgCount(call, 2, 2, ctx) == OK
        ctx.out.write("ZDictAdd(")
        ctx.out.write(methodName == "add" ? "false, " : "true, ")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        Zui.Expression arg0 = argList[0]
        Zui.Expression arg1 = argList[1]
        genKeyArg(type, arg0, ctx)
        genValueArg(type, arg1, ctx)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "remove"
                       || (methodName == "clear" && call.sizeArgument() > 0)
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        ctx.setDeclUsed(%dictRemove)
        Zui.Expression arg = argList[0]
        ctx.out.write("ZDictRemove(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        genKeyArg(type, arg, ctx)
        IF methodName == "clear"
          ctx.out.write(", 0)")  # no exception
          retType = DictStuff.newDict(type)
        ELSE
          ctx.out.write(", 1)")  # exception when key not found
          retType = type.itemType
        }
      }
    ELSEIF methodName == "clear"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictClear)
        ctx.out.write("ZDictClear(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "keys"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictKeys)
        ctx.out.write("ZDictKeys(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(dotnil ? ", true)" : ", false)")
        retType = ListStuff.newList(type)
        retType.<ContainerType>.itemType = type.keyType
      }
    ELSEIF methodName == "values"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictValues)
        ctx.out.write("ZDictValues(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(dotnil ? ", 1)" : ", 0)")
        retType = ListStuff.newList(type)
      }
    ELSEIF methodName == "map" || methodName == "keyMap"
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        IF methodName == "map"
          ctx.setDeclUsed(%dictMap)
          ctx.out.write("ZDictMap(")
        ELSE
          ctx.setDeclUsed(%dictKeyMap)
          ctx.out.write("ZDictKeyMap(")
        }
        Generate.genExpr(object, ctx, type)

        ctx.out.write(", ")
        Zui.Expression arg = argList[0]
        Generate.genFuncArg(arg,
                 methodName == "map" ? NIL : type.keyType, type.itemType, ctx)

        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "copy"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictCopy)
        ctx.out.write("ZDictCopy(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "size" || methodName == "Size"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictSize)
        ctx.out.write("ZDictSize(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
      }
      retType = Type.anInt
    ELSEIF ctx.gen.writing
      ctx.error("Method " .. methodName .. "() not supported for Dict",
                                                              call.getPos())
    }

    IF retType == NIL
      RETURN Type.anUnknown
    }
    RETURN retType
  }

  # Generate the key argument for |expr|.
  PROC genKeyArg(ContainerType type, Zui.Expression expr, SContext ctx)
    IF type.keyType == NIL
      ctx.out.write("nokeytype")
      RETURN
    }
    Generate.genExprDoConv(expr, ctx, type.keyType)
  }

  # Generate the value argument for |expr|.
  # Outputs ", val".
  PROC genValueArg(ContainerType type, Zui.Expression expr, SContext ctx)
    ctx.out.write(", ")
    Generate.genExprDoConv(expr, ctx, type.itemType ?: Type.anInt)
  }

  # Set dependencies between used items.  Called before marking Main() as
  # used.
  PROC addDependencies(WriteJava gen)
    # Not always used but too much work to figure it out properly.
    Declaration.dict.addDependsOn(
                     DeclStore.getDecl("MEModule", "FthrowStringKeyNotFound"))
    Declaration.dict.addDependsOn(
                     DeclStore.getDecl("MEModule", "FthrowStringKeyExists"))

    # For giving errors, converting key to a string.
    Declaration.dict.addDependsOn(Declaration.itemToString)
    Declaration.itemToString.addDependsOn(%dictToString)
  }


  Declaration.C %dictToString = NEW("dictToString")
  Declaration.C %dictGet = NEW("dictGet")
  Declaration.C %dictGetDef = NEW("dictGetDef")
  Declaration.C %dictIsOrdered = NEW("dictIsOrdered")
  Declaration.C %dictRemove = NEW("dictRemove")
  Declaration.C %dictCopy = NEW("dictCopy")
  Declaration.C %dictSize = NEW("dictSize")
  Declaration.C %dictHas = NEW("dictHas")
  Declaration.C %dictClear = NEW("dictClear")
  Declaration.C %dictKeys = NEW("dictKeys")
  Declaration.C %dictValues = NEW("dictValues")
  Declaration.C %dictMap = NEW("dictMap")
  Declaration.C %dictKeyMap = NEW("dictKeyMap")
  Declaration.C %dictCompare = NEW("dictCompare")
  Declaration.C %dictEqual = NEW("dictEqual")

  PROC initCodeWriters(list<CodeWriter> codeWriters)
    codeWriters.add(NEW(%dictToString,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
static <Tk, Ti> String ZDictToString(ZDict<Tk, Ti> d, boolean keyUseq, boolean itemUseq) {
 if (d == null) return "NIL";
 ++tosNr;
 return ZDictToStringGa(d, keyUseq, itemUseq);
}
static <Tk, Ti> String ZDictToStringGa(ZDict<Tk, Ti> d, boolean keyUseq, boolean itemUseq) {
 if (d == null) return "NIL";
 StringBuffer res = new StringBuffer();
 res.append("[");
 if (d.tosNr == tosNr) {
  res.append("recursive-dict");
 } else {
  d.tosNr = tosNr;
  boolean first = true;
  for (Tk key : d.map.keySet()) {
   if (first) { first = false; } else { res.append(", "); }
   Ti v = d.map.get(key);
   res.append(ZitemToString(key, d.keyType, keyUseq));
   res.append(": ");
   res.append(ZitemToString(v, d.itemType, itemUseq));
  }
  d.tosNr = 0;
  if (first) return "[:]";
 }
 res.append("]");
 return res.toString();
}
"'')
      }).setDependencies([Declaration.itemToString]))

    codeWriters.add(NEW(%dictGet,
      PROC (WriteJava gen, IO.File fd)
        string stringKey = DeclStore.getPName("MEModule",
                                                    "FthrowStringKeyNotFound")
        fd.write(''"
static <Tk, Ti> Ti ZDictGet(ZDict<Tk, Ti> d, Tk key) {
 if (d == null) ZthrowNil("getting item from NIL dict");
 if (!d.map.containsKey(key)) "'' .. stringKey .. ''"(ZitemToString(key, d.keyType, true), "");
 return d.map.get(key);
}
"'')
      }).setDependencies([["MEModule", "FthrowStringKeyNotFound"]]))

    codeWriters.add(NEW(%dictGetDef,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
static <Tk, Ti> Ti ZDictGetDef(ZDict<Tk, Ti> d, Tk key, Ti def) {
 if (d.map.containsKey(key))
  return d.map.get(key);
 return def;
}
"'')
      }))

    codeWriters.add(NEW(%dictKeys,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
static <Tk, Ti> ZList<Tk> ZDictKeys(ZDict<Tk, Ti> d, boolean dn) {
 ZList<Tk> l = new ZList<Tk>(d.keyType);
 if (d != null) {
  l.list.addAll(d.map.keySet());
 }
 return l;
}
"'')
      }))

    codeWriters.add(NEW(%dictValues,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZDictValues(d, dn) {
 if (!d) {
  if (dn) return null;
  ZthrowNil("Invoking values() on NIL dict");
 }
 var l = [];
 var i = 0;
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   l[i++] = d[key][1];
  }
 }
 return {a: l, itemType: d.itemType};
}
"'')
      }))

    codeWriters.add(NEW(%dictMap,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZDictMap(d, f) {
 if (d == null) return null;
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   d[key][1] = f(d[key][1]);
  }
 }
 return d;
}
"'')
      }))

    codeWriters.add(NEW(%dictKeyMap,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZDictKeyMap(d, f) {
 if (d == null) return null;
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   var v = d[key];
   v[1] = f(v[0], v[1]);
  }
 }
 return d;
}
"'')
      }))

    codeWriters.add(NEW(%dictRemove,
      PROC (WriteJava gen, IO.File fd)
        string stringKey = DeclStore.getPName("MEModule",
                                                  "FthrowStringKeyNotFound")
        fd.write(''"
function ZDictRemove(d, key, remove) {
 var r;
 var ckey = ZDictKey(d, key);
 if (ckey in d) {
  d.size--;
  r = d[ckey][1];
  delete d[ckey];
 } else if (remove) {
  "'' .. stringKey .. ''"(key, 'dict.remove(): ');
 }
 if (remove)
  return r;
 return d;
}

"'')
      }).setDependencies([["MEModule", "FthrowStringKeyNotFound"]]))

    codeWriters.add(NEW(%dictClear,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZDictClear(d) {
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   delete d[key];
  }
 }
 d.size = 0;
 return d;
}
"'')
      }))

    codeWriters.add(NEW(%dictCopy,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZDictCopy(d) {
 var newd = {};
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   newd[key] = d[key].slice(0);
  } else {
   newd[key] = d[key];
  }
 }
 return newd;
}
"'')
      }))

    codeWriters.add(NEW(%dictSize,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
static <Tk, Ti> int ZDictSize(ZDict<Tk, Ti> d) {
 return d == null ? 0 : d.map.size();
}
"'')
      }))

    codeWriters.add(NEW(%dictHas,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
static <Tk, Ti> boolean ZDictHas(ZDict<Tk, Ti> d, Tk key) {
 return d != null && d.map.containsKey(key);
}
"'')
      }))

    codeWriters.add(NEW(%dictIsOrdered,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZDictIsOrdered(d) {
 if (d == null) ZthrowNil("Invoking isOrdered() on NIL dict");
 return d.ordered;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

    codeWriters.add(NEW(%dictEqual,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZDictEqual(dl, dr) {
 if (!dl || !dr) ZthrowNil("Comparing with NIL dict");
 if (dl.size != dr.size) return false;
 for (var ckey in dl) {
  if (ckey.charCodeAt(0) == 58 && (!dr[ckey] || !ZitemEqual(dl.itemType, dl[ckey][1], dr.itemType, dr[ckey][1]))) return false;
 }
 return true;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

    codeWriters.add(NEW(%dictCompare,
      PROC (WriteJava gen, IO.File fd)
        fd.write(''"
function ZDictCompare(dl, dr) {
 if (!l || !r) ZthrowNil("Comparing with NIL dict");
 if (dl.size != dr.size) return dl.size > dr.size ? 1 : -1;
 for (var ckey in dl) {
  if (ckey.charCodeAt(0) == 58 && (!dr[ckey] || !ZitemEqual(dl.itemType, dl[ckey][1], dr.itemType, dr[ckey][1]))) return 1;
 }
 return 0;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

  }  # end of initCodeWriters

  PROC writeBody(WriteJava gen, IO.File fd)
    IF gen.isDeclUsed(Declaration.dict)
      # "ow" is the overwrite flag.  When zero it's not allowed to overwrite
      # an existing entry.
      string keyExists = DeclStore.getPName("MEModule",
                                                    "FthrowStringKeyExists")
      fd.write(''"
static class ZDict<Tk, Ti> {
  final public HashMap<Tk, Ti> map;
  final public ZType keyType;
  final public ZType itemType;
  public int tosNr = 0;
  public ZDict(ZType keyType, ZType itemType) {
    this.map = new HashMap<Tk, Ti>();
    this.keyType = keyType;
    this.itemType = itemType;
  }
}

int nextId = 0;
static <Tk, Ti> ZDict<Tk, Ti> ZDictAdd(boolean ow, ZDict<Tk, Ti> d, Tk key, Ti value) {
 if (d == null) ZthrowNil("adding item to NIL dict");
 if (d.map.containsKey(key)) {
  if (!ow) "'' .. keyExists .. ''"(ZitemToString(key, d.keyType, true), "dict.add(): ");
 }
 d.map.put(key, value);
 return d;
}
"'')
    }
  }

  PROC writeDictAlloc(ContainerType type, string noAllocName,
                        Zui.MethodCall call, bool isOrderedDict,
                        Zui.Position pos, SContext ctx)
    Output out = ctx.out
    WriteJava genJava = ctx.gen
    # TODO: isOrderedDict
    out.write("new ZDict<")
    out.write(genJava.vartypeString(type.keyType, FALSE, TRUE, pos, ctx))
    out.write(", ")
    out.write(genJava.vartypeString(type.itemType, FALSE, TRUE, pos, ctx))
    out.write(">(")
    out.write(WriteJava.getTypeName(type.keyType, ctx))
    out.write(", ")
    out.write(WriteJava.getTypeName(type.itemType, ctx))
    out.write(")")
  }

}
