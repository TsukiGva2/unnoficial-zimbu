#
# The Zimbu compiler written in Zimbu
#
# Token class.
#
# Copyright 2009 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO zui.proto

IMPORT TokenType.zu

# NOTE: Don't add imports here that drag in parts of the compiler.

CLASS Token @public @items=public   # TODO: restrict visibility
  TokenType     $type
  string        $value
  byteString    $byteValue       # for stringLiteral when $value is NIL
  bool          $hasComment      # includes a comment (line_sep can have it)
  bool          $hasCommentFirst # comment starts before line break
  Zui.Position  $zuiPos          # start position of the token

  int           $pluginLnum      # line number from #@ :123

  # Create a Z.Pos from $zuiPos.
  FUNC $zcPos() Z.Pos @private
    RETURN Z.Pos.NEW($zuiPos.getFilename(),
                                       $zuiPos.getLine(), $zuiPos.getColumn())
  }

  # Report an error detected during parse phase after getting this token.
  PROC $error(string msg)
    LOG.error(msg, $zcPos())
  }

  # Report an error for token found in a place where it is not accepted.
  PROC $notAllowedError()
    LOG.error("'\($value)' not allowed here", $zcPos())
  }

  # Return TRUE if the token has a type that is white space or comment.
  FUNC $isSep() bool
    RETURN $type == TokenType.sep
        || $type == TokenType.line_sep
        || $type == TokenType.comment
  }

  # Return a shallow copy of the Token.  Positions are deep-copied.
  FUNC $copy() Token
    Token t = NEW()
    t.type = $type
    t.value = $value
    t.hasComment = $hasComment
    t.hasCommentFirst = $hasCommentFirst
    IF $zuiPos != NIL
      t.zuiPos = $zuiPos.copy(FALSE)
    }
    RETURN t
  }

}
