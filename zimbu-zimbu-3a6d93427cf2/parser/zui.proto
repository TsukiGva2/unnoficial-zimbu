// Protocol buffer definition for parsed .zu files.
//
// This contains all the information produced by the parser.  This is input for
// the rest of the compiler.
//
// The information can also be used for "zudocu", thus it contains essential
// parts of comments.
//
//
// Copyright 2010 Bram Moolenaar
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// The License can be found it in the LICENSE file, or you may obtain a copy of
// the License at http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.

package Zui;

message Contents {
  // Imported files.
  repeated Import import = 1;

  // What is defined in the file.  For an imported file it is one item.
  // In the main file and test files it can be many.
  // This normally is a list of Declarations.
  repeated Statement statement = 2;

  // If "#@ filename" is encountered the file name is set here.
  // This is used for the plugin input file.
  optional string pluginFileName = 3;
}


message Import {
  // Name as specified in the .zu file.
  required string fileName = 1;

  // True when <filename> was used instead of "fileName".
  optional bool angleQuotes = 2;

  // plugin name: PROTO, ZWT, etc.
  optional string plugin = 3;

  // Name of the toplevel item in the import.
  optional string toplevelName = 4;

  // Name used in AS argument.
  optional string asName = 5;

  // String used in OPTIONS argument.
  optional string options = 6;

  // Where the import was defined.
  optional Position pos = 7;

  // Whether @javascript is present
  optional bool javascript = 8;
}


// A declared item, something defined in the Zimbu file, specified by name
// and optionally a type.
message Declaration {
  // Symbol name as used in the Zimbu file.  This is without dots.
  // It is not set for anonymous items.
  optional string name = 1;

  // For an argument after USE, name may contain dots: "USE Mod.var".
  optional Expression dotName = 2;

  // Has a dollar before the name: $name.
  optional bool dollar = 3;

  // Has a percent before the name: %name.
  optional bool percent = 4;

  // Has a colon before the name: :name.
  optional bool colon = 5;

  // SHARED declaration.
  optional bool shared = 6;

  // Where the symbol was defined.
  optional Position pos = 7;

  // Item does not have a type but USE before it.
  optional bool isUse = 8;

  // The type of the declared item.
  optional Type type = 9;

  // Variable initialization.
  optional Expression init = 10;

  // When TRUE: argument of a method; only used in the CodeBlock of a
  // MethodType.
  optional bool isArg = 11;

  // For an argument: type ... name
  optional bool threeDots = 12;

  // Comment before the declaration.
  optional string commentBefore = 13;

  // Comment after the declaration.
  optional string commentAfter = 14;

  // Prefer using commentAfter if commentBefore is also present.
  optional bool preferCommentAfter = 15;

  // TODO: visibility.
  // TODO: usage dependency.
}

enum TypeEnum {
  // Most often used types.
  INT = 0;  // same as INT64
  BOOL = 1;
  STATUS = 2;
  NIL = 3;
  ANY = 4;

  // String types.
  CSTRING = 5;
  STRING = 6;
  VARSTRING = 7;
  BYTES = 8;
  VARBYTES = 9;

  // Container types
  ARRAY = 10;
  TUPLE = 11;
  LIST = 12;
  DICT = 13;
  MULTIDICT = 14;
  SET = 15;
  MULTISET = 16;

  // Method definitions.
  NEW = 17;
  PROC = 18;
  FUNC = 19;
  LAMBDA = 49;

  // Method references.
  PROCREF = 20;
  FUNCREF = 21;

  // Module
  MODULE = 22;

  // Types with declaration and instances.
  ENUM = 23;
  ENUMVAL = 24;

  BITS = 25;
  BITSVAL = 26;

  CLASS = 27;
  OBJECT = 28;   // object of known class

  INTERFACE = 29;
  IOBJECT = 30;  // object of class with known interface

  PIECE = 48;

  NAT = 34;  // used for numbers so long as there is no sign
  BIGINT = 35;
  BIGNAT = 36;

  // Floating point numbers.
  FLOAT = 40;  // same as FLOAT64
  FLOAT32 = 41;
  FLOAT80 = 42;
  FLOAT128 = 43;

  // Fixed point numbers in 64 bit, number of decimals set in "decimals".
  FIXED = 44;

  ALIAS = 45;  // also used for TYPE

  // "USE var": get type of var from context.
  USE = 46;

  // Method argument with &var
  REF = 47;

  NAME = 100;  // Unparsed name, possibly with dots.
  UNKNOWN = 101;   // Only used internally.
}

message Type {
  // Symbol type.
  required TypeEnum type = 1;

  // The text used to declare the type, for error messages.
  optional string text = 2;

  // Where the text starts.
  optional Position pos = 3;

  optional Attributes attr = 4;

  ////// Information about simple types.

  // Number of decimals for FIXED.  Range 1 to 15.
  optional int64 decimals = 6; 

  // Mask for the significant bits: 1 for bool, 1/3/7/etc. for enum and intN.
  optional int64 mask = 7;

  ////// Information about not so simple types.

  // A class, interface or piece type declaration.
  optional ClassType classDecl = 8;

  // A BITS type declaration.
  optional BitsType bitsDecl = 9;

  // An ENUM type declaration.
  optional EnumType enumDecl = 10;

  // A module type declaration.
  optional ModuleType moduleDecl = 11;

  // A FUNC or PROC type declaration.
  optional MethodType methodDecl = 12;

  // A container type: dict, list, etc.
  optional ContainerType container = 13;

  // An alias
  optional AliasType alias = 14;

  // A reference: &name
  optional Type ref = 15;

  // Type name, possibly with dots.
  optional Expression name = 16;

  // Name and position of a tuple item.
  optional string itemName = 18;
  optional Position itemNamePos = 19;

  // For return type  in func<arg => return>
  optional bool isReturn = 17;
}

enum Visibility {
  UNSET = 0;
  PRIVATE = 1;
  PROTECTED = 2;
  PUBLIC = 3;
  LOCAL = 4;
  FILE = 5;
  DIRECTORY = 6;
}

message Attributes {
  optional bool abstract = 1;                 // @abstract
  optional bool isdefault = 2;                // @default
  optional bool final = 3;                    // @final
  optional bool define = 4;                   // @define
  optional bool replace = 5;                  // @replace
  optional bool earlyInit = 6;                // @earlyInit
  optional bool primitive = 7;                // @primitive

  optional bool noBacktrace = 8;              // @backtrace=no
  optional bool wantBacktrace = 9;            // @backtrace=yes

  optional Visibility visibility = 10;        // @public
  optional Visibility readVisibility = 11;    // @read=public
  optional Visibility itemsVisibility = 12;   // @items=public

  optional bool testOnly = 13;                // @testOnly
  optional bool notOnExit = 14;               // @notonexit
  optional bool javascript = 15;              // @javascript
}


// A class, interface or piece.
message ClassType {
  optional bool isInterface = 1;
  optional bool isPiece = 2;

  // Template type names: <Tone, Ttwo>.
  repeated Id templateTypeName = 3;

  // EXTENDS, AUGMENTS, GROWS
  optional Expression extends = 4;
  optional Expression augments = 5;
  optional Expression grows = 6;

  // IMPLEMENTS items
  repeated Expression implements = 7;

  // Methods and members of the class/interface/piece.
  repeated Statement member = 8;

  // Methods and members in the SHARED section of the class.
  optional CodeBlock shared = 9;
  optional Attributes sharedAttr = 10;
}

// A BITS
message BitsType {
  // Methods and members of the bits.
  repeated Statement member = 1;
}


// An ENUM
message EnumType {
  // The items of the enum.
  repeated Declaration item = 1;

  // EXTENDS {name}
  optional Expression extends = 2;

  // Methods and members of the enum.
  repeated Statement member = 3;
}


message ModuleType {
  // The items defined in the Module.
  repeated Statement statement = 2;
}


// Method declaration.
message MethodType {
  // For FUNC and closure.
  repeated Type returnType = 1;

  // Method template type names: <Tone, Ttwo>.
  repeated Id templateTypeName = 2;

  // Arguments.
  repeated Declaration argument = 3;

  // USE Arguments.
  repeated Declaration use = 4;

  // Method body.
  optional CodeBlock body = 5;

  // For a closure: the expression.
  optional Expression expr = 6;
}


message ContainerType {
  // For DICT, MULTIDICT, SET, MULTISET
  optional Type keyType = 1;

  // For any container type.  Only TUPLE may have more than one itemType.
  repeated Type itemType = 2;
}


// ALIAS from name
// TYPE from name
message AliasType {
  optional Expression from = 1;

  optional string name = 2;

  // For Zudocu
  optional Statement for = 3;
}


// A block of code, can be nested.
message CodeBlock {
  // Where the block starts.
  optional Position pos = 1;

  // Where the block ends, the "}".
  optional Position endPos = 2;

  // The actual code.  Declarations too.
  repeated Statement statement = 3;
}


enum StatementType {
  VAR_DECL = 1;     // Type variable [= init]
  MODULE_DECL = 2;  // MODULE
  CLASS_DECL = 3;   // CLASS, INTERFACE, PIECE
  BITS_DECL = 4;    // BITS
  ENUM_DECL = 5;    // ENUM
  METHOD_DECL = 6;  // PROC, FUNC, NEW
  ALIAS_DECL = 7;   // ALIAS
  TYPE_DECL = 8;    // TYPE
  ASSIGN = 9;       // v = expr
  CALL = 10;        // method call
  NEWCALL = 11;     // NEW() as a statement
  IF = 12;          // IF - ELSEIF - ELSE
  GENERATEIF = 13;  // GENERATE_IF - GENERATE_ELSEIF - GENERATE_ELSE
  FOR = 14;         // FOR loop
  WHILE = 15;       // WHILE loop
  DO = 16;          // DO - UNTIL loop
  UNTIL = 17;       // UNTIL of DO - UNTIL loop
  TRY = 18;         // TRY - CATCH - FINALLY
  TRYELSE = 19;     // ELSE of TRY
  RETURN = 20;      // RETURN [expr]
  EXIT = 21;        // EXIT expr
  THROW = 22;       // THROW expr
  SWITCH = 23;      // SWITCH expr
  CASE = 24;        // CASE
  MATCH = 25;       // MATCH
  DEFAULT = 26;     // DEFAULT
  BREAK = 27;       // BREAK
  CONTINUE = 28;    // CONTINUE
  INC = 29;         // ++expr
  DEC = 30;         // --expr
  BLOCK = 31;       // { code }
  CBLOCK = 32;      // >>> C code <<<
  INCLUDE = 33;     // INCLUDE block
  GENERATEERROR = 34; // GENERATE_ERROR
  IFNIL = 35;       // IFNIL
  DEFER = 36;       // DEFER method(arg)
  SPLIT = 37;       // one statement split into several while parsing
}

// Any kind of statement.
message Statement {
  optional Position pos = 1;
  optional int64 pluginLnum = 2;

  required StatementType type = 3;

  // Only one of the following optional fields can be used at a time.
  optional Declaration declaration = 4; // for *_DECL
  optional Include include = 5;         // for INCLUDE
  optional Assignment assign = 6;       // for ASSIGN
  optional MethodCall methodCall = 7;   // for CALL, NEWCALL
  optional Condition condition = 8;     // for IF, GENERATEIF, WHILE, DO, SWITCH
  optional ForStatement for = 9;        // for FOR
  optional TryStatement try = 10;       // for TRY - CATCH - ELSE - FINALLY
  optional CodeBlock block = 11;        // for TRYELSE, BLOCK
  optional Expression expr = 12;        // for RETURN, EXIT, THROW, CASE, INC,
                                        // DEC
  repeated Expression arguments = 13;   // for RETURN
  repeated CBlock cblock = 14;          // for CBLOCK
  optional Position proceedPos = 15;    // for CASE: PROCEED after block
  optional bool blockgc = 16;           // for >>>: blocking GC

  repeated Statement statement = 17;    // for SPLIT
}


message Include {
  repeated Statement statement = 1;
}


message Assignment {
  // For +=, -=, ..=, etc.  Not set for normal assign.
  optional ExprType type = 1;

  required Expression lhs = 2;  // left hand side
  required Expression rhs = 3;  // right hand side
}


message Condition {
  optional Expression cond = 1;  // empty for DO - UNTIL

  optional CodeBlock block = 2;

  // IF can have any number of ELSEIF.  Each of these only has the "cond" and
  // "block" fields filled in.
  repeated Condition elseif = 3;

  // IF can have one final ELSE
  optional CodeBlock else = 4;
}


message ForStatement {
  repeated Declaration loopVar = 1;      // FOR loopVarName IN expr

  repeated Expression iter = 2;   // what comes after IN

  optional Expression to = 3;     // FOR x IN expr TO expr
  optional Expression until = 4;  // FOR x IN expr UNTIL expr

  optional Expression step = 5;   // FOR x IN expr TO expr STEP expr

  optional CodeBlock body = 6;
}


message TryStatement {
  optional CodeBlock body = 1;
  repeated Catch catch = 2;
  optional CodeBlock else = 3;
  optional CodeBlock finally = 4;
}


message Catch {
  optional Position pos = 1;
  repeated Type type = 2;
  required Declaration decl = 3;  // the variable that gets the exception 
  optional CodeBlock body = 4;
}


// Part of a liberal C block from >>> to <<<.
message CBlock {
  optional Position pos = 1;
  repeated string uses = 2;      // uses(foo, bar)
  optional string text = 3;      // Literally copied text
  optional Expression expr = 4;  // expression %var% or %{ expr }%
  optional bool literal = 5;     // %[ expr ]%
}


message WhileStatement {
  required Expression cond = 1;
  optional CodeBlock body = 2;
}


message DoStatement {
  required Expression cond = 1;
  optional CodeBlock body = 2;
}


enum ExprType {
  ID = 1;           // id; uses name, percent and dollar

  INT = 2;          // number
  NAT = 64;         // unsigned number
  FLOAT = 3;        // number.dotNumber e expNumber
  STRING = 4;       // stringValue
  BYTESTRING = 67;  // byteStringValue
  NIL = 5;
  TRUE = 6;
  FALSE = 7;
  OK = 8;
  FAIL = 9;
  THIS = 10;
  PARENT = 11;      // used for PARENT, not for abc.PARENT
  LIST = 12;        // [listItem, ...]
  DICT = 13;        // [dictItem, ...]
  INIT = 65;        // {name: expr, ...}

  CALL = 14;        // methodCall
  NEWCALL = 15;     // methodCall  name.NEW()
  METHOD = 16;      // decl   FUNC () s }
  LAMBDA = 17;      // lambda function   { x => y }
  MEMBER = 18;      // left.right
  TYPECAST = 19;    // left.<typecast>
  TYPESPEC = 20;    // left<typespec ...>
  CTYPE = 21;       // %< C-type >%
  JAVATYPE = 72;    // %< Java-type >%
  JSTYPE = 73;      // %< JS-type >%

  MINUS = 22;       // -right
  NOT = 23;         // !right
  TILDE = 24;       // ~right
  REF = 25;         // &right

  PRE_INC = 26;     // ++right
  PRE_DEC = 27;     // --right
  POST_INC = 28;    // right++
  POST_DEC = 29;    // right--

  PARENS = 30;      // (right)
  SUBSCRIPT = 31;   // left[right]
  BITSASSIGN = 32;  // left=right  left=-right
  EXPRMETHOD = 33;  // left.(right)
  ADD = 34;         // left + right
  SUBTRACT = 35;    // left - right
  MULTIPLY = 36;    // left * right
  DIVIDE = 37;      // left / right
  REMAINDER = 38;   // left % right
  CONCAT = 39;      // left .. right
  SHIFT_LEFT = 40;  // left << right
  SHIFT_RIGHT = 41; // left >> right
  BIT_AND = 42;     // left & right
  BIT_OR = 43;      // left | right
  BIT_XOR = 44;     // left ^ right

  IFNIL = 45;       // left ?: right
  TERNARY = 46;     // cond ? left : right

  EQUAL = 47;         // left == right
  EQUALIC = 68;       // left ==? right
  NOTEQUAL = 48;      // left != right
  NOTEQUALIC = 69;    // left !=? right
  MATCH = 49;         // left =~ right
  MATCHIC = 70;       // left =~? right
  NOMATCH = 50;       // left !~ right
  NOMATCHIC = 71;     // left !~? right
  GREATER = 51;       // left > right
  GREATER_EQUAL = 52; // left >= right
  LESS = 53;          // left < right
  LESS_EQUAL = 54;    // left <= right
  IS = 55;            // left IS right
  ISNOT = 56;         // left ISNOT right
  ISA = 57;           // left ISA right
  ISNOTA = 58;        // left ISNOTA right
  AND = 59;           // left && right
  OR = 60;            // left || right

  INF = 61;
  NINF = 62;
  NAN = 63;

  ASSIGN = 66;        // name = expr (name uses stringValue)
  CCODE = 77;         // C(code)

  UNKNOWN = 99;       // used for empty expression
}

// An expression.
message Expression {
  required ExprType type = 1;

  // Where the operator was defined.  Always set, also when the position is in
  // value, etc.
  optional Position pos = 2;

  // Name for ID, PARENT, THIS, etc.
  optional string name = 3;

  // Has a dollar before the name: $name.
  optional bool dollar = 4;

  // Has a percent before the name: %name.
  optional bool percent = 5;

  // Has a colon before the name: :name.
  optional bool colon = 6;

  // INT value.  Also used for NAT value, in which case it goes negative for
  // very large values.
  optional int64 number = 7;

  // Float value.
  optional double fnumber = 8;

  // Number after the dot, unused.
  optional int64 dotNumber = 9;

  // "text"
  optional string stringValue = 10;

  // "\xff"
  optional bytes byteStringValue = 11;

  // One item in [expr, ...]
  repeated Expression listItem = 12;

  // One item in [expr: expr, expr: expr]
  repeated ExprPair dictItem = 13;

  // One item in [name: expr, name: expr]
  repeated NameExpr initItem = 14;

  // TRUE for O[key: value]
  optional bool orderedDict = 15;

  // CALL: module.method(arguments)
  optional MethodCall methodCall = 16;

  // CLOSURE: { arg, .. => expr }
  optional MethodType method = 17;

  // METHOD: PROC block } or FUNC block }
  optional Declaration decl = 18;

  // TYPECAST: left.<Type>
  optional Type typecast = 19;

  // TYPESPEC: left<Type, Type>
  repeated Type typespec = 20;

  // For TERNARY operation.
  optional Expression cond = 21;

  // For SEQUENCE and binary operators.
  // If this Expression type is MEMBER then left can again be a member while
  // right isn't.
  optional Expression left = 22;

  optional Expression right = 23;

  // Using ?. instead of .
  optional bool dotnil = 24;

  // Method call used to implement the expression.
  // Set when generating code.
  optional MethodCall call = 25;
}


// ID: a type name.
message Id {
  // Only set for specific usage.
  optional Position pos = 1;

  // The name can include dots, e.g. for Module.member.
  required string name = 2;

  // Has a dollar before the name: $name.
  optional bool dollar = 3;

  // Has a percent before the name: %name.
  optional bool percent = 4;

  // Has a colon before the name: :name.
  optional bool colon = 5;
}


// Pair used in a dict.
message ExprPair {
  required Expression key = 1;
  required Expression value = 2;
}


// name-expr used in an object initializer.
message NameExpr {
  required string name = 1;
  required Expression value = 2;
}


// Method call:  method(args), Module.method(args), object.method(args)
message MethodCall {
  optional Position pos = 1;

  // What goes before the ().  Can result in an object.
  // For NEW statement and NEWCALL expression it is unset.
  optional Expression name = 2;

  repeated Expression argument = 3;

  // Dummy expression to store info about a vararg argument.
  optional Expression vararg = 4;
}


// Defines a position in a file.
message Position {
  // The first line in a file has number 1.
  optional int64  line = 1;

  // UTF-8 character number; the first position in a line is 1.
  optional int64  column = 2;

  // For a parsed file the file name is filled in.
  optional string filename = 3;
}

// vim: set et sw=2 tw=79 :
