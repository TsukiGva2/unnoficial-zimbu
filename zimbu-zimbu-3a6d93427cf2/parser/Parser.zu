#
# The Zimbu compiler written in Zimbu
#
# Parser module.
#
# Copyright 2009 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO zui.proto

# NOTE: Don't add imports here that drag in parts of the compiler.
IMPORT Visibility.zu
IMPORT FilePosition.zu
IMPORT Input.zu
IMPORT Token.zu
IMPORT TokenInput.zu
IMPORT TokenType.zu
IMPORT Tokenizer.zu

CLASS Parser @public @items=public              # TODO: restrict visibility

  # We use TokenType a lot, define an alias.
  ALIAS TokenType TType

  # Every block that doesn't have a name gets a number, so that items defined
  # inside it can have a unique name.
  int $scopeNumber = 1

  # Create one tokenizer and recycle it
  Tokenizer $tokenizer

  TokenInput $in

  NEW(Tokenizer tokenizer)
    $tokenizer = tokenizer
  }

  # Result of parsing a file.  Used to pass used keywords to the caller.
  CLASS ParseResult
    set<string>      $usedIdKeywords @public
  }

  # Read and parse |fileName|, return a Zui.Contents with the parse tree.
  # Also returns a ParseResult with extra information.
  # |blockType| should contain toplevel and mainfile or import.
  # Return NIL, NIL when the file could not be read.
  FUNC $parseFile(string fileName, string indent, BlockType blockType
                ) Zui.Contents, ParseResult
    IO.File inFile = IO.fileReader(fileName)
    IF inFile == NIL
      RETURN NIL, NIL
    }
    DEFER inFile.close()

    # Parse the file.
    Input input = NEW(inFile, fileName, indent)
    LOG.info("\(indent)\(fileName): Parsing...")

    RETURN $parseInput(input, blockType)
  }

  FUNC $parseInput(Input input, BlockType blockType) Zui.Contents, ParseResult
    $in = NEW(input, $tokenizer)
    ParseResult pr = NEW()

    # Skip comments and white space at the start of the file.
    # All other skipping is done after a statement.
    $skipSep()

    # Parse IMPORT statements.
    Zui.Contents contents = NEW()
    $parseImports(contents)

    # Parse code after IMPORT.
    $parseBody(blockType, contents)

    # If "#@ filename" was found add it to Contents.
    contents.setPluginFileName(input.pluginFileName)

    pr.usedIdKeywords = $in.usedIdKeywords
    RETURN contents, pr
  }

  #
  # Parse IMPORT statements and them to contents.imports.
  #
  PROC $parseImports(Zui.Contents contents)
    Token   token

    # Keep the separator before the first import for the first item after the
    # last import.
    Token firstSep = $lastSep

    WHILE TRUE
      token = $in.peekToken()
      IF token.type != TType.import
        BREAK
      }

      $beforeImport()

      token = $in.getToken()
      string plugin
      Token next = $tokenAfterSep()
      IF next.type == TType.dot
        # IMPORT.plugin
        $checkNoSep()
        token = $in.getToken()  # eat the "."
        $checkNoSep()
        token = $in.getToken()
        IF token.type != TType.id
          token.error("IMPORT. must be followed by a name")
        ELSE
          plugin = token.value
        }
      }

      $expectSep()
      token = $in.getToken()
      string fileName
      Zui.Position pos = token.zuiPos
      bool angle

      IF token.type == TType.eof || token.type == TType.line_sep
        token.error("IMPORT must be followed by a name")
      ELSEIF token.type == TType.lt
        # IMPORT <name>
        angle = TRUE
        IO.StringWriter w = NEW()
        $in.emptyStack()
        WHILE TRUE
          int c = $in.get()
          IF c == IO.eof || c == '\n'
            token.error("Missing >")
            BREAK
          }
          IF c == '>'
            BREAK
          }
          w.writeChar(c)
        }
        fileName = w.ToString().trim()
      ELSEIF token.type == TType.stringLiteral
        # IMPORT "name"
        fileName = token.value
      ELSE
        # IMPORT name
        IO.StringWriter w = NEW()
        w.write(token.value)
        $in.emptyStack()
        WHILE TRUE
          int c = $in.get()
          IF c == ' ' || c == IO.eof || c == '\n'
            $in.push(c)
            BREAK
          }
          w.writeChar(c)
        }
        fileName = w.ToString().trim()
      }

      IF fileName != NIL
        string asName
        string options
        bool javascript

        WHILE TRUE
          SWITCH $tokenAfterSep().type
            CASE TType.as
              token = $getAs()
              IF asName != NIL
                token.error("duplicate AS")
              ELSE
                asName = token.value
              }
              CONTINUE
          
            CASE TType.options
              $expectSep()
              token = $in.getToken()  # OPTIONS
              $expectSep()
              token = $in.getToken()  # "--some_arg"
              IF token.type != TType.stringLiteral
                token.error("OPTIONS must be followed by a string")
              ELSEIF options != NIL
                token.error("duplicate OPTIONS")
              ELSE
                options = token.value
              }
              CONTINUE

            CASE TType.at
              Zui.Attributes za = NEW()
              $parseAttr(za, TRUE, ["javascript"])
              javascript = za.getJavascript()
              CONTINUE
          }
          BREAK
        }

        $expectNewLine()

        IF contents != NIL
          Zui.Import import = contents.addNewImport()
          import.setFileName(fileName)
          import.setPlugin(plugin)
          import.setOptions(options)
          import.setJavascript(javascript)
          IF asName != NIL
            import.setAsName(asName)
          }
          IF angle
            import.setAngleQuotes(TRUE)
          }
          import.setPos(pos)

          $afterImport(import)
        }
      }
    }

    # Only use the separator before the IMPORTs when the one after does not
    # have a comment.  When the last one has a comment it should be what comes
    # just before the CLASS or MODULE.
    IF !$lastSep.hasComment
      $lastSep = firstSep
    }
  }

  # Extension point: subclasses may want to do something before parsing an
  # import.  This method is called just before getting the IMPORT token.
  PROC $beforeImport() @default
  }

  # Extension point: subclasses may want to do something before parsing an
  # import.  This method is called just after parsing an IMPORT statement.
  PROC $afterImport(Zui.Import import) @default
  }

  # Read " AS name" and return the token with "name".
  FUNC $getAs() Token
    $expectSep()
    Token token = $in.getToken()  # AS
    $expectSep()
    token = $in.getToken()  # name
    IF token.type != TType.id
      token.error("AS must be followed by a name")
    }
    RETURN token
  }

  #
  # The main parsing function.
  #
  # Parse input |in| and fill in |contents|.
  #
  PROC $parseBody(BlockType blockTypeIn, Zui.Contents contents)
    Token  token
    bool   hadBlockItem
    BlockType blockType = blockTypeIn
    blockType.keepEnd = FALSE

    list<Zui.Statement> statements = NEW()

    # Parse toplevel code.
    WHILE TRUE
      token = $in.getToken()
      IF token.type == TType.eof
        # Normal way to end a file.
        BREAK
      }

      IF !blockType.mainfile && blockType.toplevel && hadBlockItem
        IF token.type == TType.c_close
          token.error("unexpected }")
        ELSE
          token.error("Only one toplevel item allowed")
        }
      }
      hadBlockItem = TRUE

      $in.pushToken(token)
      Zui.Statement stmt = $parseBlockItem(blockType)
      IF stmt == NIL
        token = $in.getToken()
        IF token.type == TType.eof
          BREAK
        ELSEIF token.type == TType.c_close
          token.error("unexpected }")
        ELSE
          token.notAllowedError()
        }
      ELSEIF stmt ISNOT %emptyStatement
        IF stmt.getType() == Zui.StatementType.eSPLIT
          statements.extend(stmt.getStatementList())
        ELSE
          statements.add(stmt)
        }
      }
    }

    contents.setStatementList(statements)
  }

  # Note: |mainfile| and |toplevel| are used at the same time for zudoc.
  BITS BlockType
    bool :mainfile  # file containing Main()
    bool :toplevel  # toplevel block, cannot have statements
    bool :import    # imported file, only CLASS/MIXIN/INTERFACE and MODULE
                    # allowed
    bool :keepEnd   # do not consume the trailing token; when FALSE block must
                    # end in "}"
    bool :interface # Interface definition, all methods are abstract
    bool :expression  # nameless PROC or FUNC declaration
  }

  FUNC $parseBlock(BlockType blockType) list<Zui.Statement>
    list<Zui.Statement> statements = NEW()

    WHILE TRUE
      Zui.Statement stmt = $parseBlockItem(blockType)
      IF stmt == NIL
        BREAK
      }
      IF stmt ISNOT %emptyStatement
        IF stmt.getType() == Zui.StatementType.eSPLIT
          statements.extend(stmt.getStatementList())
        ELSE
          statements.add(stmt)
        }
      }
    }
    IF !blockType.keepEnd
      Token token = $in.getToken()
      IF token.type != TType.c_close
        token.error("Syntax error")
      ELSE
        $expectNewLine()
      }
    }

    RETURN statements
  }

  SHARED
    # Returned by parseBlockItem() when no statement was found.
    Zui.Statement %emptyStatement = NEW()

    # Set the position of |stmt| from |token|.
    PROC setStmtPos(Zui.Statement stmt, Token token)
      stmt.setPos(token.zuiPos)
      stmt.setPluginLnum(token.pluginLnum)
    }
  }

  #
  # Parse an item in a block.
  # Return the statement or emptyStatement when there is none.
  # Return NIL when at the end of the block.
  #
  FUNC $parseBlockItem(BlockType blockType) Zui.Statement
    Token token = $in.getToken()

    SWITCH token.type
      CASE TType.eof
        $error("unexpected EOF")
        RETURN NIL

      CASE TType.line_sep
      CASE TType.sep
      CASE TType.comment
        # Ignore white space and commments at start of block.
        # Should not happen in between statements, because we consume the
        # separator after each statement.
        RETURN %emptyStatement

      CASE TType.c_close
        # End of this block.
        $in.pushToken(token)
        RETURN NIL

      CASE TType.stringLiteral
        token.error("unexpected string: '" .. token.value .. "'")
        RETURN %emptyStatement

      CASE TType.alias
      CASE TType.type
        RETURN $parseAlias(token)

      CASE TType.copy_start
        # >>>  # comment
        #   C or JS code
        # <<<
        RETURN $copyCode()

      CASE TType.c
      CASE TType.java
      CASE TType.js
        # Declaration with C type:  C(type) id
        # Declaration with Java type:  JAVA(type) id
        # Declaration with JS type:  JS(type) id
        RETURN $parseLangType(token.type)

      CASE TType.module
        RETURN $parseModule(token)


      CASE TType.class
      CASE TType.interface
      CASE TType.piece
        RETURN $parseClass(token)

      CASE TType.include
        RETURN $parseInclude(token)

      CASE TType.shared
        IF blockType.toplevel
          # SHARED interrupts the CLASS block, it is handled in parseClass().
          $in.pushToken(token)
          RETURN NIL
        }
        token.error("Unexpected SHARED")

      CASE TType.static
        $skipSep()

        # Must be a STATIC variable declaration
        Token nextToken = $in.getToken()
        Zui.Statement stmt = $parseStatement(nextToken, blockType)
        IF stmt.getType() == Zui.StatementType.eVAR_DECL
          stmt.getDeclaration().setShared(TRUE)
          RETURN stmt
        }
        token.error("Unexpected STATIC")

      CASE TType.new
        IF !blockType.toplevel
          BREAK
        }
        # NEW(arg) without preceding PROC.
        PROCEED

      CASE TType.proc
      CASE TType.func
        BlockType bt = blockType
        bt.keepEnd = FALSE
        RETURN $parseMethod(token, bt)

      CASE TType.lambda
        token.error("Misplaced LAMBDA")
        RETURN %emptyStatement

      CASE TType.bits
        RETURN $parseBits(token)

      CASE TType.enum
        RETURN $parseEnum(token)

      CASE TType.dollar
      CASE TType.percent
      CASE TType.colon
      CASE TType.id
      CASE TType.var
      CASE TType.this
      CASE TType.parent
      CASE TType.i
      CASE TType.sq_open  # tuple unpack
        # This can be the start of a declaration, method call, etc.
        RETURN $parseStatement(token, blockType)

      CASE TType.generate_if
        RETURN $parseIf(token)

      CASE TType.generate_elseif
      CASE TType.generate_else
        # "GENERATE_ELSEIF expr"  ends the block
        # "GENERATE_ELSE"  ends the block
        $in.pushToken(token)
        RETURN NIL

      CASE TType.generate_error
        RETURN $parseGenerateError(token)

      DEFAULT
        Zui.Statement stmt = $extendTopStatement(token, blockType)
        IF stmt != NIL
          RETURN stmt
        }
        # Something else: fall through
    }

    #
    # The rest cannot appear at the toplevel.
    #
    IF blockType.toplevel
      token.notAllowedError()
    }

    SWITCH token.type
      CASE TType.if
      CASE TType.ifnil
        RETURN $parseIf(token)

      CASE TType.elseif
      CASE TType.else
        # "ELSEIF expr"  ends the block
        # "ELSE"  ends the block
        $in.pushToken(token)
        RETURN NIL

      CASE TType.try
        RETURN $parseTry(token)

      CASE TType.catch
      CASE TType.finally
        # "CATCH expr"  ends the block
        # "FINALLY"  ends the block
        $in.pushToken(token)
        RETURN NIL

      CASE TType.while
        RETURN $parseWhile(token)
        
      CASE TType.do
        RETURN $parseDo(token)

      CASE TType.until
        # "UNTIL expr" ends the block
        $in.pushToken(token)
        RETURN NIL

      CASE TType.for
        RETURN $parseFor(token)

      CASE TType.return
      CASE TType.exit
      CASE TType.throw
      CASE TType.defer
        RETURN $parseReturnExitThrowDefer(token)

      CASE TType.break
      CASE TType.continue
        RETURN $parseBreakContinue(token)

      CASE TType.switch
        RETURN $parseSwitch(token)

      CASE TType.case
      CASE TType.match
      CASE TType.default
      CASE TType.proceed
        # "CASE expr"  ends the block
        # "DEFAULT"  ends the block
        # "PROCEED"  ends the block
        $in.pushToken(token)
        RETURN NIL

      CASE TType.new
        RETURN $parseNewStatement(token)

      CASE TType.c_open
        RETURN $parseBlockStatement(token)

      CASE TType.plusplus
      CASE TType.minmin
        # ++var, --var.member
        # Give an error for "++ x here, instead of giving an error for
        # unexpected sep.
        $checkNoSep()

        Zui.Expression nameExpr = $parseDotName(TRUE, :doTypespec + :doParens)
        # TODO: error when nameExpr is not a left value.
        IF nameExpr.getType() == Zui.ExprType.eCALL
          token.error("Cannot use " .. token.value .. " here")
        }
        $expectLineSep()

        RETURN $makeIncDecStatement(token, nameExpr)

      DEFAULT
        token.error("unexpected '" .. token.value .. "'")
    }

    RETURN %emptyStatement
  }

  FUNC $makeIncDecStatement(Token token, Zui.Expression nameExpr
       ) Zui.Statement
    bool isInc = (token.type == TType.plusplus)

    Zui.Statement stmt = NEW()
    stmt.setType(isInc ? Zui.StatementType.eINC : Zui.StatementType.eDEC)
        .setExpr(nameExpr)
    setStmtPos(stmt, token)

    RETURN stmt
  }

  # Parse a declaration after we have the type in |typeExpr| and ID in
  # |id_token|.
  FUNC $parseDeclaration(Zui.Expression typeExpr, Token id_token,
                            bool checkForInit, bool checkForEol
                       ) Zui.Statement
    Token token = id_token

    bool hasDollar
    bool hasPercent
    bool hasColon
    IF token.type == TType.dollar
      # member variable: Type $name
      token = $in.getToken()
      hasDollar = TRUE
    ELSEIF token.type == TType.percent
      # member variable: Type %name
      token = $in.getToken()
      hasPercent = TRUE
    ELSEIF token.type == TType.colon
      # member variable: Type :name
      token = $in.getToken()
      hasColon = TRUE
    }
    IF token.type != TType.id
      $in.pushToken(token)
      IF typeExpr.getType() == Zui.ExprType.eID
        token.error("name without operation: " .. typeExpr.getName())
      ELSE
        token.error("Syntax error")
      }
      RETURN %emptyStatement
    }

    # "Type name" is a declaration.
    string name = token.value
    Token startToken = token

    Token prevComment
    IF $lastSep.hasComment
      prevComment = $lastSep
    }

    # TODO: repeat when there is a comma: Type name, name @public = 1, name

    # Type name @public
    Zui.Attributes za = NEW()
    $parseAttr(za, TRUE, ["private", "protected",
                        "public", "local", "file", "directory", "read"])

    Zui.Expression expr
    IF checkForInit
      token = $tokenAfterSep()
      IF token.type == TType.assign
        # "Type name = expr"
        $expectSep()
        token = $in.getToken()
        $expectSep()
        expr = $parseExpr()

        # Check for @earlyInit.
        $parseAttr(za, TRUE, ["earlyInit"])
      }
    }

    # A comment directly after declaration belongs to the declaration:
    # "type name  # comment"
    # It is preferred over a comment before the declaration.
    Token peek = $in.peekToken()
    Token nextComment
    IF peek.type == TType.line_sep && peek.hasCommentFirst
      nextComment = peek
    }

    IF checkForEol
      $expectNewLine()
    }

    $typeUsed(typeExpr)

    Zui.Declaration decl = NEW()
    decl.setName(name)
        .setDollar(hasDollar)
        .setPercent(hasPercent)
        .setColon(hasColon)
        .setPos(startToken.zuiPos)
        .newType()
            .setType(Zui.TypeEnum.eNAME)  # actual type figured out later
            .setName(typeExpr)
            .setAttr(za)
    IF expr != NIL
      decl.setInit(expr)
    }
    IF prevComment != NIL
      decl.setCommentBefore(prevComment.value)
    }
    IF nextComment != NIL
      decl.setPreferCommentAfter(TRUE)
      decl.setCommentAfter(nextComment.value)
    }

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eVAR_DECL)
        .setDeclaration(decl)
    setStmtPos(stmt, startToken)
    RETURN stmt
  }

  # A type |expr| is used, may add it to the keywords when the type requires
  # loading a library module.  Do that right after parsing to reduce the
  # number of passes required.
  PROC $typeUsed(Zui.Expression expr)
    IF expr.getType() == Zui.ExprType.eID
      string name = expr.getName()
      string module = typeNames.get(name, NIL)
      IF module != NIL
        $in.usedIdKeywords.set(module)
      }
    }
  }

  # MODULE {name}
  #   type var1
  #   type var2
  # }
  FUNC $parseModule(Token startToken) Zui.Statement
    Token comment
    IF $lastSep.hasComment
      comment = $lastSep
    }

    # {name}
    $expectSep()
    Token token = $in.getToken()
    IF token.type != TType.id
      token.error("MODULE must be followed by a name")
    }
    string name = token.value

    # @public and friends, can't use @protected or @private
    Zui.Attributes za = NEW()
    $parseAttr(za, TRUE, ["public", "file", "directory", "items"])

    Zui.ModuleType module = NEW()
    $expectNewLine()
    module.setStatementList($parseBlock(:toplevel))

    Zui.Declaration decl = NEW()
    decl.setName(name)
        .setPos(startToken.zuiPos)
        .newType()
            .setType(Zui.TypeEnum.eMODULE)
            .setModuleDecl(module)
            .setAttr(za)
    IF comment != NIL
      decl.setCommentBefore(comment.value)
    }

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eMODULE_DECL)
        .setDeclaration(decl)
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  # CLASS {name}<Type, Type>
  #        [EXTENDS {name}, {name}]
  #        [IMPLEMENTS {name}, {name}]
  #   type var1
  #   FUNC name() type
  #     stmt
  #   }
  # }
  # INTERFACE {name} [EXTENDS {name}, {name}]
  #   type var1
  #   FUNC name() type
  # }
  # PIECE
  #   (like CLASS)
  # }
  FUNC $parseClass(Token classToken) Zui.Statement
    Token comment
    IF $lastSep.hasComment
      comment = $lastSep
    }
    bool isInterface = classToken.type == TType.interface
    bool isPiece = classToken.type == TType.piece
    Zui.ClassType class = NEW()
    IF isInterface
      class.setIsInterface(TRUE)
    }
    IF isPiece
      class.setIsPiece(TRUE)
    }

    Zui.Attributes za = NEW()
    IF isInterface
      za.setAbstract(TRUE)
    }

    # {name}
    $expectSep()
    Token token = $in.getToken()
    IF token.type != TType.id
      token.error("CLASS must be followed by a name")
    }
    string name = token.value

    # <Type, Type>  template types go in ClassType.templateTypeName.
    token = $tokenAfterSep()
    IF token.type == TType.lt
      $skipLineSep()
      class.setTemplateTypeNameList($parseTypeNameList())
      token = $tokenAfterSep()
    }

    # EXTENDS {name}
    # AUGMENTS {name}
    # GROWS {name}
    IF token.type == TType.extends
        || token.type == TType.augments
        || token.type == TType.grows
      $expectSep()
      token = $in.getToken()
      $expectSep()
      Zui.Expression nameExpr = $parseDotName(FALSE, :doTypespec)
      IF token.type == TType.extends
        class.setExtends(nameExpr)
      ELSEIF token.type == TType.augments
        class.setAugments(nameExpr)
      ELSE
        class.setGrows(nameExpr)
      }
      IF nameExpr.getType() == Zui.ExprType.eID
        string tname = nameExpr.getName()
        # TODO: More class types that require loading a library module?
        IF tname == "thread" || tname == "evalThread"
          $in.usedIdKeywords.set("THREAD")
        }
      }
      token = $tokenAfterSep()
    }

    # IMPLEMENTS {name}
    IF token.type == TType.implements
      IF isInterface
        token.error("cannot use IMPLEMENTS on an interface")
      }
      $expectSep()
      token = $in.getToken()
      $expectSep()
      list<Zui.Expression> nameList = $parseDotNameList()
      class.setImplementsList(nameList)
    }

    $parseAttr(za, TRUE, ["abstract", "final", "earlyInit",
                                        "private", "protected", "public",
                                   "local", "file", "directory", "items"])
    $expectNewLine()

    # Repeat parsing CLASS statements and SHARED blocks.
    list<Zui.Statement> memberStmts = NEW()
    list<Zui.Statement> sharedStmts = NEW()
    WHILE TRUE
      # Parse block and terminating }
      memberStmts.extend($parseBlock(
                       :toplevel + :keepEnd + (isInterface ? :interface : 0)))

      IF $tokenAfterSep().type != TType.shared
        BREAK
      }

      # Parse a SHARED section and a terminating }.
      token = $in.getToken()

      # TODO: SHARED @items=public should only apply to its contents
      $parseAttr(za, TRUE, ["items"])
      $expectNewLine()

      sharedStmts.extend($parseBlock(:toplevel))
    }

    class.setMemberList(memberStmts)
    IF sharedStmts.Size() > 0
      class.newShared()
           .setStatementList(sharedStmts)
      class.setSharedAttr(NEW())
    }

    # Check for closing }.
    token = $in.getToken()
    IF token.type != TType.c_close
      token.error("Syntax error")
      classToken.error("No } found that ends this class")
    ELSE
      $expectNewLine()
    }

    # Create the statement and the declaration.
    Zui.Declaration decl = NEW()
    decl.setName(name)
        .setPos(classToken.zuiPos)
        .newType()
            .setType(isInterface ? Zui.TypeEnum.eINTERFACE
                       : isPiece ? Zui.TypeEnum.ePIECE
                       : Zui.TypeEnum.eCLASS)
            .setClassDecl(class)
            .setAttr(za)
    IF comment != NIL
      decl.setCommentBefore(comment.value)
    }

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eCLASS_DECL)
        .setDeclaration(decl)
    setStmtPos(stmt, classToken)

    RETURN stmt
  }

  # INCLUDE
  #   PieceName $foo
  # }
  FUNC $parseInclude(Token startToken) Zui.Statement
    Token comment
    IF $lastSep.hasComment
      comment = $lastSep
    }
    $expectLineSep()

    Zui.Include include = NEW()
    list<Zui.Statement> stmtList = $parseBlock(0)
    include.setStatementList(stmtList)

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eINCLUDE)
        .setInclude(include)
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  bool   $hadMain        # set to TRUE when Main() encountered.

  # NEW(type arg1, type arg2) @attribute
  #   body
  # }
  #
  # PROC {name}(type arg1, type arg2) @attribute
  #   body
  # }
  #
  # FUNC {name}(type arg1, type arg2) type @attribute
  #   body
  # }
  #
  FUNC $parseMethod(Token firstToken, BlockType blockType
                  ) Zui.Statement
    CHECK.true(firstToken.type == TType.func
            || firstToken.type == TType.proc
            || firstToken.type == TType.lambda
            || firstToken.type == TType.new)
    IF blockType.import
      firstToken.notAllowedError()
    }
    Token comment
    IF $lastSep.hasComment
      comment = $lastSep
    }

    # Create a method statement and add it to list of statements in the
    # current block.
    Zui.Statement stmt = NEW()
    Zui.Declaration decl = stmt.newDeclaration()
    decl.setPos(firstToken.zuiPos)

    Zui.MethodType method = NEW()
    Zui.Attributes za = NEW()

    IF blockType.interface
      za.setAbstract(TRUE)
    }

    IF firstToken.type != TType.new
      $expectSep()
    }

    Zui.TypeEnum type = Zui.TypeEnum.ePROC
    string name
    IF blockType.expression
      # A nameless method, part of an expression.
      decl.setPos(firstToken.zuiPos)
    ELSE
      Token nameToken
      IF firstToken.type == TType.new
        # NEW()
        nameToken = firstToken
      ELSE
        # Get the function name.
        nameToken = $in.getToken()
        IF nameToken.type == TType.dollar
          # FUNC $function()  or PROC $proc()
          decl.setDollar(TRUE)
          nameToken = $in.getToken()
        }
        IF nameToken.type == TType.new
          nameToken.error(firstToken.value .. " NEW() not allowed")
        }
      }
      IF nameToken.type == TType.new
        # NEW()
        type = Zui.TypeEnum.eNEW
        decl.setDollar(TRUE)
      ELSEIF nameToken.type == TType.id && nameToken.value == "Main"
        # FUNC Main() int
        IF !blockType.mainfile
          nameToken.error("Main() not allowed in imported file")
        ELSEIF $hadMain
          nameToken.error("Duplicate Main()")
        }
        $hadMain = TRUE
      ELSEIF nameToken.type != TType.id
        nameToken.error("Expected a name")
      }
      name = nameToken.value
      decl.setPos(nameToken.zuiPos)

      # Check for <Type> after the name.
      IF $in.peekToken().type == TType.lt
        method.setTemplateTypeNameList($parseTypeNameList())
      }
    }
    decl.setName(name)

    # Get function arguments.  For LAMBDA there are no types.
    Token token = $in.getToken()
    IF token.type != TType.p_open
      token.error("Missing (")
    ELSE
      $parseArgDecl(method, firstToken.type == TType.lambda, TType.p_close)
    }

    IF firstToken.type == TType.func
      # FUNC name(args) ReturnType
      type = Zui.TypeEnum.eFUNC

      $expectSep()
      VAR typeList = $parseDotNameList()

      FOR retType IN typeList
        method.addNewReturnType()
            .setType(Zui.TypeEnum.eNAME)
            .setName(retType)
      }
    ELSEIF firstToken.type == TType.lambda
      type = Zui.TypeEnum.eLAMBDA
    }

    $parseAttr(za, TRUE,
                      ["backtrace", "abstract", "default", "define", "replace",
                       "test", "testOnly", "primitive", "notOnExit",
                       "private", "protected", "public", "local",
                       "file", "directory"])

    # Allow semicolon for line continuation only for nameless method.
    $expectLineSep(blockType.expression)

    # Get the body of the method.
    Zui.CodeBlock block = $getCodeBlock(firstToken,
                                              blockType.keepEnd ? :keepEnd : 0)
    IF block.hasStatement()
      method.setBody(block)
    }

    stmt.setType(Zui.StatementType.eMETHOD_DECL)
    setStmtPos(stmt, firstToken)
    decl.newType()
            .setType(type)
            .setMethodDecl(method)
            .setAttr(za)
    IF comment != NIL
      decl.setCommentBefore(comment.value)
    }

    RETURN stmt
  }

  # BITS {name}
  #   type var1
  #   type var2
  #   PROC ...
  #   FUNC ...
  # }
  FUNC $parseBits(Token bitsToken) Zui.Statement
    Zui.BitsType bits = NEW()
    Zui.Statement stmt = NEW()
    setStmtPos(stmt, bitsToken)
    Token comment
    IF $lastSep.hasComment
      comment = $lastSep
    }
    $expectSep()
    Token token = $in.getToken()
    IF token.type != TType.id
      token.error("BITS must be followed by a name")
    }

    Zui.Attributes za = NEW()
    $parseAttr(za, TRUE, ["private", "public", "local", "file", "directory"])

    $expectNewLine()
    list<Zui.Statement> stmts = $parseBlock(:toplevel)
    IF stmts.Size() > 0
      bits.setMemberList(stmts)
    }
    stmt.setType(Zui.StatementType.eBITS_DECL)
    Zui.Declaration decl = stmt.newDeclaration()
    decl.setPos(stmt.getPos())
        .newType()
            .setType(Zui.TypeEnum.eBITS)
            .setBitsDecl(bits)
            .setAttr(za)
    decl.setName(token.value)
    IF comment != NIL
      decl.setCommentBefore(comment.value)
    }

    RETURN stmt
  }

  # ENUM {name} [EXTENDS {name}]
  #   value1
  #   value2
  # }
  FUNC $parseEnum(Token enumToken) Zui.Statement
    Token comment
    IF $lastSep.hasComment
      comment = $lastSep
    }

    # {name}
    $expectSep()
    Token token = $in.getToken()
    IF token.type != TType.id
      token.error("ENUM must be followed by a name")
    }
    string enumName = token.value
    Zui.EnumType enum = NEW()

    # optional EXTENDS {name}
    IF $tokenAfterSep().type == TType.extends
      $expectSep()
      $in.getToken()
      $expectSep()
      enum.setExtends($parseDotName(FALSE, :doTypespec))
    }

    # @public and friends.
    Zui.Attributes za = NEW()
    $parseAttr(za, TRUE, ["private", "public", "local", "file", "directory"])

    $expectNewLine()
    WHILE TRUE
      token = $in.getToken()
      Token saveLastSep = $lastSep  # remember for below
      IF token.type == TType.c_close
        $expectNewLine()
        BREAK
      }
      IF token.type != TType.id
        IF token.type == TType.eof
          token.error("unexpected EOF, unterminated ENUM")
        ELSE
          token.error("unexpected token in ENUM")
        }
        BREAK
      }

      Token peek = $in.peekToken()

      Token next = $tokenAfterSep()
      IF next.type == TType.c_close
        $expectNewLine()  # don't allow value1; value2; }
      ELSE
        $expectSep()
      }

      # A comment directly after declaration belongs to the declaration:
      # "valuename  #= comment"
      Token nextComment
      IF peek.type == TType.line_sep && peek.hasCommentFirst
        nextComment = peek
      }
      Token prevComment
      IF saveLastSep.hasComment
        prevComment = $lastSep
      }

      Zui.Declaration decl = enum.addNewItem()
      decl.setPos(token.zuiPos)
          .setName(token.value)
          .newType()
              .setType(Zui.TypeEnum.eENUMVAL)
      IF prevComment != NIL
        decl.setCommentBefore(prevComment.value)
      }
      IF nextComment != NIL
        decl.setCommentAfter(nextComment.value)
      }
    }

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eENUM_DECL)
    setStmtPos(stmt, enumToken)
    Zui.Declaration decl = stmt.newDeclaration()
    decl.setPos(enumToken.zuiPos)
        .setName(enumName)
        .newType()
            .setType(Zui.TypeEnum.eENUM)
            .setEnumDecl(enum)
            .setAttr(za)
    IF comment != NIL
      decl.setCommentBefore(comment.value)
    }

    RETURN stmt
  }

  # Extension point for toplevel statements.  Return the statement or NIL if
  # no statement was recognized.
  FUNC $extendTopStatement(Token startToken, BlockType blockType
                          ) Zui.Statement @default
    RETURN NIL
  }

  FUNC $parseStatement(Token startToken, BlockType blockType
                     ) Zui.Statement
    IF blockType.import
      startToken.notAllowedError()
    }
    Zui.Expression leadExpr
    IF startToken.type == TType.id
        || startToken.type == TType.dollar
        || startToken.type == TType.percent
        || startToken.type == TType.colon
        || startToken.type == TType.this
        || startToken.type == TType.parent
        || startToken.type == TType.i
      IF blockType.toplevel && (startToken.type == TType.this
                                       || startToken.type == TType.parent)
        startToken.error("cannot use " .. startToken.value .. " in this scope")
      }
      # Found a type/variable/module/class/enum/function name.
      $in.pushToken(startToken)
      leadExpr = $parseDotName(TRUE, :doTypespec + :doParens)
    ELSEIF startToken.type == TType.sq_open
                                         || startToken.type == TType.sq_o_open
      leadExpr = $parseList(startToken)
    ELSE
      # Must be VAR
      leadExpr = $newZuiExpr(Zui.ExprType.eID, startToken.zuiPos)
      leadExpr.setName(startToken.value)
    }

    Zui.Statement splitStmt

    IF $tokenAfterSep().type == TType.comma
      # "expr, expr = expr"
      # For "expr, type var = expr" put "type var" into splitStmt and
      # "expr, var" in itemList.
      list<Zui.Expression> itemList = NEW()
      WHILE TRUE
        list<Zui.Expression> items = $parseComma(leadExpr, 0)
        IF $isAssign($tokenAfterSep().type)
          itemList.extend(items)
          BREAK
        }

        # We have "expr, type" in items, " var" is following. Take the last
        # "type" to make "type var" into a declaration.
        leadExpr = items.remove(-1)
        itemList.extend(items)
        $expectSep()
        Zui.Statement declStmt = $parseDeclaration(leadExpr, $in.getToken(),
                                                             FALSE, FALSE)
        IF splitStmt == NIL
          splitStmt = NEW()
          splitStmt.setType(Zui.StatementType.eSPLIT)
        }
        splitStmt.addStatement(declStmt)
        leadExpr = $varExprFromDeclStmt(declStmt)
        IF $tokenAfterSep().type != TType.comma
          # Found ", type var" with no comma following, add "var" to the list.
          itemList.add(leadExpr)
          BREAK
        }
      }

      leadExpr = $newZuiExpr(Zui.ExprType.eLIST, startToken.zuiPos)
      leadExpr.setListItemList(itemList)
    }

    Zui.Statement stmt

    IF leadExpr.getType() == Zui.ExprType.eCALL
      # func(arg) or module.method(arg)
      IF blockType.toplevel
        startToken.error("cannot call a function in this scope")
      }
      $expectLineSep()

      Zui.MethodCall call = leadExpr.getMethodCall()
      stmt = NEW()
      stmt.setType(Zui.StatementType.eCALL)
          .setMethodCall(call)
      setStmtPos(stmt, startToken)
    ELSE
      Token afterSep = $tokenAfterSep()
      IF afterSep.type != TType.plusplus
                                     && afterSep.type != TType.minmin
        $expectSep()
      }
      Token token = $in.getToken()
      IF $isAssign(token.type)
        IF blockType.toplevel
          token.error("cannot do assignment in this scope")
        }
        stmt = $parseAssign(leadExpr, token)
        $expectLineSep()
      ELSEIF afterSep.type == TType.plusplus
             || afterSep.type == TType.minmin
        # "var++" or "module.something--"
        $in.pushToken(token)
        $checkNoSep()
        token = $in.getToken()
        IF blockType.toplevel
          token.error("cannot do in/decrement in this scope")
        ELSEIF leadExpr.getType() == Zui.ExprType.eID
             && (leadExpr.getName() == "dyn"
              || leadExpr.getName() == "VAR")
          token.error("cannot in/decrement dyn or VAR")
        }
        $expectLineSep()

        stmt = $makeIncDecStatement(token, leadExpr)
      ELSE
        # Can't have $Type name, %Type name or :Type name.
        IF startToken.type == TType.dollar
             || startToken.type == TType.percent
             || startToken.type == TType.colon
          startToken.error("Misplaced \(startToken.value)")
        }
        stmt = $parseDeclaration(leadExpr, token, TRUE, FALSE)

        IF stmt ISNOT %emptyStatement
            && !stmt.getDeclaration().hasInit()
            && $tokenAfterSep().type == TType.comma
          # We don't know which one of these it is yet:
          # 1. "type var, var, var"
          # 2. "type var, [type] var, [type] var = expr"
          leadExpr = $varExprFromDeclStmt(stmt)
          list<Zui.Expression> items = $parseComma(leadExpr, 0)
          splitStmt = NEW()
          splitStmt.setType(Zui.StatementType.eSPLIT)

          Token nextToken = $tokenAfterSep()
          IF $isAssign(nextToken.type) || (nextToken.type == TType.id
                                     && $in.peekToken().type != TType.line_sep)
            # It's 2. "type var, [type] var, [type] var = expr"
            # NOTE: a linebreak is not allowed between type and var, because
            # that could be:
            #      type var, var
            #      var = expr
            # instead of
            #      type var, type
            #      var = expr
            splitStmt.addStatement(stmt)

            list<Zui.Expression> itemList = NEW()
            WHILE TRUE
              IF $isAssign($tokenAfterSep().type)
                itemList.extend(items)
                leadExpr = $newZuiExpr(Zui.ExprType.eLIST, startToken.zuiPos)
                leadExpr.setListItemList(itemList)
                $expectSep()
                token = $in.getToken()
                stmt = $parseAssign(leadExpr, token)
                BREAK
              }
              IF $in.peekToken().type == TType.line_sep
                token.error("Syntax error")
                BREAK
              }
              $expectSep()

              # We have "expr, type" in items, " var" is following. Take the
              # last "type" to make "type var" into a declaration.
              leadExpr = items.remove(-1)
              itemList.extend(items)
              Zui.Statement declStmt = $parseDeclaration(leadExpr,
                                                 $in.getToken(), FALSE, FALSE)
              IF declStmt IS %emptyStatement
                BREAK
              }
              splitStmt.addStatement(declStmt)
              leadExpr = $varExprFromDeclStmt(declStmt)
              IF $tokenAfterSep().type != TType.comma
                # Found ", type var" with no comma following, add "var" to the
                # list.
                items = [leadExpr]
              ELSE
                # more items following
                items = $parseComma(leadExpr, 0)
              }
            }

          ELSE
            # It's 1. "type var, var, var".  Make a list of declaration
            # statements.
            VAR declStmt = stmt
            FOR var IN items.slice(1)  # skip the first one, it's in declStmt
              splitStmt.addStatement(stmt)
              stmt = declStmt.copy(TRUE)
              Zui.Declaration decl = stmt.getDeclaration()
              decl.setName(var.getName())
                  .setDollar(var.getDollar())
                  .setPercent(var.getPercent())
                  .setPos(var.getPos())
            }
          }
        }
        $expectNewLine()
      }
    }

    IF splitStmt != NIL
      splitStmt.addStatement(stmt)
      RETURN splitStmt
    }
    RETURN stmt
  }

  FUNC $isAssign(TType type) bool
    RETURN type == TType.assign
        || type == TType.minassign
        || type == TType.plusassign
        || type == TType.multassign
        || type == TType.divassign
        || type == TType.stringassign
  }

  # Parse "var = expr".
  # |expr| is the lhs, |token| is "=", "+=", etc.
  FUNC $parseAssign(Zui.Expression expr, Token token) Zui.Statement
    # "var = expr"
    # "var -= expr"
    # "var += expr"
    # "var *= expr"
    # "var /= expr"
    # "var ..= expr"
    # "module.something = expr"
    # "var[i] = expr"
    Zui.Assignment ass = NEW()
    SWITCH token.type
      CASE TType.minassign
           ass.setType(Zui.ExprType.eSUBTRACT)
      CASE TType.plusassign
           ass.setType(Zui.ExprType.eADD)
      CASE TType.multassign
           ass.setType(Zui.ExprType.eMULTIPLY)
      CASE TType.divassign
           ass.setType(Zui.ExprType.eDIVIDE)
      CASE TType.stringassign
           ass.setType(Zui.ExprType.eCONCAT)
    }
    $expectSep()
    Zui.Expression rhs = $parseExpr()

    IF $tokenAfterSep().type == TType.comma
      # a, b, c = b, c, a
      list<Zui.Expression> rhsList = [rhs]

      WHILE $tokenAfterSep().type == TType.comma
        $checkNoSep()
        Token commaToken = $in.getToken()  # get the comma
        IF expr.getType() != Zui.ExprType.eLIST
          commaToken.error("Misplaced comma")
          BREAK
        }
        $expectSep()
        rhsList.add($parseExpr())
      }

      rhs = $newZuiExpr(Zui.ExprType.eLIST, token.zuiPos)
      rhs.setListItemList(rhsList)

      IF expr.getType() == Zui.ExprType.eLIST
                                      && expr.sizeListItem() != rhsList.Size()
        token.error("Expected " .. expr.sizeListItem()
                                       .. " values, found " .. rhsList.Size())
      }
    }

    ass.setLhs(expr)
    ass.setRhs(rhs)

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eASSIGN)
        .setAssign(ass)
    setStmtPos(stmt, token)
    RETURN stmt
  }

  # Generate an Expression from the variable in a Declaration.
  FUNC $varExprFromDeclStmt(Zui.Statement stmt) Zui.Expression
    Zui.Expression expr = $newZuiExpr(Zui.ExprType.eID, stmt.getPos())
    Zui.Declaration decl = stmt.getDeclaration()
    expr.setName(decl.getName())
    expr.setDollar(decl.getDollar())
    expr.setPercent(decl.getPercent())
    RETURN expr
  }

  # IF expr         GENERATE_IF expr
  #   ...             ...
  # ELSEIF expr     GENERATE_ELSEIF expr
  #   ...             ...
  # ELSE            GENERATE_ELSE
  #   ...             ...
  # }               }
  #
  # Also IFNIL instead of IF expr
  FUNC $parseIf(Token startToken) Zui.Statement
    bool generate = (startToken.type == TType.generate_if)
    bool ifnil = (startToken.type == TType.ifnil)

    Zui.Condition cond = NEW()

    IF !ifnil
      $checkNoLineBreak()
      $expectSep()
      Zui.Expression condExpr = $parseExpr()
      cond.setCond(condExpr)
    }
    $expectLineSep()

    # IF block goes in cond.block
    cond.setBlock($getCodeBlock(startToken, :keepEnd))

    Zui.Statement stmt = NEW()
    stmt.setType(generate ? Zui.StatementType.eGENERATEIF
                  : ifnil ? Zui.StatementType.eIFNIL
                          : Zui.StatementType.eIF)
        .setCondition(cond)
    setStmtPos(stmt, startToken)

    # Parse zero or more ELSEIF, goes in cond.elseif.
    Token token
    WHILE TRUE
      token = $in.getToken()
      IF token.type != (generate ? TType.generate_elseif : TType.elseif)
        BREAK
      }
      $checkNoLineBreak()
      $expectSep()
      Zui.Expression elseifExpr = $parseExpr()
      $expectLineSep()
      Zui.Condition elseifCond = cond.addNewElseif()
      elseifCond.setCond(elseifExpr)
      elseifCond.setBlock($getCodeBlock(token, :keepEnd))
    }

    # Parse optional ELSE.
    IF token.type == (generate ? TType.generate_else : TType.else)
      $expectLineSep()
      cond.setElse($getCodeBlock(token, :keepEnd))
      token = $in.getToken()
    }

    IF token.type == TType.c_close
      $expectNewLine()
    ELSE
      token.error("Syntax error")
    }

    RETURN stmt
  }

  # GENERATE_ERROR expr
  FUNC $parseGenerateError(Token token) Zui.Statement
    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eGENERATEERROR)
    setStmtPos(stmt, token)

    $checkNoLineBreak()
    $expectSep()
    Zui.Expression expr = $parseExpr()
    stmt.setExpr(expr)
    $expectLineSep()

    RETURN stmt
  }

  # TRY
  #   ...
  # CATCH Exn e
  #   ...
  # ELSE
  #   ...
  # FINALLY
  #   ...
  # }
  FUNC $parseTry(Token startToken) Zui.Statement
    Token token = startToken

    Zui.TryStatement try = NEW()
    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eTRY)
        .setTry(try)
    setStmtPos(stmt, token)

    $expectLineSep()

    # Parse the TRY block.
    try.setBody($getCodeBlock(startToken, :keepEnd))

    # Parse a sequence of CATCH blocks
    WHILE TRUE
      token = $in.getToken()
      IF token.type != TType.catch
        BREAK
      }
      Zui.Catch catch = try.addNewCatch()
      catch.setPos(token.zuiPos)
      $checkNoLineBreak()
      $expectSep()

      # E.Exit, E.Interrupt e
      list<Zui.Type> types = NEW()
      $parseTypeList(types, FALSE)
      catch.setTypeList(types)

      $expectSep()
      token = $in.getToken()
      IF token.type != TType.id
        token.error("Expected a name for the exception")
      }
      Zui.Declaration decl = NEW()
      decl.setName(token.value)
      decl.setPos(token.zuiPos)
      catch.setDecl(decl)
      $expectLineSep()

      # Parse the CATCH block.  Also add the block when it's empty, it means
      # the exception is ignored.
      catch.setBody($getCodeBlock(token, :keepEnd))
    }

    # Parse the optional ELSE
    IF token.type == TType.else
      # Append the ELSE at the end of the TRY block.
      $expectLineSep()

      # Parse the ELSE block.
      Zui.CodeBlock tryElse = $getCodeBlock(token, :keepEnd)

      Zui.Statement elseStmt = NEW()
      elseStmt.setType(Zui.StatementType.eTRYELSE)
              .setBlock(tryElse)
              .setTry(try)  # link to the TryStatement
      setStmtPos(elseStmt, token)
      try.getBody().addStatement(elseStmt)
      try.setElse(tryElse)

      token = $in.getToken()
    }

    # Parse the optional FINALLY
    IF token.type == TType.finally
      $expectLineSep()

      # Parse the FINALLY block.
      Zui.CodeBlock tryFinally = $getCodeBlock(token, :keepEnd)
      IF tryFinally.hasStatement()
        try.setFinally(tryFinally)
      }

      token = $in.getToken()
    }

    IF token.type == TType.c_close
      $expectNewLine()
    ELSE
      token.error("Syntax error")
      $in.pushToken(token)
    }

    RETURN stmt
  }

  FUNC $getCodeBlock(Token token, BlockType blockType
                   ) Zui.CodeBlock
    Zui.CodeBlock block = NEW()
    list<Zui.Statement> stmts = $parseBlock(blockType)
    IF stmts.Size() > 0
      block.setStatementList(stmts)
      block.setPos(stmts[0].getPos())
    ELSE
      block.setPos(token.zuiPos)
    }
    block.setEndPos($in.peekToken().zuiPos)
    RETURN block
  }

  # WHILE expr
  #   ...
  # }
  FUNC $parseWhile(Token startToken) Zui.Statement
    $expectSep()
    Zui.Expression condExpr = $parseExpr()
    Zui.Condition cond = NEW()
    cond.setCond(condExpr)

    $expectLineSep()
    Zui.CodeBlock block = $getCodeBlock(startToken, 0)
    IF block.hasStatement()
      cond.setBlock(block)
    }

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eWHILE)
        .setCondition(cond)
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  # DO
  #   ...
  # UNTIL expr
  FUNC $parseDo(Token startToken) Zui.Statement
    $expectLineSep()

    list<Zui.Statement> stmts = $parseBlock(:keepEnd)

    Token token = $in.getToken()
    IF token.type != TType.until
      token.error("Missing UNTIL")
    ELSE
      # The UNTIL goes at the end of the block, so that variables declared
      # inside the block can be accessed.
      $expectSep()
      Zui.Expression condExpr = $parseExpr()
      $expectNewLine()

      Zui.Condition cond = NEW()
      cond.setCond(condExpr)

      Zui.Statement stmt = NEW()
      stmt.setType(Zui.StatementType.eUNTIL)
          .setCondition(cond)
      setStmtPos(stmt, token)
      stmts.add(stmt)
    }

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eDO)
    setStmtPos(stmt, startToken)

    Zui.Condition cond = stmt.newCondition()
    cond.newBlock().setPos(stmt.getPos())
    IF stmts.Size() > 0
      cond.getBlock()
          .setPos(stmts[0].getPos())
          .setStatementList(stmts)
    }
    cond.getBlock().setEndPos(token.zuiPos)

    RETURN stmt
  }

  # FOR i IN expr
  #   block
  # }
  FUNC $parseFor(Token startToken) Zui.Statement
    Zui.ForStatement for = NEW()

    # Get the loop variables: comma separated list of "USE i" and "i".
    WHILE TRUE
      Zui.Declaration loopVar = NEW()

      $expectSep()
      Token token = $in.peekToken()
      IF token.type == TType.use
        loopVar.setIsUse(TRUE)
        $in.getToken()
        $expectSep()
      }

      Zui.Expression leftExpr = $parseDotName(TRUE, 0)
      string name
      IF leftExpr.getType() == Zui.ExprType.eID
        name = leftExpr.getName()
      ELSE
        # TODO: "USE some.member" should work.
        token.error("Sorry, only name supported for FOR loop variable")
        name = "unknown"
      }
      loopVar.setName(name)
      loopVar.setPos(leftExpr.getPos())
      $setPrefixFromExpr(loopVar, leftExpr)
      for.addLoopVar(loopVar)

      IF $tokenAfterSep().type != TType.comma
        BREAK
      }
      $checkNoSep()
      $in.getToken()  # eat the comma
    }

    $expectSep()
    Token token = $in.getToken()
    IF token.type != TType.in
      token.error("Missing IN")
    }
    $expectSep()
    Zui.Expression expr = $parseExpr()
    for.addIter(expr)

    token = $tokenAfterSep()
    IF token.type == TType.to || token.type == TType.until
      IF for.sizeLoopVar() > 1
        token.error("Cannot use TO or UNTIL with more than one variable")
      }

      # FOR i IN 1 TO 100
      # FOR i IN 0 UNTIL 100
      $expectSep()
      $in.getToken()  # TO or UNTIL
      $expectSep()
      Zui.Expression toExpr = $parseExpr()
      IF token.type == TType.to
        for.setTo(toExpr)
      ELSE
        for.setUntil(toExpr)
      }

      token = $tokenAfterSep()
      IF token.type == TType.step
        # FOR i IN 1 TO 100 STEP -1
        $expectSep()
        $in.getToken()  # STEP
        $expectSep()
        Zui.Expression stepExpr = $parseExpr()
        for.setStep(stepExpr)
      }
    ELSE
      WHILE token.type == TType.comma
        # FOR i1, i2 IN iter1, iter2
        $checkNoSep()
        $in.getToken()  # eat the comma
        $expectSep()
        expr = $parseExpr()
        for.addIter(expr)
        token = $tokenAfterSep()
      }
    }

    $expectLineSep()
    list<Zui.Statement> stmts = $parseBlock(0)
    IF stmts.Size() > 0
      for.newBody()
          .setPos(stmts[0].getPos())
          .setStatementList(stmts)
          .setEndPos($in.peekToken().zuiPos)
    }

    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eFOR)
        .setFor(for)
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  # RETURN [expr]
  # EXIT {expr}
  # THROW {expr}
  # DEFER method(arg)
  FUNC $parseReturnExitThrowDefer(Token startToken) Zui.Statement
    Zui.Statement stmt = NEW()
    SWITCH startToken.type
      CASE TType.return
           stmt.setType(Zui.StatementType.eRETURN)
      CASE TType.exit
           stmt.setType(Zui.StatementType.eEXIT)
      CASE TType.throw
           stmt.setType(Zui.StatementType.eTHROW)
      CASE TType.defer
           stmt.setType(Zui.StatementType.eDEFER)
    }
    Token next = $in.getToken()
    $in.pushToken(next)
    $skipSep()
    Zui.Expression arg
    IF startToken.type == TType.return
      VAR argList = $parseComma(NIL, 0)
      IF argList.Size() > 0
        arg = argList[0]
        stmt.setArgumentsList(argList)
      ELSE
        arg = $newZuiExpr(Zui.ExprType.eUNKNOWN, startToken.zuiPos)
      }
    ELSE
      arg = $parseExpr()
    }
    IF arg.getType() != Zui.ExprType.eUNKNOWN
                                       || next.type != TType.line_sep
      # There must be a line separator when there is an argument.  When
      # there is no argument check for a line break when there wasn't one
      # before looking for the argument to generate an error.
      $expectLineSep()
    }

    IF arg.getType() != Zui.ExprType.eUNKNOWN
      stmt.setExpr(arg)
    }
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  # BREAK
  # CONTINUE
  FUNC $parseBreakContinue(Token startToken) Zui.Statement
    bool isBreak = startToken.type == TType.break
    $expectLineSep()

    Zui.Statement stmt = NEW()
    stmt.setType(isBreak ? Zui.StatementType.eBREAK
                                                : Zui.StatementType.eCONTINUE)
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  # SWITCH expr
  #   CASE expr
  #   ...
  #   DEFAULT
  #   ...
  # }
  FUNC $parseSwitch(Token startToken) Zui.Statement
    $skipSep()
    Zui.Expression condExpr = $parseExpr()
    Zui.Condition cond = NEW()
    cond.setCond(condExpr)

    $expectLineSep()

    list<Zui.Statement> stmts = NEW()
    Zui.Statement stmt
    bool hadDefault
    Token token
    WHILE TRUE
      token = $in.getToken()
      IF token.type == TType.case || token.type == TType.match
        # CASE expr
        # MATCH expr
        IF hadDefault
          token.error("\(token.value.toUpper()) after DEFAULT")
        }
        $skipSep()
        Zui.Expression caseExpr = $parseExpr()
        $expectLineSep()

        stmt = NEW()
        stmt.setType(token.type == TType.case ? Zui.StatementType.eCASE
                                              : Zui.StatementType.eMATCH)
            .setExpr(caseExpr)
        setStmtPos(stmt, token)
        stmts.add(stmt)
      ELSEIF token.type == TType.default
        # DEFAULT
        IF hadDefault
          token.error("Duplicate DEFAULT")
        }
        IF stmt != NIL
          token.error("DEFAULT follows CASE or MATCH")
        }
        hadDefault = TRUE
        $expectLineSep()

        stmt = NEW()
        stmt.setType(Zui.StatementType.eDEFAULT)
        setStmtPos(stmt, token)
        stmts.add(stmt)

      ELSEIF token.type == TType.c_close
          || token.type == TType.eof
        BREAK
      ELSE
        IF stmt == NIL
          token.error("Unexpected item in SWITCH")
        }
        $in.pushToken(token)
        Zui.CodeBlock block = $getCodeBlock(token, :keepEnd)
        IF block.hasStatement() && stmt != NIL
          stmt.setBlock(block)
        }

        token = $tokenAfterSep()
        IF token.type == TType.proceed
          token = $in.getToken()
          $expectLineSep()
          IF stmt != NIL
            stmt.setProceedPos(token.zuiPos)
          }
        }
        stmt = NIL
      }
    }
    IF stmts.Size() > 0
      cond.newBlock()
          .setStatementList(stmts)
          .setEndPos(token.zuiPos)
    }

    stmt = NEW()
    stmt.setType(Zui.StatementType.eSWITCH)
        .setCondition(cond)
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  # NEW(args) as a statement.
  FUNC $parseNewStatement(Token startToken) Zui.Statement
    Zui.Expression expr = $parseNew(startToken)

    Zui.MethodCall method = expr.getMethodCall()
    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eNEWCALL)
        .setMethodCall(method)
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  # {
  #   ...
  # }
  FUNC $parseBlockStatement(Token startToken) Zui.Statement
    $expectLineSep()
    Zui.CodeBlock block = $getCodeBlock(startToken, 0)
    Zui.Statement stmt = NEW()
    stmt.setType(Zui.StatementType.eBLOCK)
        .setBlock(block)
    setStmtPos(stmt, startToken)

    RETURN stmt
  }

  # Parse arguments for a method declaration: "type name, type name".
  # Also find "type ... name" at the end.
  # When isLambda is TRUE parse arguments for a lambda expression or method:
  # "name, USE name, GET name".
  # Stop when |end_token| is found.
  # Add the arguments to |method|.
  PROC $parseArgDecl(Zui.MethodType method, bool isLambda, TType end_token)
    bool didFirst
    bool foundUse
    bool foundDefault
    bool gotThreeDots

    # Parse the arguments: "type name".
    # Loop until we find the end_token.
    $skipLineSep()
    WHILE TRUE
      Token token = $in.getToken()
      IF token.type == end_token
        BREAK
      }
      IF !didFirst
        # first argument
        didFirst = TRUE
        $in.pushToken(token)
      ELSEIF $in.peekToken().type == TType.use
        # Found USE after argument: "(type arg USE x)".  No comma.
        $in.pushToken(token)
        $expectSep()
      ELSE
        # second or later argument
        IF token.type != TType.comma
          token.error("missing comma")
        }
        $expectSep()
        IF $in.peekToken().type == TType.use
          token.error("superfluous comma before USE")
        }
      }
      IF $tokenAfterSep().type == end_token
        token.error("superfluous comma")
        token = $in.getToken()
        IF token.type != end_token
          token = $in.getToken()
        }
        BREAK
      }
      IF gotThreeDots
        token.error("Cannot have another argument after a varargs argument")
      }

      TType ttype = TType.id
      Zui.Type type = NEW()
      type.setPos(token.zuiPos)
      IF foundUse
        # Second name: "USE x, &y"
        type.setType(Zui.TypeEnum.eUSE)
      ELSE
        token = $in.peekToken()
        IF token.type == TType.use
          # USE id
          $in.getToken()
          type.setType(Zui.TypeEnum.eUSE)
          foundUse = TRUE
          $expectSep()
        ELSEIF isLambda
          type.setType(Zui.TypeEnum.eUSE)
        ELSE
          # get the type
          Zui.Expression typeExpr = $parseDotName(FALSE, :doTypespec)
          $typeUsed(typeExpr)
          type.setType(Zui.TypeEnum.eNAME)
              .setName(typeExpr)

          # If we get a ) or comma the type is missing.
          token = $in.getToken()
          IF token.type == end_token || token.type == TType.comma
            token.error("Missing type or name")
          }
          $in.pushToken(token)
          $expectSep()
        }
      }

      token = $in.getToken()
      IF token.type == TType.threeDots
        # type ... name
        gotThreeDots = TRUE
        $expectSep()
        token = $in.getToken()
      }

      # get optional '&' and the argument name
      IF token.type == TType.amp
        $checkNoSep()
        token = $in.getToken()

        IF foundUse
          type.setType(Zui.TypeEnum.eREF)
        ELSE
          Zui.Type t = NEW()
             .setType(Zui.TypeEnum.eREF)
             .setRef(type)
          type = t
          type.setPos(token.zuiPos)
        }
      }

      IF foundUse
        # After USE can come an expression: "USE Mod.var"
        # Also allowed: "USE $var"
        $in.pushToken(token)
        Zui.Expression nameExpr = $parseDotName(TRUE, 0)
        Zui.Declaration d = method.addNewUse()
            .setDotName(nameExpr)
            .setPos(token.zuiPos)
            .setIsArg(TRUE)
            .setType(type)
        $setPrefixFromExpr(d, nameExpr)

        token = $tokenAfterSep()
        IF token.type == TType.as
          token = $getAs()
          d.setName(token.value)
        }
      ELSE
        IF token.type != TType.id
          token.error("Expected argument name; missing )?")
          BREAK
        }

        Zui.Declaration d = method.addNewArgument()
        d.setName(token.value)
            .setPos(token.zuiPos)
            .setIsArg(TRUE)
            .setThreeDots(gotThreeDots)
            .setType(type)

        IF $tokenAfterSep().type == TType.assign
          # argument with a default value: "type arg = value"
          $expectSep()
          $in.getToken()
          $expectSep()
          d.setInit($parseExpr())
          foundDefault = TRUE
        ELSEIF foundDefault
          $error("Expected default value")
        }
      }

      IF foundDefault && gotThreeDots
        $error("Cannot have both varargs and optional arguments")
      }

      # A comma must be right after the name, but the ) may come after a
      # line break.
      token = $tokenAfterSep()
      IF token.type == TType.gives
        # There must be white space between the argument and "=>"
        $expectSep()
      }
      IF token.type != TType.comma && token.type != TType.use
        $skipLineSep()
      }
    }
  }

  PROC $setPrefixFromExpr(Zui.Declaration d, Zui.Expression expr)
    d.setDollar($exprHasDollar(expr))
    d.setPercent($exprHasPercent(expr))
  }

  # Parse attributes in the form @attr.
  # |accepted| is the list of possible attribute names.
  PROC $parseAttr(Zui.Attributes za, bool requireSep, list<string> accepted)
    bool needSep = requireSep
    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type != TType.at
        BREAK
      }
      IF needSep
        $expectSep()
      ELSE
        $checkNoSep()
        needSep = TRUE  # must have separator if another @ follows
      }
      token = $in.getToken()  # get the @ token
      token = $in.getToken()
      IF token.type != TType.id
        token.error("Expected attribute name")
        BREAK
      }
      string attrName = token.value
      string attrValue
      token = $in.getToken()
      IF token.type == TType.assign
        token = $in.getToken()
        # TODO: get dot name
        attrValue = token.value
      ELSE
        $in.pushToken(token)
      }
      $checkAttrAccepted(token, attrName, accepted)

      IF attrName == "backtrace"
        IF attrValue == NIL
          token.error("missing =no or =yes after @backtrace")
        ELSEIF attrValue == "no"
          $attrUsedTwice(za.getNoBacktrace() || za.getWantBacktrace(),
                                                              token, attrName)
          za.setNoBacktrace(TRUE)
        ELSEIF attrValue == "yes"
          $attrUsedTwice(za.getNoBacktrace() || za.getWantBacktrace(),
                                                              token, attrName)
          za.setWantBacktrace(TRUE)
        ELSE
          token.error("expected =no or =yes after @backtrace")
        }
      ELSEIF attrName == "read" || attrName == "items"
        # E.g., @read=public or @items=public
        IF attrValue == NIL
          token.error("missing = after @" .. attrName)
        ELSE
          Visibility vis = name2visibility.get(attrValue, Visibility.unset)
          Zui.Visibility zavis = name2zuiVisibility.get(attrValue,
                                                        Zui.Visibility.eUNSET)

          IF vis == Visibility.unset
            token.error("invalid value for @" .. attrName .. "=")
          }
          IF attrName == "read"
            $attrUsedTwice(za.hasReadVisibility(), token, "read")
            za.setReadVisibility(zavis)
          ELSE
            $attrUsedTwice(za.hasItemsVisibility(), token, "items")
            za.setItemsVisibility(zavis)
          }
        }
      ELSE
        IF attrValue != NIL
          token.error("No value expected for this attribute")
        }
        IF attrName == "default"
          $attrUsedTwice(za.getIsdefault(), token, attrName)
          za.setIsdefault(TRUE)
        ELSEIF attrName == "replace"
          $attrUsedTwice(za.getReplace(), token, attrName)
          za.setReplace(TRUE)
        ELSEIF attrName == "define"
          $attrUsedTwice(za.getDefine(), token, attrName)
          za.setDefine(TRUE)
        ELSEIF attrName == "abstract"
          $attrUsedTwice(za.getAbstract(), token, attrName)
          za.setAbstract(TRUE)
        ELSEIF attrName == "earlyInit"
          $attrUsedTwice(za.getEarlyInit(), token, attrName)
          za.setEarlyInit(TRUE)
        ELSEIF attrName == "primitive"
          $attrUsedTwice(za.getPrimitive(), token, attrName)
          za.setPrimitive(TRUE)
        ELSEIF attrName == "testOnly"
          $attrUsedTwice(za.getTestOnly(), token, attrName)
          za.setTestOnly(TRUE)
        ELSEIF attrName == "notOnExit"
          $attrUsedTwice(za.getNotOnExit(), token, attrName)
          za.setNotOnExit(TRUE)
        ELSEIF attrName == "final"
          $attrUsedTwice(za.getFinal(), token, attrName)
          za.setFinal(TRUE)
        ELSEIF attrName == "javascript"
          $attrUsedTwice(za.getJavascript(), token, attrName)
          za.setJavascript(TRUE)
        ELSE
          Zui.Visibility v = name2zuiVisibility.get(attrName,
                                                        Zui.Visibility.eUNSET)
          IF v != Zui.Visibility.eUNSET
            $visAttrSet(za.hasVisibility(), token, attrName)
            za.setVisibility(v)
          ELSE
            token.error("Unsupported attribute: " .. attrName)
          }
        }
      }
    }
  }

  SHARED
    dict<string, Visibility> name2visibility = [
        "private": Visibility.private,
        "protected": Visibility.protected,
        "public": Visibility.public,
        "file": Visibility.file,
        "directory": Visibility.directory]

    dict<string, Zui.Visibility> name2zuiVisibility = [
        "private": Zui.Visibility.ePRIVATE,
        "protected": Zui.Visibility.ePROTECTED,
        "public": Zui.Visibility.ePUBLIC,
        "local": Zui.Visibility.eLOCAL,
        "file": Zui.Visibility.eFILE,
        "directory": Zui.Visibility.eDIRECTORY]
  }

  # Check if "value" was already set, if so then give an error for an
  # attribute appearing twice.
  PROC $checkAttrAccepted(Token token, string name, list<string> accepted)
    FOR n IN accepted
      IF n == name
        RETURN
      }
    }
    token.error("Attribute not allowed here: @" .. name)
  }

  # Check if "value" is TRUE, if so then give an error for an
  # attribute appearing twice.
  PROC $attrUsedTwice(bool value, Token token, string name)
    IF value
      token.error("Attribute used twice: @" .. name)
    }
  }

  # Check if "value" was already set, if so then give an error for a
  # visibility attribute appearing twice.
  PROC $visAttrSet(bool isSet, Token token, string name)
    IF isSet
      token.error("Visibility set a second time: @" .. name)
    }
  }

  # Expression returned when there is nothing.
  Zui.Expression $unknown = $newZuiExpr(Zui.ExprType.eUNKNOWN, NEW())


  #
  # Toplevel expression parser.
  #
  FUNC $parseExpr() Zui.Expression
    RETURN $parseExprIfnil()
  }

  #
  # Evaluate "expr_alt" ?: "expr_ifnil"
  #
  FUNC $parseExprIfnil() Zui.Expression
    Zui.Expression expr = $parseExprAlt()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    IF $tokenAfterSep().type == TType.colonnil
      $expectSep()
      Token token = $in.getToken()
      $expectSep()

      Zui.Expression e = $newZuiExpr(Zui.ExprType.eIFNIL, token.zuiPos)
      e.setLeft(expr)
      expr = e

      e = $parseExprIfnil()
      expr.setRight(e)
    }
    RETURN expr
  }

  #
  # Evaluate "expr_or ? expr_alt : expr_alt"
  #
  FUNC $parseExprAlt() Zui.Expression
    Zui.Expression expr = $parseExprOr()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    Token token = $tokenAfterSep()
    IF token.type == TType.question
      $expectSep()
      token = $in.getToken()
      $expectSep()

      Zui.Expression e = $newZuiExpr(Zui.ExprType.eTERNARY, token.zuiPos)
      e.setCond(expr)
      expr = e

      e = $parseExprAlt()
      expr.setLeft(e)

      $expectSep()
      token = $in.getToken()
      IF token.type != TType.colon
        token.error("Missing ':' after '?'")
        $in.pushToken(token)
      ELSE
        $expectSep()
        e = $parseExprAlt()
        expr.setRight(e)
      }
    }
    RETURN expr
  }

  #
  # Evaluate "expr_and || expr_and || expr_and"
  #
  FUNC $parseExprOr() Zui.Expression
    Zui.Expression expr = $parseExprAnd()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type != TType.or
        BREAK
      }
      $expectSep()
      token = $in.getToken()
      $expectSep()

      Zui.Expression e = $newZuiExpr(Zui.ExprType.eOR, token.zuiPos)
      e.setLeft(expr)
      expr = e

      e = $parseExprAnd()
      expr.setRight(e)
    }
    RETURN expr
  }

  #
  # Evaluate "expr_comp && expr_comp && expr_comp"
  #
  FUNC $parseExprAnd() Zui.Expression
    Zui.Expression expr = $parseExprComp()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type != TType.and
        BREAK
      }
      $expectSep()
      token = $in.getToken()
      $expectSep()

      Zui.Expression e = $newZuiExpr(Zui.ExprType.eAND, token.zuiPos)
      e.setLeft(expr)
      expr = e

      e = $parseExprComp()
      expr.setRight(e)
    }
    RETURN expr
  }

  #
  # Evaluate "expr_concat COMPARE expr_concat" (==, !=, =~, etc.)
  #
  FUNC $parseExprComp() Zui.Expression
    Zui.Expression expr = $parseExprConcat()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type == TType.assign
        BREAK
      }
      IF token.type != TType.equal
          && token.type != TType.equalIc
          && token.type != TType.notequal
          && token.type != TType.notequalIc
          && token.type != TType.gt
          && token.type != TType.gte
          && token.type != TType.lt
          && token.type != TType.lte
          && token.type != TType.is
          && token.type != TType.isnot
          && token.type != TType.isa
          && token.type != TType.isnota
          && token.type != TType.reMatch
          && token.type != TType.reMatchIc
          && token.type != TType.noReMatch
          && token.type != TType.noReMatchIc
        BREAK
      }
      bool typeSpec
      Token first = $in.getToken()
      IF first.type == TType.lt
        # typeSpec is written as "expr<"
        typeSpec = TRUE
        token = first
      ELSE
        # smaller-than is written as "expr <"
        $in.pushToken(first)
        $expectSep()
        token = $in.getToken()
      }
      IF typeSpec
        $skipSep()
      ELSE
        $expectSep()
      }

      Z.Pos pos = $in.input.pos.copy()
      Zui.Expression e = NEW()
      SWITCH token.type
        CASE TType.equal
            e.setType(Zui.ExprType.eEQUAL)
        CASE TType.equalIc
            e.setType(Zui.ExprType.eEQUALIC)
        CASE TType.notequal
            e.setType(Zui.ExprType.eNOTEQUAL)
        CASE TType.notequalIc
            e.setType(Zui.ExprType.eNOTEQUALIC)
        CASE TType.gt
            e.setType(Zui.ExprType.eGREATER)
        CASE TType.gte
            e.setType(Zui.ExprType.eGREATER_EQUAL)
        CASE TType.lt
            IF typeSpec
              e.setType(Zui.ExprType.eTYPESPEC)
            ELSE
              e.setType(Zui.ExprType.eLESS)
            }
        CASE TType.lte
            e.setType(Zui.ExprType.eLESS_EQUAL)
        CASE TType.is
            e.setType(Zui.ExprType.eIS)
        CASE TType.isnot
            e.setType(Zui.ExprType.eISNOT)
        CASE TType.isa
            e.setType(Zui.ExprType.eISA)
        CASE TType.isnota
            e.setType(Zui.ExprType.eISNOTA)
        CASE TType.reMatch
            e.setType(Zui.ExprType.eMATCH)
        CASE TType.reMatchIc
            e.setType(Zui.ExprType.eMATCHIC)
        CASE TType.noReMatch
            e.setType(Zui.ExprType.eNOMATCH)
        CASE TType.noReMatchIc
            e.setType(Zui.ExprType.eNOMATCHIC)
      }

      e.setLeft(expr)
      e.setPos(token.zuiPos)

      IF typeSpec
        bool hasOp
        IF expr.getType() != Zui.ExprType.eID
              && expr.getType() != Zui.ExprType.eMEMBER
              && expr.hasLeft()
              && expr.hasRight()
          # Turn "(left OP right) <type>" into "left OP (right<type>)"
          e.setLeft(expr.getRight())
          hasOp = TRUE
        }

        list<Zui.Type> types = NEW()
        $parseTypeSpec(types, FALSE)
        e.setTypespecList(types)

        # Now check for what follows: list<string>.NEW()...
        e = $parseMembers(e, :doParens)

        IF hasOp
          expr.setRight(e)
        ELSE
          expr = e
        }
      ELSE
        expr = e
        e = $parseExprConcat()
        expr.setRight(e)
      }
    }
    RETURN expr
  }

  #
  # Evaluate "expr_bitwise .. expr_bitwise": string concatenation
  #
  FUNC $parseExprConcat() Zui.Expression
    Zui.Expression expr = $parseExprBitwise()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type != TType.concat
        BREAK
      }
      $expectSep()
      token = $in.getToken()
      $expectSep()

      Zui.Expression e = $newZuiExpr(Zui.ExprType.eCONCAT, token.zuiPos)
      e.setLeft(expr)
      expr = e

      expr.setRight($parseExprBitwise())
    }
    RETURN expr
  }

  #
  # Evaluate "expr_shift OP expr_shift"  (&, |, ^)
  #
  FUNC $parseExprBitwise() Zui.Expression
    Zui.Expression expr = $parseExprShift()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type != TType.amp
          && token.type != TType.bit_or
          && token.type != TType.bit_xor
        BREAK
      }
      $expectSep()
      token = $in.getToken()
      $expectSep()

      Zui.Expression right = $parseExprShift()

      IF (expr.getType() == Zui.ExprType.eINT
                                       || expr.getType() == Zui.ExprType.eNAT)
         && (right.getType() == Zui.ExprType.eINT
                                      || right.getType() == Zui.ExprType.eNAT)
        # nr OP nr: compute the result.
        int val
        IF token.type == TType.amp
          val = expr.getNumber() & right.getNumber()
        ELSEIF token.type == TType.bit_or
          val = expr.getNumber() | right.getNumber()
        ELSE
          val = expr.getNumber() ^ right.getNumber()
        }
        expr.setNumber(val)
      ELSE
        Zui.Expression e = NEW()
        IF token.type == TType.amp
          e.setType(Zui.ExprType.eBIT_AND)
        ELSEIF token.type == TType.bit_or
          e.setType(Zui.ExprType.eBIT_OR)
        ELSE
          e.setType(Zui.ExprType.eBIT_XOR)
        }
        e.setLeft(expr)
        e.setRight(right)
        e.setPos(token.zuiPos)
        expr = e
      }
    }
    RETURN expr
  }

  #
  # Evaluate "expr_incr OP expr_incr" (<<, >>)
  #
  FUNC $parseExprShift() Zui.Expression
    Zui.Expression expr = $parseExprPlus()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type != TType.lshift && token.type != TType.rshift
        BREAK
      }
      $expectSep()
      token = $in.getToken()
      $expectSep()

      Zui.Expression right = $parseExprPlus()

      IF (expr.getType() == Zui.ExprType.eINT
                                       || expr.getType() == Zui.ExprType.eNAT)
         && (right.getType() == Zui.ExprType.eINT
                                      || right.getType() == Zui.ExprType.eNAT)
        # nr OP nr: compute the result.
        int val
        IF token.type == TType.lshift
          val = expr.getNumber() << right.getNumber()
        ELSE
          val = expr.getNumber() >> right.getNumber()
        }
        expr.setNumber(val)
      ELSE
        Zui.Expression e = NEW()
        IF token.type == TType.lshift
          e.setType(Zui.ExprType.eSHIFT_LEFT)
        ELSE
          e.setType(Zui.ExprType.eSHIFT_RIGHT)
        }
        e.setLeft(expr)
        e.setRight(right)
        e.setPos(token.zuiPos)
        expr = e
      }
    }
    RETURN expr
  }

  #
  # Evaluate "expr_incr OP expr_incr" (+, -)
  #
  FUNC $parseExprPlus() Zui.Expression
    Zui.Expression expr = $parseExprMult()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type != TType.plus && token.type != TType.minus
        BREAK
      }
      $expectSep()
      token = $in.getToken()  # get the + or -
      $expectSep()

      Zui.Expression right = $parseExprMult()

      IF (expr.getType() == Zui.ExprType.eINT
                                       || expr.getType() == Zui.ExprType.eNAT)
         && (right.getType() == Zui.ExprType.eINT
                                      || right.getType() == Zui.ExprType.eNAT)
        # int OP int: compute the int result.
        int val
        IF token.type == TType.plus
          val = expr.getNumber() + right.getNumber()
        ELSE
          val = expr.getNumber() - right.getNumber()
        }
        expr.setNumber(val)
      ELSEIF (expr.getType() == Zui.ExprType.eINT
           || expr.getType() == Zui.ExprType.eNAT
           || expr.getType() == Zui.ExprType.eFLOAT)
         && (right.getType() == Zui.ExprType.eINT
          || right.getType() == Zui.ExprType.eNAT
          || right.getType() == Zui.ExprType.eFLOAT)
        # int/float OP int/float: compute the float result.
        float lval
        IF expr.getType() == Zui.ExprType.eINT
                                        || expr.getType() == Zui.ExprType.eNAT
          lval = expr.getNumber()
        ELSE
          lval = expr.getFnumber()
        }
        float rval
        IF right.getType() == Zui.ExprType.eINT
                                       || right.getType() == Zui.ExprType.eNAT
          rval = right.getNumber()
        ELSE
          rval = right.getFnumber()
        }
        IF token.type == TType.plus
          lval += rval
        ELSE
          lval -= rval
        }
        expr.setFnumber(lval)
        expr.setType(Zui.ExprType.eFLOAT)
      ELSE
        Zui.Expression e = NEW()
        IF token.type == TType.plus
          e.setType(Zui.ExprType.eADD)
        ELSE
          e.setType(Zui.ExprType.eSUBTRACT)
        }
        e.setLeft(expr)
        e.setRight(right)
        e.setPos(token.zuiPos)
        expr = e
      }
    }
    RETURN expr
  }

  #
  # Evaluate "expr_incdec OP expr_incdec" (*, /, %)
  #
  FUNC $parseExprMult() Zui.Expression
    Zui.Expression expr = $parseExprIndecr()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    WHILE TRUE
      Token token = $tokenAfterSep()
      IF token.type != TType.star
          && token.type != TType.slash
          && token.type != TType.percent
        BREAK
      }
      IF token.type == TType.percent
        # % is not an operator when used as %var
        Token next
        token, next = $twoTokensAfterSep()
        IF !next.isSep()
          BREAK
        }
      }
      $expectSep()
      token = $in.getToken()  # get the *, / or %
      $expectSep()

      Zui.Expression right = $parseExprIndecr()

      IF (expr.getType() == Zui.ExprType.eINT
                                       || expr.getType() == Zui.ExprType.eNAT)
         && (right.getType() == Zui.ExprType.eINT
                                      || right.getType() == Zui.ExprType.eNAT)
        # int OP int: compute the int result.
        int val
        IF token.type == TType.star
          val = expr.getNumber() * right.getNumber()
        ELSE
          IF right.getNumber() == 0
            token.error("Divide by zero")
            val = 0
          ELSEIF token.type == TType.slash
            val = expr.getNumber() / right.getNumber()
          ELSE
            val = expr.getNumber() % right.getNumber()
          }
        }
        expr.setNumber(val)
      ELSEIF (expr.getType() == Zui.ExprType.eINT
           || expr.getType() == Zui.ExprType.eNAT
           || expr.getType() == Zui.ExprType.eFLOAT)
         && (right.getType() == Zui.ExprType.eINT
          || right.getType() == Zui.ExprType.eNAT
          || right.getType() == Zui.ExprType.eFLOAT)
        # int/float OP int/float: compute the float result.
        float lval
        IF expr.getType() == Zui.ExprType.eINT
                                        || expr.getType() == Zui.ExprType.eNAT
          lval = expr.getNumber()
        ELSE
          lval = expr.getFnumber()
        }
        float rval
        IF right.getType() == Zui.ExprType.eINT
                                       || right.getType() == Zui.ExprType.eNAT
          rval = right.getNumber()
        ELSE
          rval = right.getFnumber()
        }
        IF token.type == TType.star
          lval = lval * rval
        ELSE
          IF rval == 0
            token.error("Divide by zero")
          ELSEIF token.type == TType.slash
            lval = lval / rval
          ELSE
            token.error("Cannot use % with float")
          }
        }
        expr.setFnumber(lval)
        expr.setType(Zui.ExprType.eFLOAT)
      ELSE
        Zui.Expression e = NEW()
        IF token.type == TType.star
          e.setType(Zui.ExprType.eMULTIPLY)
        ELSEIF token.type == TType.slash
          e.setType(Zui.ExprType.eDIVIDE)
        ELSE
          e.setType(Zui.ExprType.eREMAINDER)
        }
        e.setLeft(expr)
        e.setRight(right)
        e.setPos(token.zuiPos)
        expr = e
      }
    }

    RETURN expr
  }

  #
  # Evaluate "++expr_dot", "--expr_dot", "expr_dot++" and "expr_dot--".
  #
  FUNC $parseExprIndecr() Zui.Expression
    Token token = $in.getToken()
    Zui.Expression preExpr

    IF token.type == TType.plusplus || token.type == TType.minmin
      IF token.type == TType.plusplus
        preExpr = NEW().setType(Zui.ExprType.ePRE_INC)
      ELSE
        preExpr = NEW().setType(Zui.ExprType.ePRE_DEC)
      }
      preExpr.setPos(token.zuiPos)
    ELSE
      $in.pushToken(token)
    }

    Zui.Expression expr = $parseExprUnary()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }
    IF preExpr != NIL
      preExpr.setRight(expr)
      expr = preExpr
    }

    token = $in.getToken()
    # give an error for "x ++" here, instead of giving an error for
    # unexpected ++ much later.
    IF token.type == TType.sep
      Token next = $in.getToken()
      IF next.type == TType.plusplus
        next.error("white space before ++")
        token = next
      ELSEIF next.type == TType.minmin
        next.error("white space before --")
        token = next
      ELSE
        $in.pushToken(next)
      }
    }
    IF token.type == TType.plusplus || token.type == TType.minmin
      Zui.Expression postExpr = NEW()
      IF token.type == TType.plusplus
        postExpr.setType(Zui.ExprType.ePOST_INC)
      ELSE
        postExpr.setType(Zui.ExprType.ePOST_DEC)
      }
      postExpr.setPos(token.zuiPos)
      postExpr.setRight(expr)
      expr = postExpr
    ELSE
      $in.pushToken(token)
    }

    RETURN expr
  }

  #
  # Evaluate  -expr  and  !expr  and  ~expr  and  &expr
  #
  FUNC $parseExprUnary() Zui.Expression
    Zui.Expression expr
    Token token = $in.getToken()
    Zui.ExprType exprType = Zui.ExprType.eUNKNOWN

    IF token.type == TType.minus
        && !($in.peekToken().type == TType.id
                                         && $in.peekToken().value[0].isDigit())
      # handle -expr but not -123
      exprType = Zui.ExprType.eMINUS
    ELSEIF token.type == TType.not
      exprType = Zui.ExprType.eNOT
    ELSEIF token.type == TType.tilde
      exprType = Zui.ExprType.eTILDE
    ELSEIF token.type == TType.amp
      exprType = Zui.ExprType.eREF
    }

    IF exprType == Zui.ExprType.eUNKNOWN
      $in.pushToken(token)
      expr = $parseExprDot()
    ELSE
      Zui.Expression e = $parseExprDot()
      IF e.getType() == Zui.ExprType.eUNKNOWN
        RETURN e
      }
      expr = $newZuiExpr(exprType, token.zuiPos)
                .setRight(e)
    }

    RETURN expr
  }

  #
  # Evaluate members and methods.
  #
  FUNC $parseExprDot() Zui.Expression
    Zui.Expression expr = $parseExprParen()
    IF expr.getType() == Zui.ExprType.eUNKNOWN
      RETURN expr
    }

    # This is shared with toplevel evaluation.
    RETURN $parseMembers(expr, :doParens)
  }

  #
  # Evaluate "( expr_alt )" or "expr_base".
  #
  FUNC $parseExprParen() Zui.Expression
    Zui.Expression expr
    Token token = $in.getToken()

    IF token.type == TType.p_open
      $skipLineSep()
      Zui.Expression right = $parseExpr()
      IF right.getType() == Zui.ExprType.eUNKNOWN
        RETURN right
      }
      $skipLineSep()
      Token closeToken = $in.getToken()
      IF closeToken.type != TType.p_close
        token.error("missing matching )")
      }

      IF [Zui.ExprType.eSTRING,
          Zui.ExprType.eBYTESTRING,
          Zui.ExprType.eNIL,
          Zui.ExprType.eTHIS,
          Zui.ExprType.ePARENT,
          Zui.ExprType.eTRUE,
          Zui.ExprType.eFALSE,
          Zui.ExprType.eOK,
          Zui.ExprType.eFAIL,
          Zui.ExprType.eINT,
          Zui.ExprType.eNAT,
          Zui.ExprType.eFLOAT,
          Zui.ExprType.eID].has(right.getType())
        # There is no need to add a PARENS expression around a constant.
        expr = right
      ELSE
        expr = $newZuiExpr(Zui.ExprType.ePARENS, token.zuiPos)
        expr.setRight(right)
      }
    ELSE
      $in.pushToken(token)
      expr = $parseExprBase()
    }
    RETURN expr
  }


  #
  # Base level evaluation, recognize:
  # "string"
  # 123    number
  # -123   negative number
  # 0x12   hex number
  # 'c'    character (used as a number)
  # TRUE   boolean
  # FALSE  boolean
  # OK     status
  # FAIL   status
  # THIS   object
  # PARENT object
  # name   identifier
  # $name  identifier
  # %name  identifier
  # [item, item]  list
  # [key: value, key: value] dict
  # { arg => expr }  Lambda function
  # FUNC(arg) block  func
  # PROC(arg) block  proc
  # C(code)  C code
  #
  FUNC $parseExprBase() Zui.Expression
    Token token = $in.getToken()
    Zui.Expression expr

    SWITCH token.type
      CASE TType.stringLiteral
           IF token.byteValue != NIL
             expr = $newZuiExpr(Zui.ExprType.eBYTESTRING, token.zuiPos)
                     .setByteStringValue(token.byteValue)
           ELSE
             expr = $newZuiExpr(Zui.ExprType.eSTRING, token.zuiPos)
                     .setStringValue(token.value)
           }
      CASE TType.stringExprStart
           expr = $parseStringExpr(token)
      CASE TType.nil
           expr = $newZuiExpr(Zui.ExprType.eNIL, token.zuiPos)
      CASE TType.inf
           expr = $newZuiExpr(Zui.ExprType.eINF, token.zuiPos)
      CASE TType.ninf
           expr = $newZuiExpr(Zui.ExprType.eNINF, token.zuiPos)
      CASE TType.nan
           expr = $newZuiExpr(Zui.ExprType.eNAN, token.zuiPos)
      CASE TType.this
           expr = $newZuiExpr(Zui.ExprType.eTHIS, token.zuiPos)
      CASE TType.parent
           expr = $newZuiExpr(Zui.ExprType.ePARENT, token.zuiPos)
      CASE TType.new
           expr = $parseNew(token)
      CASE TType.re
           expr = $parseRe(token)
      CASE TType.true
           expr = $newZuiExpr(Zui.ExprType.eTRUE, token.zuiPos)
      CASE TType.false
           expr = $newZuiExpr(Zui.ExprType.eFALSE, token.zuiPos)
      CASE TType.ok
           expr = $newZuiExpr(Zui.ExprType.eOK, token.zuiPos)
      CASE TType.fail
           expr = $newZuiExpr(Zui.ExprType.eFAIL, token.zuiPos)
      CASE TType.char
           int val = token.value == NIL ? token.byteValue[0] : token.value[0]
           expr = $newZuiExpr(Zui.ExprType.eINT, token.zuiPos)
                   .setNumber(val)
      CASE TType.dollar
           expr = $parseId($in.getToken())
           IF expr.getType() == Zui.ExprType.eID
             expr.setDollar(TRUE)
           ELSE
             token.error("Misplaced $")
           }
      CASE TType.percent
           expr = $parseId($in.getToken())
           IF expr.getType() == Zui.ExprType.eID
             expr.setPercent(TRUE)
           ELSE
             token.error("Misplaced %")
           }
      CASE TType.colon
           expr = $parseId($in.getToken())
           IF expr.getType() == Zui.ExprType.eID
             expr.setColon(TRUE)
           ELSE
             token.error("Misplaced %")
           }
      CASE TType.minus
           expr = $parseId($in.getToken())
           IF expr.getType() == Zui.ExprType.eINT
             expr.setNumber(-expr.getNumber())
           ELSEIF expr.getType() == Zui.ExprType.eNAT
             # This may overflow, give an error?
             expr.setNumber(-expr.getNumber())
             expr.setType(Zui.ExprType.eINT)
           ELSEIF expr.getType() == Zui.ExprType.eFLOAT
             expr.setFnumber(-expr.getFnumber())
           ELSE
             token.error("Unexpected minus")
           }
      CASE TType.id
      CASE TType.i
           expr = $parseId(token)
      CASE TType.sq_open
      CASE TType.sq_o_open
           expr = $parseList(token)
      CASE TType.c_open
           expr = $parseCurlyExpr(token)
      CASE TType.proc
      CASE TType.func
      CASE TType.lambda
           # FUNC, PROC or LAMBDA used in an expression
           Zui.Statement stmt = $parseMethod(token, :keepEnd + :expression)
           Token t = $in.getToken()
           IF t.type != TType.c_close
             t.error("Missing }")
           }
           Zui.Declaration decl = stmt.getDeclaration()
           expr = $newZuiExpr(Zui.ExprType.eMETHOD, token.zuiPos)
                        .setDecl(decl)
      CASE TType.c
           expr = $parseCCode()

      CASE TType.semicolon
           token.error("unexpected ;")
           PROCEED
      DEFAULT
           # Didn't recognize anything, could be an empty expression in ().
           $in.pushToken(token)
           expr = $newZuiExpr(Zui.ExprType.eUNKNOWN, token.zuiPos)
    }

    RETURN expr
  }

  # Parse a string literal containing \(expr).
  # |startToken| is the the string up to the \(.
  FUNC $parseStringExpr(Token startToken) Zui.Expression
    Zui.Expression result
    Token token = startToken
    WHILE TRUE
      IF token.value != ""
        Zui.Expression sExpr = $newZuiExpr(Zui.ExprType.eSTRING,
                                     token.zuiPos).setStringValue(token.value)
        IF result == NIL
          result = sExpr
        ELSE
          Zui.Expression e = $newZuiExpr(Zui.ExprType.eCONCAT, token.zuiPos)
          e.setLeft(result)
          e.setRight(sExpr)
          result = e
        }
      }
      IF token.type != TType.stringExprStart
        BREAK
      }

      # Check for a format: \(0.2s expr)
      list<Zui.Expression> args
      IO.StringWriter w = NEW()
      bool gotSpace
      bool gotMinus
      $in.emptyStack()
      WHILE TRUE
        int c = $in.get()
        IF c == ' ' && w.Size() == 0
          # Leading space, no format.
          BREAK
        }
        w.writeChar(c)
        IF gotSpace && (c.isDigit() || c.isAlpha() || (c != ' ' && gotMinus))
          IF gotMinus
            $in.push(w.remove())  # push back "x" of "-x"
          }
          $in.push(w.remove())    # push back character after space
          w.remove()              # drop the space
          Zui.Expression arg = NEW()
              .setType(Zui.ExprType.eSTRING)
              .setStringValue(w.ToString())
          args = [arg]
          BREAK
        ELSEIF c == ' ' && !gotSpace
          gotSpace = TRUE
        ELSEIF c == '-' && gotSpace && !gotMinus
          # (foo - expr) is an expression
          # (foo -expr) is a format + expression
          gotMinus = TRUE
        ELSEIF !c.isDigit() && !c.isAlpha() && c != '-' && c != '.'
          WHILE w.Size() > 0
            $in.push(w.remove())
          }
          BREAK
        }
      }

      # Parse the expr in \(expr) and turn into expr?.ToString().
      Zui.Expression expr = $parseExpr()

      Zui.Expression methodName = NEW()
          .setType(Zui.ExprType.eMEMBER)
          .setDotnil(TRUE)
          .setPos(expr.getPos())
          .setLeft(expr)
      methodName.newRight()
           .setType(Zui.ExprType.eID)
           .setPos(token.zuiPos)
           .setName("ToString")

      Zui.MethodCall method = NEW()
      method.setPos(expr.getPos())
      IF args != NIL
        method.setArgumentList(args)
      }
      method.setName(methodName)

      Zui.Expression call = NEW()
           .setType(Zui.ExprType.eCALL)
           .setPos(expr.getPos())
           .setMethodCall(method)

      IF result == NIL
        result = call
      ELSE
        Zui.Expression e = $newZuiExpr(Zui.ExprType.eCONCAT, token.zuiPos)
        e.setLeft(result)
        e.setRight(call)
        result = e
      }

      # Allow for space before the ).
      $skipSep()
      token = $in.getToken()
      IF token.type != TType.p_close
        token.error("missing matching )")
        IF token.type == TType.stringLiteral
          # We run into the end quote, which now will start a new string.
          # Bail out.
          BREAK
        }
      }
      $in.emptyStack()
      $in.push('"')  # start of the next string part
      token = $in.getToken()
    }
    RETURN result
  }

  # Parse a lambda expression: { foo USE bar => expr }
  # OR
  # Parse an object initializer: {foo: expr, bar: expr}
  FUNC $parseCurlyExpr(Token startToken) Zui.Expression
    Token first = $in.getToken()
    Token id
    IF first.isSep()
      id = $in.getToken()
    ELSE
      id = first
      first = NIL
    }
    Token afterId = $in.peekToken()
    $in.pushToken(id)
    IF first != NIL
      $in.pushToken(first)
    }

    # object initializer: {foo: expr, bar: expr}  or {}
    IF (id.type == TType.id && afterId.type == TType.colon)
        || id.type == TType.c_close
      RETURN $parseObjectInitializer(startToken)
    }
    RETURN $parseLambdaExpr(startToken)
  }

  # Parse an object initializer: {foo: expr, bar: expr}
  FUNC $parseObjectInitializer(Token startToken) Zui.Expression
    $skipLineSep()
    Zui.Expression initExpr = $newZuiExpr(Zui.ExprType.eINIT, startToken.zuiPos)

    Token token = $in.getToken()
    WHILE token.type != TType.c_close
      IF token.type == TType.eof
        token.error("Missing }")
        startToken.error("To match this {")
        BREAK
      }
      IF token.type != TType.id
        token.error("Expected a name")
      }
      $checkNoSep()
      Token colon = $in.getToken()
      IF colon.type != TType.colon
        token.error("missing colon")
      }
      $skipSep()
      Zui.Expression val = $parseExpr()
      Zui.NameExpr item = initExpr.addNewInitItem()
      item.setName(token.value)
      item.setValue(val)

      # Skip the comma and white space.
      token = $in.getToken()
      IF token.isSep() && $in.peekToken().type == TType.comma
        token.error("unexpected white space")
        token = $in.getToken()
      }
      IF token.type == TType.comma
        $skipSep()
      ELSEIF token.type == TType.c_close
        BREAK
      ELSEIF $tokenAfterSep().type != TType.c_close
        token.error("expected a comma")
      }

      token = $in.getToken()
    }
    RETURN initExpr
  }

  # Parse a lambda expression: { foo USE bar => expr }
  FUNC $parseLambdaExpr(Token startToken) Zui.Expression
    $expectSep()

    # Parse any arguments.
    Zui.MethodType method = NEW()
    $parseArgDecl(method, TRUE, TType.gives)

    # Parse "expr", it goes in method.expr
    $expectSep()
    Zui.Expression right = $parseExpr()
    method.setExpr(right)

    # Return type is unknown, will be set while processing.

    # Check for the }
    $expectSep()
    Token token = $in.getToken()
    IF token.type != TType.c_close
      token.error("Missing }")
      startToken.error("To match this {")
    }

    Zui.Expression expr = $newZuiExpr(Zui.ExprType.eLAMBDA, startToken.zuiPos)
                              .setMethod(method)

    RETURN expr
  }

  # An id token can be a number or a name.
  FUNC $parseId(Token token) Zui.Expression
    int c = token.value[0]
    Zui.Expression expr
    IF c >= '0' && c <= '9'
      nat value
      float fvalue
      bool isFloat
      IF c == '0' && token.value.Size() > 1
                           && (token.value[1] == 'x' || token.value[1] == 'X')
        IF token.value.Size() == 2
          token.error("Missing digit after " .. token.value)
        }
        string v = token.value.slice(2)
        FOR cc IN v
          IF !cc.isHexDigit() && cc != '\'' && cc != '_'
            token.error("Non-digit after hex number: " .. token.value)
            BREAK
          }
        }
        value = v.quotedHexToInt()
      ELSEIF c == '0' && token.value.Size() > 1
                           && (token.value[1] == 'b' || token.value[1] == 'B')
        string v = token.value.slice(2)
        IF token.value.Size() == 2
          token.error("Missing digit after " .. token.value)
        }
        FOR cc IN v
          IF cc != '0' && cc != '1' && cc != '\'' && cc != '_'
            token.error("Invalid character after binary number: "
                                                               .. token.value)
            BREAK
          }
        }
        value = v.quotedBinToInt()
      ELSE
        FOR cc IN token.value
          IF cc == '.' || cc == 'e' || cc == 'E'
            isFloat = TRUE
            BREAK
          }
          IF !cc.isDigit() && cc != '\'' && cc != '_'
            token.error("Non-digit after number: " .. token.value)
            BREAK
          }
        }
        IF isFloat
          int len
          fvalue = token.value.toFloat(&len)
          IF len < token.value.Size()
            token.error("invalid number: " .. token.value)
          }
        ELSE
          value = token.value.quotedToInt()
        }
      }

      IF isFloat
        expr = $newZuiExpr(Zui.ExprType.eFLOAT, token.zuiPos)
                  .setFnumber(fvalue)
      ELSE
        # TODO: convert?
        int v = value
        expr = $newZuiExpr(Zui.ExprType.eNAT, token.zuiPos)
                  .setNumber(v)
      }
    ELSE
      expr = $newZuiExpr(Zui.ExprType.eID, token.zuiPos)
      expr.setName(token.value)
    }
    RETURN expr
  }

  # parse "foo.NEW(args)", "NEW(args)" or "NEW"
  FUNC $parseNew(Token startToken) Zui.Expression
    Token token = $in.getToken()
    Zui.Expression expr
    IF token.type != TType.p_open
      # "NEW" without (arg) can be used as a pointer to the method.
      $in.pushToken(token)

      expr = $newZuiExpr(Zui.ExprType.eID, startToken.zuiPos)
      expr.setName("NEW")
    ELSE
      $skipLineSep()
      list<Zui.Expression> args = $parseComma(NIL, :arguments)
      token = $in.getToken()
      IF token.type == TType.line_sep
        # Allow for NEW("foo"
        #              )
        token = $in.getToken()
      ELSEIF token.type == TType.sep && token.hasComment
        # Allow for  method(arg /* yes */)
        token = $in.getToken()
      }
      IF token.type != TType.p_close
        IF token.type == TType.sep
          token.error("Expected ), missing comma?")
        ELSE
          token.error("Expected ), found " .. token.type.ToString())
        }
      }

      Zui.MethodCall method = NEW()
      method.setPos(startToken.zuiPos)
      # The method has no name, eNEWCALL indicates it's NEW().

      method.setArgumentList(args)
      expr = $newZuiExpr(Zui.ExprType.eNEWCALL, startToken.zuiPos)
      expr.setMethodCall(method)
    }
    RETURN expr
  }

  # parse "RE(pattern-expr)"
  FUNC $parseRe(Token startToken) Zui.Expression
    Token token = $in.getToken()
    IF token.type != TType.p_open
      # Could be RE.Regexp.
      $in.pushToken(token)
      RETURN $parseId(startToken)
    }

    $skipLineSep()
    list<Zui.Expression> args = $parseComma(NIL, :arguments)
    token = $in.getToken()
    IF token.type == TType.line_sep
      # Allow for NEW("foo"
      #              )
      token = $in.getToken()
    ELSEIF token.type == TType.sep && token.hasComment
      # Allow for  method(arg /* yes */)
      token = $in.getToken()
    }
    IF token.type != TType.p_close
      IF token.type == TType.sep
        token.error("Expected ), missing comma?")
      ELSE
        token.error("Expected ), found " .. token.type.ToString())
      }
    }

    # Produce as RE.Regex.NEW(arg)
    Zui.Expression module = $newZuiExpr(Zui.ExprType.eMEMBER, token.zuiPos)
    module.newLeft()
            .setType(Zui.ExprType.eID)
            .setPos(token.zuiPos)
            .setName("RE")
    module.newRight()
            .setType(Zui.ExprType.eID)
            .setPos(token.zuiPos)
            .setName("Regex")

    Zui.Expression member = $newZuiExpr(Zui.ExprType.eMEMBER, token.zuiPos)
    member.newRight()
            .setType(Zui.ExprType.eID)
            .setPos(token.zuiPos)
            .setName("NEW")
    member.setLeft(module)
    Zui.MethodCall method = NEW()
    method.setPos(startToken.zuiPos)
    method.setName(member)

    method.setArgumentList(args)
    Zui.Expression expr = $newZuiExpr(Zui.ExprType.eCALL, startToken.zuiPos)
    expr.setMethodCall(method)

    $in.usedIdKeywords.set("RE")
    RETURN expr
  }

  # Parse [item, item] or [key: value, key: value] or [:]
  FUNC $parseList(Token startToken) Zui.Expression
    bool isL = startToken.type == TType.sq_o_open

    # [:] is an empty dictionary
    Token token = $tokenAfterSep()
    IF token.type == TType.colon
      token = $in.getToken()
      bool wrong
      IF token.type != TType.colon
        wrong = TRUE
        token = $in.getToken()
      }
      token = $in.peekToken()
      IF wrong || token.type != TType.sq_close
        token.error("Empty dictionary must be written as [:]")
      }
      RETURN $parseDict(NIL, isL)
    }

    $skipLineSep()
    Zui.Expression firstExpr = $parseExpr()
    token = $tokenAfterSep()
    IF token.type == TType.colon
      # [key: value, key: value] is a dictionary
      RETURN $parseDict(firstExpr, isL)
    }
    IF isL
      startToken.error("O[ can only be used for dictionary")
    }

    list<Zui.Expression> itemList = $parseComma(firstExpr, :allowTrailing)
    $skipLineSep()
    token = $in.getToken()
    IF token.type != TType.sq_close
      token.error("Expected ], found " .. token.type.ToString())
    }

    Zui.Expression listExpr = $newZuiExpr(Zui.ExprType.eLIST, token.zuiPos)
    listExpr.setListItemList(itemList)

    RETURN listExpr
  }

  # parse {key: value, key: value } or [key: value, key: value ]
  # If |firstKey| is not NIL it is the first key.
  FUNC $parseDict(Zui.Expression firstKey, bool isL) Zui.Expression
    # Evaluate expression pairs separated by commas:
    #   "expr1: expr2, expr3: expr4"
    IF firstKey == NIL
      $skipLineSep()
    }
    Token token = $in.peekToken()
    Zui.Expression dictExpr = $newZuiExpr(Zui.ExprType.eDICT, token.zuiPos)
    IF isL
      dictExpr.setOrderedDict(TRUE)
    }
    IF token.type != TType.sq_close
      bool useFirstKey = firstKey != NIL
      WHILE TRUE
        Zui.Expression key
        IF useFirstKey
          useFirstKey = FALSE
          key = firstKey
        ELSE
          key = $parseExpr()   # parse key
        }
        $skipLineSep()
        token = $in.getToken()
        IF token.type != TType.colon
          token.error("Missing ':' after dict key")
          IF token.type == TType.eof
            BREAK
          }
          IF token.type == TType.sq_close
            $in.pushToken(token)
            BREAK
          }
        }
        $expectSep()
        Zui.Expression value = $parseExpr()  # parse value

        dictExpr.addNewDictItem()
            .setKey(key)
            .setValue(value)

        # if there is a comma, consume it
        IF $tokenAfterSep().type != TType.comma
          IF $tokenAfterSep().type == TType.sq_close
            BREAK
          }
          token.error("missing comma")
        }
        $checkNoSep()
        token = $in.getToken()

        # break when comma after last item
        IF $tokenAfterSep().type == TType.sq_close
          $skipSep()
          BREAK
        }
        $expectSep()
      }
    }
    $skipLineSep()
    token = $in.getToken()
    IF token.type != TType.sq_close
      token.error("Expected ], found " .. token.type.ToString())
    }

    RETURN dictExpr
  }

  # Parse a comma separated list of type names: I.Iterable<Titem>, I_Mine
  FUNC $parseDotNameList() list<Zui.Expression>
    list<Zui.Expression> names = NEW()
    names.add($parseDotName(FALSE, :doTypespec))
    WHILE TRUE
      IF $tokenAfterSep().type != TType.comma
        BREAK
      }
      # Should be either "name," or "name /* comment */,", but not "name ,"
      Token token = $in.getToken()
      IF token.type == TType.line_sep
                             || (token.type == TType.sep && !token.hasComment)
        token.error("superfluous white space")
      }
      IF token.type != TType.comma
        token = $in.getToken()
      }
      $expectSep()
      names.add($parseDotName(FALSE, :doTypespec))
    }
    RETURN names
  }

  #
  # Parse a type specification or var name: "string", "MyMod.method".
  # |prefixOk| is TRUE with "$" and "%" prefixes are valid.
  #
  FUNC $parseDotName(bool prefixOk, MemberType what
       ) Zui.Expression
    Token token = $in.getToken()
    Zui.Expression expr
    IF token.type == TType.id || token.type == TType.i
      expr = $parseId(token)
    ELSEIF token.type == TType.dollar
        || token.type == TType.percent
        || token.type == TType.colon
      # $name, %name or :name
      string value = token.value
      Token next = $in.getToken()
      IF next.type != TType.id
        token.error("expected ID instead of " .. next.type.ToString())
      ELSEIF !prefixOk
        token.error("\(value) not allowed here")
      }
      expr = $newZuiExpr(Zui.ExprType.eID, token.zuiPos)
      expr.setName(next.value)
      IF value == "$"
        expr.setDollar(TRUE)
      ELSEIF value == "%"
        expr.setPercent(TRUE)
      ELSE
        expr.setColon(TRUE)
      }
      token.value = next.value
    ELSEIF token.type == TType.this
      expr = $newZuiExpr(Zui.ExprType.eTHIS, token.zuiPos)
    ELSEIF token.type == TType.parent
      expr = $newZuiExpr(Zui.ExprType.ePARENT, token.zuiPos)

    ELSEIF token.type == TType.c
      # nothing can follow C(type)
      RETURN $parseCCode()
    ELSE
      IF what.doTypespec
        token.error("expected type name, found " .. token.value)
      ELSE
        token.error("unexpected token type: " .. token.type.ToString())
      }
      expr = $newZuiExpr(Zui.ExprType.eUNKNOWN, token.zuiPos)
    }

    RETURN $parseMembers(expr, what)
  }

  # Return TRUE when |expr| starts with a $.
  FUNC $exprHasDollar(Zui.Expression expr) bool
    Zui.Expression e = expr
    WHILE e.hasLeft()
      e = e.getLeft()
    }
    IF e.getType() == Zui.ExprType.eID
      RETURN e.getDollar()
    }
    RETURN FALSE
  }

  # Return TRUE when |expr| starts with a %.
  FUNC $exprHasPercent(Zui.Expression expr) bool
    Zui.Expression e = expr
    WHILE e.hasLeft()
      e = e.getLeft()
    }
    IF e.getType() == Zui.ExprType.eID
      RETURN e.getPercent()
    }
    RETURN FALSE
  }

  # Return TRUE when |expr| starts with a :.
  FUNC $exprHasColon(Zui.Expression expr) bool
    Zui.Expression e = expr
    WHILE e.hasLeft()
      e = e.getLeft()
    }
    IF e.getType() == Zui.ExprType.eID
      RETURN e.getColon()
    }
    RETURN FALSE
  }

  # Parse a typespec: "<type, type>".
  # Put the types in |types|.
  # Also handles an empty list: "<>" and extra ">" after the end.
  PROC $parseTypeSpec(list<Zui.Type> types, bool itemNames)
    Token token = $in.getToken()
    IF token.type != TType.gt
          && token.type != TType.rshift
          && token.type != TType.copy_start
      $in.pushToken(token)
      $parseTypeList(types, itemNames)
      $skipLineSep()
      token = $in.getToken()
    }

    # If we get >> or >>> split it into individual > tokens.
    IF token.type == TType.rshift
         || token.type == TType.copy_start
      # For ">>" push the second ">" with startpos incremented, decrement
      # endpos of first ">".
      Token second = token.copy()
      second.type = TType.gt
      second.zuiPos.setColumn(second.zuiPos.getColumn() + 1)
      IF token.type == TType.copy_start
        # For ">>>" push another ">" with startpos incremented, decrement
        # endpos of first and second ">".
        Token third = second.copy()
        third.zuiPos.setColumn(third.zuiPos.getColumn() + 1)
        $in.pushToken(third)
      }
      $in.pushToken(second)
      token.type = TType.gt
    }
    IF token.type != TType.gt
      token.error("Missing > after type spec")
      $in.pushToken(token)
    }
  }

  #
  # Find a list of dot names: type, type, ...
  # There must always be a type, caller should check for empty <>.
  # The last one can be " => type", marked with "isReturn == TRUE".
  # When |itemNames| is TRUE accept an item name after the type.  Used for
  # "tuple<type a, type b>"
  # Add the types to |types|.
  #
  PROC $parseTypeList(list<Zui.Type> types, bool itemNames)
    bool didFirst
    bool foundGives
    WHILE TRUE
      Token token = $in.getToken()
      IF token.type == TType.gives
        #  "=> type"
        token.error("white space required before =>")
        $expectSep()
      ELSEIF token.isSep() && $in.peekToken().type == TType.gives
        #  " => type"
        token = $in.getToken()
        $expectSep()
        foundGives = TRUE
      ELSE
        # "type"
        $in.pushToken(token)
        $skipLineSep()
      }

      Zui.Expression expr = $parseDotName(FALSE, :doTypespec)
      $typeUsed(expr)
      Zui.Type item = NEW()
          .setType(Zui.TypeEnum.eNAME)
          .setPos(expr.getPos())
          .setName(expr)

      IF $tokenAfterSep().type == TType.amp
        # Reference: "type &"
        $expectSep()
        Token t = $in.getToken()
        Zui.Type ref = NEW()
             .setType(Zui.TypeEnum.eREF)
             .setRef(item)
             .setPos(t.zuiPos)
        item = ref
      }

      IF foundGives
        item.setIsReturn(TRUE)
      }

      types.add(item)

      IF itemNames && $tokenAfterSep().type == TType.id
        $expectSep()
        token = $in.getToken()
        item.setItemName(token.value)
        item.setItemNamePos(token.zuiPos)
      }

      IF $in.peekToken().type == TType.comma
        $in.getToken()
        $expectSep()
      ELSEIF $tokenAfterSep().type != TType.gives
        BREAK
      }
      didFirst = TRUE
    }
  }

  # Parse <Tone, Ttwo> and return a list with the names.
  FUNC $parseTypeNameList() list<Zui.Id>
    $in.getToken()  # consume the '<'
    $checkNoSep()

    list<Zui.Id> names = NEW()
    Token token
    WHILE TRUE
      token = $in.getToken()
      IF token.type != TType.id
        BREAK
      }
      Zui.Id id = NEW()
      id.setPos(token.zuiPos)
      id.setName(token.value)
      names.add(id)

      token = $in.getToken()
      IF token.type != TType.comma
        BREAK
      }
      $expectSep()
    }

    IF token.type != TType.gt
      token.error("expected >")
    }
    RETURN names
  }

  BITS CommaFlags
    bool :allowTrailing   # trailing comma allowed
    bool :arguments       # allow "name = expr"
  }

  #
  # Evaluate expressions separated by commas:  "expr, expr, expr"
  # For function arguments also accept "name = expr".
  # When |firstExpr| is not NIL use it as the first expr.
  # Returns a list of expressions.
  #
  FUNC $parseComma(Zui.Expression firstExpr, CommaFlags flags
                 ) list<Zui.Expression>
    Zui.Expression expr
    IF firstExpr == NIL
      expr = $parseExpr()
    ELSE
      expr = firstExpr
    }

    list<Zui.Expression> exprList = NEW()
    bool foundNamedArgument
    WHILE TRUE
      string name
      Zui.Position pos
      IF flags.arguments && $tokenAfterSep().type == TType.assign
        IF expr.getType() != Zui.ExprType.eID
          $error("Argument without name after argument with name")
        ELSE
          name = expr.getName()
          pos = expr.getPos()
        }
        foundNamedArgument = TRUE
        $expectSep()
        $in.getToken()  # skip '='
        $expectSep()
        expr = $parseExpr()
      ELSEIF foundNamedArgument
        $error("Argument without name after argument with name")
      }

      IF expr.getType() != Zui.ExprType.eUNKNOWN
        IF name != NIL
          Zui.Expression assign = NEW()
              .setType(Zui.ExprType.eASSIGN)
              .setPos(pos)
              .setRight(expr)
          assign.newLeft()
              .setType(Zui.ExprType.eSTRING)
              .setStringValue(name)
              .setPos(pos)
          expr = assign
        }
        exprList.add(expr)
      }

      IF $tokenAfterSep().type != TType.comma
        BREAK
      }
      $checkNoSep()
      Token token = $in.getToken()
      $expectSep()

      expr = $parseExpr()
      IF expr.getType() == Zui.ExprType.eUNKNOWN
        IF !flags.allowTrailing
          token.error("trailing comma")
        }
        BREAK
      }
    }

    RETURN exprList
  }

  BITS MemberType
    bool :doTypespec    # accept typespec: list<int>
    bool :doParens      # accept (arg)
  }

  SHARED
    # Names of types that we know of.  Doesn't have to be perfect, only used
    # for guessing which library modules will be needed.
    dict<string, string> typeNames = [
        "autoLock": "THREAD",
        "bool": "BOOL",
        "byte": "BYTE",
        "byteString": "BYTESTRING",
        "cond": "THREAD",
        "dyn": "DYN",
        "float": "FLOAT",
        "float128": "FLOAT128",
        "float32": "FLOAT32",
        "float80": "FLOAT80",
        "int": "INT",
        "int16": "INT16",
        "int32": "INT32",
        "int8": "INT8",
        "lock": "THREAD",
        "nat": "NAT",
        "nat16": "NAT16",
        "nat32": "NAT32",
        "regex": "RE",
        "status": "STATUS",
        "string": "STRING",
        "thread": "THREAD",
        "type": "TYPE",
        "varByteString": "VARBYTESTRING",
        "varString": "VARSTRING",
        ]
    dict<string, string> typespecNames = [
        "array": "ARRAY",
        "dict": "DICT",
        "evalThread": "THREAD",
        "dyn": "DYN",
        "list": "LIST",
        "multiDict": "MULTIDICT",
        "multiSet": "MULTISET",
        "pipe": "PIPE",
        "set": "SET",
        "sortedList": "SORTEDLIST",
        "tuple": "TUPLE",
        ]
  }

  #
  # Evaluate "expr_idx.member"
  #      and "expr_idx?.member"
  #      and "expr_idx(expr, ...)"
  #      and "expr_idx[arg]"
  #      and "expr_idx<type>"
  #      and "bitsfield=value
  #      and "expr_idx<type>"  (only when "what.doTypespec" is TRUE)
  #      and "expr_idx.method(expr, ...)"
  #      and "expr_idx.method[expr]"
  #      and "expr_idx.(expr)
  #      and "expr_idx.(expr)(arg)
  #      and "expr_idx.<typeCast>
  #   repeated
  #
  FUNC $parseMembers(Zui.Expression startExpr, MemberType what
                   ) Zui.Expression
    Zui.Expression expr = startExpr
    Token token

    WHILE TRUE
      token = $tokenAfterSep()
      # Recognize ".word" but not ". word". Same for "?.word".
      # Also not " .word" or " ?.word".
      IF !(((token.type == TType.dot
            || token.type == TType.dotnil)
                && !$nextTokenAfterSep().isSep()
                && $in.peekToken().type != TType.sep)
          || (token.type == TType.p_open && what.doParens)
          || token.type == TType.sq_open
          || (token.type == TType.assign && !what.doTypespec
                                                   && !$in.peekToken().isSep())
          || (token.type == TType.lt && what.doTypespec))
        BREAK
      }
      IF token.type == TType.sq_open && $in.peekToken().type == TType.line_sep
        # "[]" on the next line should be tuple unpack.
        BREAK
      }
      IF token.type == TType.dot || token.type == TType.dotnil
        # We allow a line break before '.', nothing else
        token = $in.getToken()
        IF token.type != TType.line_sep
          $in.pushToken(token)
        }
      }
      $checkNoSep()
      Token opToken = $in.getToken()

      IF opToken.type != TType.dot && opToken.type != TType.dotnil
                   && opToken.type != TType.assign && opToken.type != TType.lt
        # skip line break after '(' and '['
        $skipLineSep()
      }
      IF opToken.type == TType.dot || opToken.type == TType.dotnil
              || opToken.type == TType.colon
        token = $in.getToken()
        IF token.type == TType.p_open && opToken.type != TType.colon
          # var.(expr)  method reference
          Zui.Expression methodExpr = $newZuiExpr(Zui.ExprType.eEXPRMETHOD,
                                                                 token.zuiPos)
          IF opToken.type == TType.dotnil
            methodExpr.setDotnil(TRUE)
          }
          $skipLineSep()
          Zui.Expression arg = $parseExpr()
          $skipLineSep()
          token = $in.getToken()
          IF token.type != TType.p_close
            token.error("Missing )")
            $in.pushToken(token)
          }

          methodExpr.setRight(arg)
          methodExpr.setLeft(expr)
          expr = methodExpr
        ELSEIF token.type == TType.lt && opToken.type != TType.colon
          # var.<type> type cast
          Zui.Expression typeExpr =
                       $newZuiExpr(Zui.ExprType.eTYPECAST, token.zuiPos)
          IF opToken.type == TType.dotnil
            typeExpr.setDotnil(TRUE)
          }
          $skipLineSep()
          Zui.Expression arg = $parseDotName(TRUE, :doTypespec)
          $skipLineSep()
          token = $in.getToken()
          IF token.type != TType.gt
            token.error("Missing >")
            $in.pushToken(token)
          }

          typeExpr.newTypecast()
                  .setType(Zui.TypeEnum.eNAME)
                  .setName(arg)
          typeExpr.setLeft(expr)
          expr = typeExpr
        ELSE
          # "var.member" / "var.NEW" / "var.PARENT" / "var.C" / "var.I"
          # "var:member"
          IF token.type != TType.id
             && token.type != TType.new
             && token.type != TType.parent
             && token.type != TType.c
             && token.type != TType.i
            token.error("expected ID after .")
          }

          Zui.Expression member =
                               $newZuiExpr(Zui.ExprType.eMEMBER, token.zuiPos)
          IF opToken.type == TType.dotnil
            member.setDotnil(TRUE)
          }

          member.newRight()
                  .setType(Zui.ExprType.eID)
                  .setPos(token.zuiPos)
                  .setName(token.value)
                  .setColon(opToken.type == TType.colon)
          member.setLeft(expr)
          expr = member
        }
      ELSEIF opToken.type == TType.assign
        # "var=value"
        token = $in.getToken()
        bool negative
        IF token.type == TType.minus
          # "=-value"
          negative = TRUE
          token = $in.getToken()
        }
        IF token.type != TType.id
          token.error("expected ID or number after =")
        }
        Zui.Expression rhs = $parseId(token)
        IF negative
          IF rhs.getType() != Zui.ExprType.eINT
                                         && rhs.getType() != Zui.ExprType.eNAT
            token.error("expected number after =-")
          }
          rhs.setNumber(-rhs.getNumber())
        }

        Zui.Expression assign =
                            $newZuiExpr(Zui.ExprType.eBITSASSIGN, token.zuiPos)
        assign.setRight(rhs)
                   .setLeft(expr)
        expr = assign
      ELSEIF opToken.type == TType.p_open
        # "name(arg, arg)"
        $skipLineSep()
        list<Zui.Expression> args = $parseComma(NIL, :arguments)
        $skipLineSep()
        token = $in.getToken()
        IF token.type != TType.p_close
          token.error("Missing )")
          $in.pushToken(token)
        }

        Zui.MethodCall method = NEW()
        method.setPos(expr.getPos())
        method.setArgumentList(args)
        method.setName(expr)

        expr = NEW()
                .setType(Zui.ExprType.eCALL)
                .setPos(expr.getPos())
                .setMethodCall(method)
      ELSEIF opToken.type == TType.sq_open
        # "var[arg]"
        Zui.Expression arg = $parseExpr()
        $skipLineSep()
        token = $in.getToken()
        IF token.type != TType.sq_close
          token.error("Missing ] after subscript")
          $in.pushToken(token)
        }

        Zui.Expression subscript = NEW()
               .setType(Zui.ExprType.eSUBSCRIPT)
               .setPos(expr.getPos())
        subscript.setLeft(expr)
                 .setRight(arg)
        expr = subscript
      ELSE # opToken.type == TType.lt
        # var<type, type>
        # proc<type>
        # func<type => type>
        # tuple<type, type> or tuple<type a, type b>

        # Parse if we do not get >, >> or >>>, that is an empty type spec.
        list<Zui.Type> types = NEW()
        $parseTypeSpec(types, expr.getType() == Zui.ExprType.eID
                                                 && expr.getName() == "tuple")

        IF expr.getType() == Zui.ExprType.eID
          # For some types we may need to load a module.  Do that right after
          # parsing to reduce the number of passes required.
          string module = typespecNames.get(expr.getName(), NIL)
          IF module != NIL
            $in.usedIdKeywords.set(module)
          }
        }

        Zui.Expression typespec = NEW()
              .setType(Zui.ExprType.eTYPESPEC)
              .setPos(expr.getPos())
        typespec.setTypespecList(types)
        typespec.setLeft(expr)
        expr = typespec
      }
    }
    RETURN expr
  }

  #
  # Found ">>>": start of directly copied text.
  #
  FUNC $copyCode() Zui.Statement
    Z.Pos pos = $in.input.pos.copy()

    Zui.Statement stmt = NEW()
        .setPos(FilePosition.createPosition(pos))
        .setPluginLnum($in.input.pluginLnum)
        .setType(Zui.StatementType.eCBLOCK)

    # We can't use tokens here, a C line may start with #ifdef which would be
    # recognized as a comment and skipped over.
    $in.emptyStack()

    # Skip to end of line, ignore comment, parse uses().
    bool comment
    int    c
    list<string> usesList
    WHILE TRUE
      Z.Pos startPos = $in.input.pos.copy()
      c = $in.get()
      IF c == IO.eof || c == '\n'
        BREAK
      }
      IF c == '#'
        comment = TRUE
      ELSEIF !comment
        IF c == 'u' && $in.getWord() == "ses"
          # Parse uses(item, item).
          c = $in.get()
          IF c != '('
            $error("Missing ( after uses")
            comment = TRUE  # one error is enough
          ELSE
            usesList = NEW()
            WHILE TRUE
              string word = $in.getWord()
              IF word == ""
                $error("Syntax error in uses()")
                comment = TRUE  # one error is enough
                BREAK
              }
              usesList.add(word)
              c = $in.get()
              IF c == ')'
                BREAK
              }
              IF c != ','
                IF c == ' '
                  $error("Unexpected white space in uses()")
                ELSE
                  $error("Syntax error in uses()")
                }
                comment = TRUE  # one error is enough
                BREAK
              }
              IF !$skipSpaces()
                $error("Missing white space after comma")
                comment = TRUE  # one error is enough
                BREAK
              }
            }
          }
        ELSEIF c == 'b' && $in.getWord() == "lockgc"
          # Parse "blockgc"
          stmt.setBlockgc(TRUE)
        ELSEIF c != ' '
          LOG.error("Expected comment or uses()", startPos)
          comment = TRUE  # one error is enough
        }
      }
    }

    # Collect all text until the "<<<".
    IO.StringWriter writer = NEW()
    int    gt_count = 0
    WHILE TRUE
      c = $in.get()
      IF c == IO.eof
        $error("missing <<<")
        BREAK
      }

      # Write any postponed '<'.
      WHILE gt_count > 0 && c != '<'
        writer.writeChar('<')
        --gt_count
      }

      IF c == '\n'
        gt_count = 0        # start of line, look for "<<<"
      ELSEIF gt_count >= 0 && c == '<'
        IF ++gt_count == 3  # found "<<<"
          BREAK
        }
      ELSE
        gt_count = -1       # not at start of line, don't look for "<<<"
      }
      IF gt_count <= 0
        writer.writeChar(c)
      }
    }

    # Skip to end of line, ignore comment.
    WHILE TRUE
      c = $in.get()
      IF c == IO.eof || c == '\n'
        BREAK
      }
    }

    string text = writer.ToString()

    # Find and parse separate items for these:
    # - %var%
    # - %{ expression }%
    # - %[ function ]%
    int start
    string toWrite = ""
    Z.Pos startPos = pos.copy()
    WHILE TRUE
      int idx = text.find('%', start)
      IF idx >= 0
        # write the text before the '%'
        string s = text.slice(start, idx - 1)
        toWrite ..= s
        pos.advance(s)
        ++pos.col  # count the starting %

        int end = idx + 1
        bool literal
        IF text[end] == '{' || text[end] == '['
          int match
          IF text[end] == '{'
            # Find end for %{ expr }%.
            match = '}'
          ELSE
            # Find end for %[ name ]%.
            match = ']'
            literal = TRUE
          }
          ++end
          WHILE text[end] != 0 && (text[end] != match || text[end + 1] != '%')
            ++end
          }
          IF text[end] == match
            ++end
          }
        ELSE
          # Find end for %varname%.
          WHILE text[end] != '%' && text[end] != 0
                                      && text[end] != ' ' && text[end] != '\n'
            ++end
          }
        }
        IF text[end] == '%'
          IF end == idx + 1
            # found %%, produce one %
            toWrite ..= "%"
            ++pos.col
          ELSE
            # Found %var% or %{ expr }% or %[ expr ]%.
            Zui.CBlock block = NEW().setPos(
                                        FilePosition.createPosition(startPos))
                .setText(toWrite)
                .setLiteral(literal)
            IF usesList != NIL
              block.setUsesList(usesList)
              usesList = NIL
            }
            stmt.addCblock(block)

            s = text.slice(idx + 1, end - 1)
            $parseCopyPercent(block, s, pos)
            pos.advance(s)

            toWrite = ""
            pos.col++  # count the closing %
            startPos = pos.copy()
          }
          start = end + 1  # continue after %foo%
        ELSE
          # % that is not %var%, write the % and continue after it.
          toWrite ..= "%"
          start = idx + 1
        }
      ELSE
        # No %, copy the rest of the text.
        toWrite ..= text.slice(start)
        BREAK
      }
    }

    IF toWrite != ""
      Zui.CBlock block = NEW().setPos(FilePosition.createPosition(startPos))
          .setText(toWrite)
      IF usesList != NIL
        block.setUsesList(usesList)
        usesList = NIL
      }
      stmt.addCblock(block)
    }

    RETURN stmt
  }

  # Parse the text "var" between % in >>> %var% <<<.
  PROC $parseCopyPercent(Zui.CBlock block, string text, Z.Pos pos)
    TokenInput saveIn = $in
    IF text[0] == '{' || text[0] == '['
      Input input = NEW(text.sliceWrap(1, -2), pos)
      $in = NEW(input, $tokenizer)
      $in.input.pos.col++  # count the {
    ELSE
      Input input = NEW(text, pos)
      $in = NEW(input, $tokenizer)
    }
    $skipSep()

    block.setExpr($parseExpr())
    $in = saveIn
  }

  # ALIAS Some.Dot.Name id
  # TYPE Some.Dot.Name id
  FUNC $parseAlias(Token token) Zui.Statement
    Token comment
    IF $lastSep.hasComment
      comment = $lastSep
    }

    # Some.Dot.Name
    $expectSep()
    Zui.Expression left = $parseDotName(TRUE, :doTypespec)

    # id
    $expectSep()
    Zui.Expression idExpr = $parseDotName(TRUE, 0)
    string name
    IF idExpr.getType() != Zui.ExprType.eID
      token.error("Expected a name")
    ELSE
      name = idExpr.getName()
      IF $exprHasDollar(idExpr) != $exprHasDollar(left)
        token.error("Must both have a dollar or neither")
      }
      IF $exprHasPercent(idExpr) != $exprHasPercent(left)
        token.error("Must both have a percent or neither")
      }
      IF $exprHasColon(idExpr) != $exprHasColon(left)
        token.error("Must both have a colon or neither")
      }
    }

    # @public and friends.
    Zui.Attributes za = NEW()
    $parseAttr(za, TRUE, ["private", "protected", "public",
                              "file", "directory"])

    Zui.AliasType alias = NEW()
    alias.setFrom(left)
    alias.setName(name)

    Zui.Declaration decl = NEW()
    decl.setName(name)
        .setPos(token.zuiPos)
        .newType()
            .setType(Zui.TypeEnum.eALIAS)
            .setAlias(alias)
            .setAttr(za)
    $setPrefixFromExpr(decl, idExpr)
    IF comment != NIL
      decl.setCommentBefore(comment.value)
    }
    # A comment directly after declaration belongs to the declaration:
    # "valuename  #= comment"
    Token peek = $in.peekToken()
    IF peek.type == TType.line_sep && peek.hasCommentFirst
      decl.setCommentAfter(peek.value)
    }
    $expectNewLine()

    Zui.Statement stmt = NEW()
    stmt.setType(token.type == TType.alias
            ? Zui.StatementType.eALIAS_DECL
            : Zui.StatementType.eTYPE_DECL)
        .setDeclaration(decl)
    setStmtPos(stmt, token)

    RETURN stmt
  }

  # Found C, start of "C(c-type) id"
  # Or found JAVA, start of "JAVA(java-type) id"
  # Or found JS, start of "JS(js-type) id"
  FUNC $parseLangType(TType tokenType) Zui.Statement
    Zui.Position startPos
    string typeName
    typeName, startPos = $parseLangParens()

    Zui.Expression ctype = $newZuiExpr(
                            tokenType == TType.c ? Zui.ExprType.eCTYPE
                            : tokenType == TType.java ? Zui.ExprType.eJAVATYPE
                            : Zui.ExprType.eJSTYPE, startPos)
    ctype.setName(typeName)

    $expectSep()
    Token token = $in.getToken()

    RETURN $parseDeclaration(ctype, token, TRUE, TRUE)
  }

  # Parse what is inside "C( code )"
  FUNC $parseLangParens() string, Zui.Position
    Zui.Position startPos = FilePosition.createPosition($in.input.pos)
    $in.emptyStack()
    int c = $in.get()
    IF c != '('
      $error("Missing (")
      RETURN "", startPos
    }

    # Skip white space after C(
    DO
      c = $in.get()
    UNTIL c != ' '
    $in.push(c)

    # Copy the text until the matching ).  This takes everything literally,
    # does not use the tokenizer.
    IO.StringWriter writer = NEW()
    int nesting
    WHILE TRUE
      IF c == IO.eof || c == '\n'
        $error("Missing )", startPos)
        RETURN "", startPos
      }
      c = $in.get()
      IF c == ')'
        IF nesting == 0
          BREAK
        }
        --nesting
      ELSEIF c == '('
        ++nesting
      }
      writer.writeChar(c)
    }
    RETURN writer.ToString(), startPos
  }

  # Found "C", start of "C( any C code )"
  FUNC $parseCCode() Zui.Expression
    Zui.Position startPos
    string code
    code, startPos = $parseLangParens()
    Zui.Expression ccode = $newZuiExpr(Zui.ExprType.eCCODE, startPos)
    ccode.setStringValue(code)
    RETURN ccode
  }

  # Report an error detected during the parse phase.
  PROC $error(string msg)
    LOG.error(msg, $in.input.pos)
  }

  # Report an error using Zui.Position, converting it to a Z.Pos for the LOG
  # module.
  PROC $error(string msg, Zui.Position pos)
    LOG.error(msg,
                 Z.Pos.NEW(pos.getFilename(), pos.getLine(), pos.getColumn()))
  }

  # Read a line separator from |in|.  When there is none give an error message.
  # A semicolon may also be used.
  # A comment without leading white space is not acceptable.
  PROC $expectLineSep()
    $expectLineSep(TRUE)
  }

  # Like expectLineSep() above, but do not allow a semicolon.
  PROC $expectNewLine()
    $expectLineSep(FALSE)
  }

  # Like expectLineSep() above, but allow a semicolon only when
  # |allowSemicolon| is TRUE.
  PROC $expectLineSep(bool allowSemicolon)
    Token token = $in.getToken()
    Token next
    IF token.type == TType.sep
      $lastSep = token
      next = $in.getToken()
      token = next
    }
    IF allowSemicolon
      IF token.type == TType.semicolon
        # Semicolon must be followed by white space, not a line break.
        token = $in.getToken()
        IF token.type == TType.line_sep
          token.error("unexpected semicolon")
        ELSE
          $in.pushToken(token)
          $expectSep()
        }
        RETURN
      }
      IF next != NIL
        $in.pushToken(next)
      }
    }

    IF token.type == TType.line_sep
      $lastSep = token
    ELSE
      IF token.type == TType.comment
        token.error("missing white space before comment")
      ELSEIF token.type == TType.semicolon
        next = $in.getToken()
        IF next.type == TType.line_sep
          token.error("unexpected semicolon")
        ELSE
          token.error("semicolon not allowed here, line break required")
          IF next.type != TType.sep
            $in.pushToken(next)
          }
        }
      ELSE
        token.error("missing line break")
        IF token.type != TType.sep
          $in.pushToken(token)
        }
      }
    }
  }

  # Read a separator from |in|.  When there is none give an error message.
  # A comment without leading white space is not acceptable.
  PROC $expectSep()
    Token token = $in.getToken()
    IF token.type != TType.sep && token.type != TType.line_sep
      token.error("white space required")
      IF token.type != TType.comment
        $in.pushToken(token)
      }
    }
  }

  # The last skipped separator is remembered, so that we can attach a comment
  # before an item to that item.
  Token $lastSep = NEW()

  # Read an optional separator or comment from |in|.
  PROC $skipSep()
    Token token = $in.getToken()
    IF token.isSep()
      $lastSep = token
    ELSE
      $in.pushToken(token)
    }
  }

  # Skip over spaces.  Return TRUE if at least one space was encountered.
  # Uses characters, not tokens.
  FUNC $skipSpaces() bool
    int c = $in.get()
    IF c != ' '
      $in.push(c)
      RETURN FALSE
    }
    WHILE c == ' '
      c = $in.get()
    }
    $in.push(c)
    RETURN TRUE
  }

  # Read an optional line break or comment from |in|.
  # Give an error if it is white space without a line break and without a
  # single line comment.
  PROC $skipLineSep()
    Token token = $in.getToken()
    IF token.type == TType.line_sep
                              || (token.type == TType.sep && token.hasComment)
      $lastSep = token
    ELSE
      IF token.type == TType.sep
        token.error("superfluous white space")
      ELSEIF token.type == TType.comment
        token.error("white space required")
      ELSE
        $in.pushToken(token)
      }
    }
  }

  # Return the next token, ignoring a separator token.
  # Does not actually read anything.
  FUNC $tokenAfterSep() Token
    Token res
    Token token = $in.getToken()
    IF token.type == TType.sep || token.type == TType.line_sep
      res = $in.getToken()
      $in.pushToken(res)
    ELSE
      res = token
    }
    $in.pushToken(token)
    RETURN res
  }

  # Return the next token and the one after that, ignoring a separator token.
  # Does not actually read anything.
  FUNC $twoTokensAfterSep() Token, Token
    Token res
    Token next
    Token token = $in.getToken()
    IF token.type == TType.sep || token.type == TType.line_sep
      res = $in.getToken()
      next = $in.peekToken()
      $in.pushToken(res)
    ELSE
      res = token
      next = $in.peekToken()
    }
    $in.pushToken(token)
    RETURN res, next
  }

  # Return the token after the next token, ignoring a separator token.
  # Does not actually read anything.
  FUNC $nextTokenAfterSep() Token
    Token next
    Token token = $in.getToken()
    IF token.type == TType.sep || token.type == TType.line_sep
      Token res = $in.getToken()
      next = $in.peekToken()
      $in.pushToken(res)
    ELSE
      next = $in.peekToken()
    }
    $in.pushToken(token)
    RETURN next
  }

  # Check that the next token is not a separator.  If it is anyway, give an
  # error message and consume it.
  PROC $checkNoSep()
    Token next = $in.getToken()
    IF next.type == TType.sep || next.type == TType.line_sep
      next.error("superfluous white space")
    ELSE
      $in.pushToken(next)
    }
  }

  # Check that the next token is not a line break.  If it is anyway, give an
  # error message.
  PROC $checkNoLineBreak()
    Token next = $in.peekToken()
    IF next.type == TType.line_sep
      next.error("unexpected line break")
    }
  }

  # Create a new Zui.Expression and set the type and position.
  FUNC $newZuiExpr(Zui.ExprType type, Zui.Position pos) Zui.Expression
    Zui.Expression expr = NEW()
    expr.setType(type)
    expr.setPos(pos)
    RETURN expr
  }

}
