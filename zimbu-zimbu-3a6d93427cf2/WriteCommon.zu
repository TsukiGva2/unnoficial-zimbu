#
# The Zimbu compiler written in Zimbu
#
# Common for Resolve and Write classes.
#
# Copyright 2009 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO parser/zui.proto

IMPORT BitsValueType.zu
IMPORT ClassRefType.zu
IMPORT ClassType.zu
IMPORT ContainerType.zu
IMPORT Declaration.zu
IMPORT EnumType.zu
IMPORT EnumValueType.zu
IMPORT ExprArg.zu
IMPORT ExprEval.zu
IMPORT FileScope.zu
IMPORT ForLoopInfo.zu
IMPORT Generate.zu
IMPORT MethodType.zu
IMPORT ModuleType.zu
IMPORT Output.zu
IMPORT MultipleType.zu
IMPORT ReferenceType.zu
IMPORT Report.zu
IMPORT SContext.zu
IMPORT Scope.zu
IMPORT SymUse.zu
IMPORT TargetLang.zu
IMPORT TupleType.zu
IMPORT Type.zu
IMPORT UsedFile.zu
IMPORT ValueType.zu
IMPORT ZimbuFile.zu
IMPORT ZuiExpressionExt.zu
IMPORT ZuiMethodCallExt.zu
IMPORT ZuiMethodTypeExt.zu

CLASS WriteCommon @items=public   # TODO: restrict visibility
  bool       $writing        # TRUE when writing code, FALSE for Resolve itself

  bool       $didMarkUsed    # TRUE when finished marking items as used,
                             # before starting to write code.

  PROC $Init()
    $virtualFuncMap = NEW()
    $virtualDeclOut = NEW()
    $virtualBodyOut = NEW()
  }

  # Return the name of the language, to be displayed in
  # "Generating {langName} code".
  # Overruled in subclasses for a specific language.
  FUNC $getLangName() string @default
    RETURN "none"
  }

  # Return the target language.
  # Overruled in subclasses for a specific language.
  FUNC $getTargetLang() TargetLang @default
    RETURN 0
  }

  GENERATE_IF FALSE
    # For debugging: When 1 indicates that a specific used item was found.
    int $found
  }

  # Mark |decl| as being used for this language.  Also recursively marks
  # Declarations used inside |decl| as being used.
  PROC $setDeclUsed(Declaration decl)
    GENERATE_IF FALSE
      # For debugging: Value for $found when returning.
      int found
    }

    TargetLang lang = $getTargetLang()
    IF !decl.isUsed(lang)
      decl.setUsed(lang)

      GENERATE_IF FALSE
        # For debugging: set found flag for specific item.
        IF lang.c && decl.name == "thread"
          found = 1
          IO.print("decl used: " .. decl.getName(TRUE))
        }
      }

      # Setting a used flag after code generation has started is only allowed
      # for items defined in the language-specific code, not in the program or
      # libraries.  Check module and class scopes.
      IF $didMarkUsed && decl.scopeName != NIL
                                          && ['M', 'C'].has(decl.scopeName[0])
        THROW "Internal error: Declaration "
                         .. decl.getName(TRUE) .. " marked used while writing"
      }

      # Call setDeclUsed() on explicitly specified dependencies.
      FOR d IN decl.getDependsOnKeys()
        $setDeclUsed(d)  # Recursive call

        GENERATE_IF FALSE
          # For debugging: Report caller that caused $found to become 1
          IF $found == 1
            found = 1
            $found = 2
            IO.print("From dependsOn of " .. decl.getName(TRUE))
          }
        }
      }

      # Call setDeclUsed() on explicitly specified dependencies with a
      # condition.
      FOR d IN decl.getDependsOnCondKeys()
        Declaration condDecl = decl.dependsOnCond[d]
        IF condDecl.isUsed(lang)
          $setDeclUsed(d)  # Recursive call

          GENERATE_IF FALSE
            # For debugging: Report caller that caused $found to become 1
            IF $found == 1
              found = 1
              $found = 2
              IO.print("From dependsOnCond of " .. decl.getName(TRUE))
            }
          }
        ELSE
          # Now if the condDecl is marked as used also mark the conditional
          # dependency as used.
          condDecl.addDependsOn(d)
        }
      }

      # Call setDeclUsed() on language-specific specified dependencies.
      FOR d IN decl.getLangDependsOnList(lang)
        $setDeclUsed(d)  # Recursive call

        GENERATE_IF FALSE
          # For debugging: Report caller that caused $found to become 1
          IF $found == 1
            found = 1
            $found = 2
            IO.print("From langDependsOn of " .. decl.getName(TRUE))
          }
        }
      }

      # Call setDeclUsed() on language-specific specified dependencies with a
      # condition.
      FOR dl IN decl.getLangDependsOnCondList(lang)
        IF dl[0].isUsed(lang)
          $setDeclUsed(dl[1])  # Recursive call

          GENERATE_IF FALSE
            # For debugging: Report caller that caused $found to become 1
            IF $found == 1
              found = 1
              $found = 2
              IO.print("From langDependsOnCond of " .. decl.getName(TRUE))
            }
          }
        ELSE
          # Now if the conditional declaration is marked as used also mark the
          # conditional dependency as used.
          dl[0].addDependsOn(dl[1])
        }
      }

      # Call setDeclUsed() for all declarations used in all scopes inside
      # decl.
      Zui.Declaration zuiDecl = decl.zuiDecl
      IF zuiDecl != NIL && zuiDecl.hasType() && decl.type != NIL
        Zui.Type type = zuiDecl.getType()
        IF decl.type ISA MethodType
          Scope scope
          SWITCH type.getType()
            CASE Zui.TypeEnum.eNEW
            CASE Zui.TypeEnum.ePROC
            CASE Zui.TypeEnum.eFUNC
              scope = type.getMethodDecl().<ZuiMethodTypeExt>.scope
          }

          IF scope != NIL && scope.usedDecl != NIL
            FOR d IN scope.usedDecl.keys()
              $setDeclUsed(d)  # Recursive call.

              GENERATE_IF FALSE
                # For debugging: Report caller that caused $found to become 1
                IF $found == 1
                  found = 1
                  $found = 2
                  IO.print("From method scope of " .. decl.getName(TRUE))
                }
              }
            }
          }

          IF scope != NIL && scope.usedDeclCond != NIL
            FOR cd IN scope.usedDeclCond.keys()
              IF $isDeclUsed(cd)
                FOR d IN scope.usedDeclCond[cd].keys()
                  $setDeclUsed(d)  # Recursive call.

                  GENERATE_IF FALSE
                    # For debugging: Report caller that caused $found to
                    # become 1
                    IF $found == 1
                      found = 1
                      $found = 2
                      IO.print("With cond from method scope of "
                                                        .. decl.getName(TRUE))
                    }
                  }
                }
              }
            }
          }
        ELSEIF decl.type ISA ModuleType || decl.type ISA ClassType
          # In a class and module mark Init and EarlyInit as used.
          # Also mark items with @earlyInit as used.
          Scope scope
          ClassType ct
          IF decl.type ISA ModuleType
            scope = decl.type.<ModuleType>.scope
          ELSE
            ct = decl.type
            scope = ct.scope
          }
          WHILE scope != NIL
            IF scope.declDict != NIL
              multiDict<string, Declaration> declDict = scope.declDict
              FOR k IN declDict.keys()
                FOR d IN declDict.get(k)
                  IF k == "Init" || k == "EarlyInit"
                     || (d.type.zuiAttr != NIL && d.type.zuiAttr.getEarlyInit())
                    $setDeclUsed(d)  # Recursive call.

                    GENERATE_IF FALSE
                      # For debugging: Report caller that caused $found to
                      # become 1
                      IF $found == 1
                        found = 1
                        $found = 2
                        IO.print("From init of " .. decl.getName(TRUE))
                      }
                    }
                  }
                }
              }
            }
            IF decl.type ISA ClassType && ct.parent != NIL
              # Also mark Init and EarlyInit in extended classes as used.
              ct = ct.parent
              scope = ct.scope
            ELSE
              scope = NIL
            }
          }
        ELSEIF decl.type ISA ContainerType
            # TODO: mark key and item types as used
        ELSEIF decl.type ISA TupleType
            # TODO: mark all types as used
        ELSEIF decl.type ISA ReferenceType || decl.type ISA ValueType
            # TODO: mark type as used
        }
      ELSEIF decl.type != NIL && decl.type ISA MethodType
        MethodType mt = decl.type
        IF mt.scope != NIL && mt.scope.usedDecl != NIL
          FOR d IN mt.scope.usedDecl.keys()
            $setDeclUsed(d)  # Recursive call.

            GENERATE_IF FALSE
              # For debugging: Report caller that caused $found to become 1
              IF $found == 1
                found = 1
                $found = 2
                IO.print("From method scope of " .. decl.getName(TRUE))
              }
            }
          }
        }
      }
    }

    GENERATE_IF FALSE
      # For debugging: Set $found to 1 when specific item was found
      $found = found
    }
  }

  # Set Declaration |from| as depending on Declaration |on|.
  # If |from| is already marked as used |on| is also marked as used
  # (recursively).
  PROC $setDeclDependency(Declaration from, Declaration on)
    from.addLangDependsOn($getTargetLang(), on)
    IF $isDeclUsed(from)
      $setDeclUsed(on)
    }
  }

  # Invoke $setDeclDependency() for each item in |onList|.
  PROC $setDeclDependency(Declaration from, list<Declaration> onList)
    FOR on IN onList
      $setDeclDependency(from, on)
    }
  }

  # Set Declaration |from| as depending on Declaration |on|, under the
  # condition that |cond| is used.
  # If |from| is already marked as used |on| is also marked as used
  # (recursively).
  PROC $setDeclCondDependency(Declaration from, Declaration cond,
                                                             Declaration on)
    from.addLangDependsOnCond($getTargetLang(), cond, on)
    IF $isDeclUsed(from) && $isDeclUsed(cond)
      $setDeclUsed(on)
    }
  }

  # Check if |decl| was marked as being used for this language.
  # Also returns TRUE if not skipping unused items.
  FUNC $isDeclUsed(Declaration decl) bool
    RETURN decl != NIL
                  && (decl.isUsed($getTargetLang()) || !Generate.skipUnused())
  }

  # Return the type of the RHS.
  # Returns NIL if there is an error.
  FUNC $isaOpType(Zui.Expression expr, SContext ctx) Type
    SymUse symUse = NEW(expr.getPos(), ctx)
    Type rightType = Generate.generateDeclType(expr.getRight(),
                                             ctx.copyNoOut(), :isDecl, symUse)
    IF ctx.doError()
      IF rightType == NIL
        # Produce the error message.
        symUse.doError = TRUE
        Generate.generateDeclType(expr.getRight(), ctx, :isDecl, symUse)
      ELSEIF (rightType.ttype != Type.Enum.iobject
                                    && rightType.ttype != Type.Enum.class
                                    && rightType.ttype != Type.Enum.interface)
        ctx.error("Expected class type, got "
                                     .. rightType.typeName(), expr.getRight())
        RETURN NIL
      }
    }
    RETURN rightType
  }

  # Produce the while() loop for FOR using an iterator
  PROC $forLoopIteratorWhile(ForLoopInfo info,
                         list<Declaration> varList, int iterIdx,
                         func<string, int => string> tupleGet,
                         SContext ctx)
    Declaration.C firstVar = varList[iterIdx]
    IF firstVar == NIL || firstVar.zuiPos == NIL
      RETURN
    }
    ForLoopInfo.Iter iter = info.iters[iterIdx]

    # Add the iterator to the scope so that generateObjectCall() can find
    # it.
    Declaration itDecl = NEW("__it" .. iterIdx)
    itDecl.type = iter.iteratorType
    itDecl.pName = iter.varDecl.pName
    ctx.scope.addMember(itDecl)

    # it.hasNext()
    Zui.Expression nameExpr = NEW()
    nameExpr.setPos(firstVar.zuiPos)
    Zui.Expression left = NEW()
    left.setType(Zui.ExprType.eID)
    left.setPos(firstVar.zuiPos)
    left.setName("__it" .. iterIdx)
    nameExpr.setLeft(left)
    nameExpr.setRight(NEW().setName("hasNext"))
    Zui.MethodCall call = NEW()
    call.setName(nameExpr)
    call.setPos(firstVar.zuiPos)
    Type retType = Generate.generateObjectCall(iter.iteratorType,
                                                   call, NIL, ctx, Type.aBool)
    IF retType != NIL && retType.ttype != Type.Enum.bool
      ctx.error("Expected bool return type for hasNext()", firstVar.zuiPos)
    }

    string tempPName = info.multiExpr == NIL ? NIL
                        : info.multiExpr.<ZuiExpressionExt>.tempDecl?.pName
    IF ctx.out.writing
      ctx.out.write(" && (")
      IF info.multiExpr != NIL
        ctx.out.write(tempPName)
      ELSE
        ctx.out.write(firstVar.pName)
      }
      ctx.out.write(" = ")
    }

    # it.next()
    nameExpr.setRight(NEW().setName("next"))
    Generate.generateObjectCall(iter.iteratorType, call, NIL,
                                                       ctx, iter.iteratorType)
    ctx.scope.removeMember(itDecl)

    IF ctx.out.writing
      IF info.multiExpr != NIL
        FOR i IN 0 UNTIL varList.Size()
          ctx.out.write(", ")
          ctx.out.write(varList[i].pName)
          ctx.out.write(" = ")
          ctx.out.write(tupleGet(tempPName, i))
        }
      }
      ctx.out.write(", 1)")
    }
  }

  # Write a function call with left and right of |expr|.
  PROC $writeFuncLeftRight(Zui.Expression expr, string name, Type type,
                                                                 SContext ctx)
    ctx.out.write(name)
    ctx.out.write("(")
    ctx.gen.wrapExpr(expr.getLeft(), ctx, type)
    ctx.out.write(", ")
    ctx.gen.wrapExpr(expr.getRight(), ctx, type)
    ctx.out.write(")")
  }

  # Write after imports, before inits of the file itself.
  PROC $commonAfterImports(Scope scope, Output.Group outs)
    string earlyInit
    string init
    IF scope.scopeType == Scope.Stype.libModule
      earlyInit =  " if (round == 0) {\n"
      init = "  if (round == 0) {\n"
    ELSE
      earlyInit = " if (round == 1) {\n"
      init = "  if (round == 2001) {\n"
    }
    IF outs.earlyInitOut.empty()
      # No early inits yet.  If there are some later need to add the "if"
      outs.earlyInitLead = earlyInit
    ELSE
      # Some early inits already.  Write the "if" and make earlyInitLead empty
      # so that the matching "}" is written.
      outs.earlyInitLead = ""
      outs.earlyInitOut.write(earlyInit)
    }
    IF outs.initOut.empty()
      # No inits yet.  If there are some later need to add the "if"
      outs.initLead = init
    ELSE
      # Some inits already.  Write the "if" and make earlyInitLead empty so
      # that the matching "}" is written.
      outs.initLead = ""
      outs.initOut.write(init)
    }
  }

  # Write after inits of the file itself.
  PROC $commonAfterGenerate(UsedFile usedFile, Output.Group outs, SContext ctx)
    Scope scope = usedFile.scope()
    IF scope.declDict != NIL
      FOR early IN [TRUE, FALSE]
        bool didElse
        Declaration initDecl
        FOR declList IN scope.declDict.values()
          FOR decl IN declList
            $classInit(decl, early, outs, &didElse, ctx)
            IF usedFile.zimbuFile.isMainFile
                     && decl.type.ttype == Type.Enum.func
                     && (decl.name == (early ? "EarlyInit" : "Init"))
              initDecl = decl
            }
          }
        }
        # The main file can have an EarlyInit() and Init() function at the
        # toplevel.
        IF usedFile.zimbuFile.isMainFile
          $writeInitLine(initDecl, early, outs, &didElse)
        }
      }
    }
  }

  # Write code for initialization, Init() function call.
  # And recurse into nested classes and methods.
  PROC $classInit(Declaration decl, bool early,
                               Output.Group outs, bool &didElse, SContext ctx)
    Type type = decl.type
    # Only do modules and do a class if it is not a template.
    IF (type.ttype == Type.Enum.class || type.ttype == Type.Enum.module)
          && !(decl.zuiDecl != NIL && decl.zuiDecl.hasType()
                   && decl.zuiDecl.getType().getType() == Zui.TypeEnum.eALIAS)
          && (type.getClassType(ctx) == NIL
                                || type.getClassType(ctx).templateList == NIL)
          && decl.pName != NIL
          && (!Generate.skipUnused() || $isDeclUsed(decl))
      Declaration initDecl = type.findMember(early ? "EarlyInit" : "Init", NIL)
      IF initDecl != NIL && initDecl.type.ttype == Type.Enum.func
        $writeInitLine(initDecl, early, outs, didElse)
      }

      # Do nested classes and modules
      VAR declDict = type.getDeclDict()
      IF declDict != NIL
        FOR ndeclList IN declDict.values()
          FOR ndecl IN ndeclList
            $classInit(ndecl, early, outs, didElse, ctx)
          }
        }
      }
    }
  }

  # Write code for one initialization, EarlyInit() or Init() function call.
  PROC $writeInitLine(Declaration init, bool early,
                                             Output.Group outs, bool &didElse)
    IF init == NIL
      # There is no Init() function, the module is always ready.
      RETURN
    }

    string readyName = init.pName
    IF early
      readyName ..= "__e"
    ELSE
      readyName ..= "__r"
    }

    Output out = early ? outs.earlyInitOut : outs.initOut

    # The module or class defines an Init() function.
    # In the first round reset "done" but don't call it yet.
    # In following rounds call it until it returns OK.
    IF !didElse
      out.write("  done = 0;\n")
      IF early
        out.write("  } else if (round > 1 && round < 2000) {\n")
      ELSE
        out.write("  } else if (round > 2001) {\n")
      }
      didElse = TRUE
    }
    $writeReadyCheck(readyName, init.pName, out)
  }

  PROC $writeReadyCheck(string readyName, string pName, Output out) @default
    out.write("    if (\(readyName) == 0) {\n")
    out.write("      \(readyName) = \(pName)();\n")
    out.write("      done &= \(readyName);\n")
    out.write("    }\n")
  }

  # Remember which functions have been generated, don't do one twice.
  # Key is a concatenation of class, argument, etc.
  dict<string, Declaration.C> $virtualFuncMap

  # Write declaration output here, it's appended to declOut later.
  Output $virtualDeclOut

  # Write function body here, it's appended to bodyOut later.
  Output $virtualBodyOut

  # Write any collected virtual methods.
  PROC $writeVirtual(SContext ctx)
    IF $writing && ctx.scope ISA FileScope
      # Append the functions for virtual methods.
      ctx.outs.declOut.append($virtualDeclOut)
      $virtualDeclOut.clear()
      ctx.outs.bodyOut.append($virtualBodyOut)
      $virtualBodyOut.clear()
    }
  }

  # For C this would put the string in static memory.
  FUNC $writeStaticString(string value, SContext ctx) string @default
    RETURN value
  }

  CLASS FileTestMethods @items=public
    list<tuple<MethodType, string>>  $testMethodsList = NEW()
    MethodType                       $setUp
    MethodType                       $tearDown
    string                           $filePname
  }

  dict<ZimbuFile, FileTestMethods> $testMethods

  PROC $addTestMethod(MethodType method, SContext ctx)
    IF $testMethods == NIL
      $testMethods = NEW()
    }
    ZimbuFile zf = method.scope.topZimbuFile()
    FileTestMethods ftm
    IF $testMethods.has(zf)
      ftm = $testMethods.get(zf)
    ELSE
      ftm = NEW()
      $testMethods.add(zf, ftm)
      ftm.filePname = $writeStaticString(zf.filename, ctx)
    }

    IF method.name == "setUp"
      IF ftm.setUp != NIL
        LOG.error("Two setUp methods in \(zf.filename)")
      }
      ftm.setUp = method
    ELSEIF method.name == "tearDown"
      IF ftm.tearDown != NIL
        LOG.error("Two tearDown methods in \(zf.filename)")
      }
      ftm.tearDown = method
    ELSE
      string methodPname = $writeStaticString(method.name, ctx)
      ftm.testMethodsList.add([method, methodPname])
    }
  }

  # Common string concatenation for JS and Java using "+".
  PROC $commonConcatStringOp(Zui.Expression expr, Declaration.C null2nil,
                                                SContext ctx, Type destType)
    Zui.Expression left = expr.getLeft()
    IF left.getType() == Zui.ExprType.eSTRING
      Generate.genExprDoConv(left, ctx, destType)
      ctx.out.write(" + ")
    ELSE
      $setDeclUsed(null2nil)
      ctx.out.write("Znull2nil(")
      Generate.genExprDoConv(left, ctx, destType)
      ctx.out.write(") + ")
    }
    Zui.Expression right = expr.getRight()
    IF right.getType() == Zui.ExprType.eSTRING
      Generate.genExprDoConv(right, ctx, destType)
    ELSE
      $setDeclUsed(null2nil)
      ctx.out.write("Znull2nil(")
      Generate.genExprDoConv(right, ctx, destType)
      ctx.out.write(")")
    }
  }

  SHARED

    # Values OR'd together for "did_goto_finally" and the "rt" variable. This
    # is used to decide what must happen after the FINALLY block and at the
    # end of a scope.
    int scopeReturn = 1    # RETURN was used
    int scopeBreak = 2     # BREAK was used
    int scopeContinue = 4  # CONTINUE was used

    # Return a list of all possible objects for superclass |type|.
    FUNC interfaceClassList(ClassType type, list<Declaration> resultList,
                                               SContext ctx) list<Declaration>
      list<Declaration> olist = resultList ?: NEW()
      IF type.countClass()
        Declaration decl = type.getValueType(ctx)
        bool found
        FOR d IN olist
          IF d IS decl
            # If |type| is an interface we may encounter the same class twice.
            found = TRUE
            BREAK
          }
        }
        IF !found
          olist.add(decl)
        }
      }

      FOR child IN type.children
        interfaceClassList(child, olist, ctx)
      }
      FOR child IN type.implementers
        interfaceClassList(child, olist, ctx)
      }
      RETURN olist
    }

    # Generate binary operator with int values.
    # Common for all C-like languages.
    FUNC numberOp(Zui.Expression expr, SContext ctx) Type
      ZuiExpressionExt exprExt = expr
      ctx.out.write("(")
      Type destType = exprExt.leftExprType ?: Type.anInt
      Type leftType = Generate.genExpr(expr.getLeft(), ctx, destType)
      string op
      SWITCH expr.getType()
        CASE Zui.ExprType.eBIT_AND;     op = " & "
        CASE Zui.ExprType.eBIT_OR;      op = " | "
        CASE Zui.ExprType.eBIT_XOR;     op = " ^ "
        CASE Zui.ExprType.eSHIFT_RIGHT; op = " >> "
        CASE Zui.ExprType.eSHIFT_LEFT;  op = " << "
        CASE Zui.ExprType.eMULTIPLY;    op = " * "
        CASE Zui.ExprType.eDIVIDE;      op = " / "
        CASE Zui.ExprType.eREMAINDER;   op = " % "
        CASE Zui.ExprType.eADD;         op = " + "
        CASE Zui.ExprType.eSUBTRACT;    op = " - "
        DEFAULT
             Report.internal("numberOp not implemented: \(expr.getType())")
      }
      ctx.out.write(op)
      Type rightType = Generate.genExpr(expr.getRight(), ctx, destType)
      ctx.out.write(")")

      IF exprExt.leftExprType?.ttype == Type.Enum.bitsValue
        # Verify that the bits type matches and only contains bool members.
        IF leftType ISNOTA BitsValueType || rightType ISNOTA BitsValueType
          Report.error("Left or right is not a BITS value")
        ELSEIF leftType.<BitsValueType>.bitsType
                                      ISNOT rightType.<BitsValueType>.bitsType
          Report.error("Left and right of operator must be the same BITS type")
        ELSEIF !leftType.<BitsValueType>.bitsType.isAllBool()
          Report.error("operator on BITS type only possible for bool members")
        }
      }
      RETURN destType
    }

    PROC incrdecrOp(Zui.Expression expr, SContext ctx)
      Zui.ExprType type = expr.getType()
      IF type == Zui.ExprType.ePRE_INC
        ctx.out.write("++")
      ELSEIF type == Zui.ExprType.ePRE_DEC
        ctx.out.write("--")
      }
      ctx.out.write("(")
      Generate.genExpr(expr.getRight(), ctx, Type.anInt)
      ctx.out.write(")")
      IF type == Zui.ExprType.ePOST_INC
        ctx.out.write("++")
      ELSEIF type == Zui.ExprType.ePOST_DEC
        ctx.out.write("--")
      }
    }

    FUNC compareOp(Zui.Expression expr) string
      SWITCH expr.getType()
        CASE Zui.ExprType.eEQUAL
        CASE Zui.ExprType.eIS
          RETURN " == "
        CASE Zui.ExprType.eNOTEQUAL
        CASE Zui.ExprType.eISNOT
          RETURN " != "
        CASE Zui.ExprType.eGREATER
          RETURN " > "
        CASE Zui.ExprType.eGREATER_EQUAL
          RETURN " >= "
        CASE Zui.ExprType.eLESS
          RETURN " < "
        CASE Zui.ExprType.eLESS_EQUAL
          RETURN " <= "
      }
      RETURN ""
    }

    PROC andorOp(Zui.Expression expr, SContext ctx)
      ctx.out.write("(")
      Generate.genExpr(expr.getLeft(), ctx, Type.aBool)
      IF expr.getType() == Zui.ExprType.eAND
        ctx.out.write(" && ")
      ELSE
        ctx.out.write(" || ")
      }
      Generate.genExpr(expr.getRight(), ctx, Type.aBool)
      ctx.out.write(")")
    }

    FUNC altOp(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
      ctx.out.write("((")
      ctx.gen.wrapExpr(expr.getCond(), ctx, Type.aBool)
      ctx.out.write(") ? (")
      ctx.gen.wrapExprConv(expr.getLeft(), ctx, exprArg)
      ctx.out.write(") : (")
      Type typeR = ctx.gen.wrapExprConv(expr.getRight(), ctx, exprArg)
      ctx.out.write("))")
      # TODO: if destType is NIL check syml and symr are the same type
      RETURN typeR
    }

    # Keyword characters that can be used for an ID.
    # The first one is Iaa, I. is reserved for often used keywords.
    string charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
                     .. "_0123456789"
    int charsetSize = charset.Size()
    dict<string, int> %usedIds = NEW()

    # Return a unique ID with a minimal number of characters, seeded by a
    # name.  Usually the returned ID is the same if the seed is the same, but
    # it's guaranteed to be unique.
    FUNC getUid(string seed) string
      string ret
      ret = "Y"
      int nr = seed.hash()
      IF nr < 0
        nr = -nr  # fix nat to int overflow
      }

      # Usually three characters are sufficient.
      FOR i IN 1 TO 3
        ret ..= charset[nr % charsetSize].asString()
        IF nr < charsetSize
          BREAK
        }
        nr = nr / charsetSize - 1
      }

      WHILE %usedIds.has(ret)
        # This ID already exists, add additional characters until it is unique.
        nr = %usedIds[ret]
        %usedIds[ret] = nr + 1
        ret ..= charset[nr % charsetSize].asString()
      }
      %usedIds.add(ret, 0)

      RETURN ret
    }


    # Bits assignment of |rhs| to |lhs|, of type |bitsMember|.
    # Return the number of undefined symbols in |lhs|.
    FUNC bitsAssign(Zui.Expression lhs, Zui.Expression rhs,
                                     ValueType bitsMember, SContext ctx) int
      # Assignment to a BITS field requires some more work:
      #  Zimbu: myFlags.on = someExpr
      #  C:     myFlags = ((myFlags) & ~mask) | ((someExpr) << shift)
      #  for int:  myFlags = ((myFlags) & ~mask) | (((someExpr) & mask) << shift)
      ctx.out.write("((")
      Generate.generateVarname(lhs, ctx, NIL)
      int shift = bitsMember.shift
      ctx.out.write(") & " .. ~(bitsMember.mask << shift) .. ") | (((")
      # TODO: proper handling of Nat
      Type retType = bitsMember
      IF retType.ttype == Type.Enum.nat
        retType = Type.anInt
      }
      Generate.genExpr(rhs, ctx, retType)
      ctx.out.write(") & " .. bitsMember.mask)
      IF shift == 0
        ctx.out.write("))")
      ELSE
        ctx.out.write(") << " .. shift .. ")")
      }
      RETURN lhs.<ZuiExpressionExt>.undefined
    }

    PROC bitsMemberBool(Zui.Expression left, ValueType memberType,
                                                                 SContext ctx)
      ctx.out.write("(((")
      Generate.genExpr(left, ctx)
      int shift = memberType.shift
      ctx.out.write(") & " .. (1 << shift) .. ")")
      # We would need TRUE be 1 and not any non-zero value when it's again
      # used to set a bits field.
      IF shift > 0
        ctx.out.write(" >> " .. shift)
      }
      ctx.out.write(")")
    }

    # An int (or nat) member of a BITS
    PROC bitsMemberInt(Zui.Expression left, ValueType memberType,
                                                                 SContext ctx)
      # Getting a Nat out of a BITS:
      #    (((expr) & (mask << shift)) >> shift)
      # Getting an int  out of a BITS:
      #    ZFixSign((((expr) & (mask << shift)) >> shift),
      #                                            ~(mask >> 1))
      IF memberType.ttype == Type.Enum.int
        ctx.gen.setDeclUsed(%fixSign)
        ctx.out.write("ZFixSign(")
      }
      ctx.out.write("(((")
      Generate.genExpr(left, ctx)
      int shift = memberType.shift
      ctx.out.write(") & " .. (memberType.mask << shift) .. ")")
      IF shift > 0
        ctx.out.write(" >> " .. shift)
      }
      ctx.out.write(")")
      IF memberType.ttype == Type.Enum.int
        ctx.out.write(", " .. ~(memberType.mask >> 1) .. ")")
      }
    }

    # UNITL of a DO block.
    FUNC until(Zui.Condition cond, SContext ctx) int
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("if (")
      Generate.genExpr(cond.getCond(), ctx, Type.aBool)
      ctx.out.write(") break;\n")
      RETURN cond.getCond().<ZuiExpressionExt>.undefined
    }

    # Declarations to keep track of used items.
    Declaration.C %fixSign = NEW("fixSign")

    # One function argument used for ToString().
    PROC oneToStringArgument(Type type, Zui.MethodCall call,
                                                 bool useQuotes, SContext ctx)
      oneToStringArgument(type, call.getPos(),
                           &call.<ZuiMethodCallExt>.undefined, useQuotes, ctx)
    }

    # One function argument used for ToString().
    PROC oneToStringArgument(Type type, Zui.Position pos, int &undef,
                                                 bool useQuotes, SContext ctx)
      IF type == NIL
        RETURN
      }
      ctx.addUsedItem(Declaration.itemToString)
      IF !ctx.gen.writing
        # Find the ToString function and mark it as used.
        IF type.ttype == Type.Enum.object || type.ttype == Type.Enum.iobject
          findToStringMethod(NIL, NIL, type, pos, undef, ctx)
        ELSEIF type.ttype == Type.Enum.enumValue
          EnumType et = type.<EnumValueType>.enumType
          IF et.usedValueName == NIL
            et.usedValueName = NEW("usedValueName")
          }
          ctx.addUsedItem(et.usedValueName)
        ELSEIF type.ttype == Type.Enum.tuple
          type.<TupleType>.usingToString(ctx)
        }
      ELSE
        IF useQuotes
          ctx.gen.writeTrueArgument(ctx.out)
        ELSE
          ctx.gen.writeFalseArgument(ctx.out)
        }
      }
    }

    # Find the ToString method of a class.
    # |decl| is the class declaration.
    # |cond| must be used for the ToString method to be marked as used.
    FUNC findToStringMethod(Declaration decl, Declaration cond,
              Type ct, Zui.Position pos, int &undef, SContext ctx) Declaration
      Declaration func = ct.findMatchingMethod("ToString",
                                       TRUE, [], NIL, :skipShared, undef, ctx)
      IF func != NIL
        ctx.addUsedItem(func)
        IF decl != NIL
          # Class depends on the function.
          decl.addDependsOnCond(func, cond, ctx.gen)
        }
      }
      # Need to mark the ToString() method of other classes as used.
      IF ct.ttype == Type.Enum.iobject
        ctx.gen.iobjectUseFunc("ToString", pos, undef, ct, func, ctx)
      }
      RETURN func
    }

    # Return the type index of |type|.
    # This code uses TYPE_NUMBERS, keep in sync!
    FUNC getArgumentType(Type type, Zui.Position pos, int &undef,
                                                             SContext ctx) int
      # Argument for item type
      SWITCH type.getTtype()
        #
        # Integer value types: 0 - 79
        #
        CASE Type.Enum.int
          RETURN 0
        CASE Type.Enum.int8
          RETURN 1
        CASE Type.Enum.int16
          RETURN 2
        CASE Type.Enum.int32
          RETURN 3

        # Natural value types: 10 - 19
        CASE Type.Enum.nat
          RETURN 10
        CASE Type.Enum.byte
          RETURN 11
        CASE Type.Enum.nat16
          RETURN 12
        CASE Type.Enum.nat32
          RETURN 13

        CASE Type.Enum.bool
          RETURN 21
        CASE Type.Enum.status
          RETURN 22
        CASE Type.Enum.enumValue
          RETURN 23
        # TODO: module returns 24 (was 4)
        CASE Type.Enum.bitsValue
          RETURN 25

        #
        # Float value types: 80 - 99
        #
        CASE Type.Enum.float
          RETURN 80
        CASE Type.Enum.float32
          RETURN 81
        CASE Type.Enum.float80
          RETURN 82
        CASE Type.Enum.float128
          RETURN 83

        #
        # Reference types that are not allocated: 100 - 199
        #
        CASE Type.Enum.type
          RETURN 101

        #
        # Reference types that are allocated and do not contain an allocated
        # type: 200 - 299
        #
        CASE Type.Enum.string
          RETURN 200
        CASE Type.Enum.byteString
          RETURN 201

        # thread: 250
        # cond: 251
        # lock: 252
        # autoLock: 253

        #
        # Reference types that are allocated and possibly contain an allocated
        # type: 300 - 399
        #
        CASE Type.Enum.array
          RETURN 300
        CASE Type.Enum.list
          RETURN 301
        CASE Type.Enum.dict
          RETURN 302

        CASE Type.Enum.varString
          RETURN 310
        CASE Type.Enum.varByteString
          RETURN 311

        CASE Type.Enum.tuple
          RETURN 320

        CASE Type.Enum.callback
        CASE Type.Enum.procRef
        CASE Type.Enum.funcRef
          RETURN 330

        CASE Type.Enum.dyn
          RETURN 360

        CASE Type.Enum.object
          Declaration func = type.findMatchingMethod("ToString",
                                       TRUE, [], NIL, :skipShared, undef, ctx)
          IF func != NIL
            ctx.addUsedItem(func)
          ELSE
            ++undef
          }
          RETURN 390
        CASE Type.Enum.iobject
          Declaration func = type.findMatchingMethod("ToString",
                                       TRUE, [], NIL, :skipShared, undef, ctx)
          ctx.gen.iobjectUseFunc("ToString", pos, undef, type, func, ctx)
          RETURN 391

        DEFAULT
          IF ctx.doError()
            ctx.error("Unsupported item type for ToString(): "
                                           .. type.getTtype().ToString(), pos)
          }
      }
      RETURN -1
    }

    set<Declaration> newPosStringUsedDecl
    dict<Declaration, set<Declaration>> newPosStringUsedDeclCond

    # get a string with code to generate a Z.Pos for |posn|.
    FUNC newPosString(Zui.Position posn, SContext ctx) string
      IF !ctx.gen.writing
           && (newPosStringUsedDecl != NIL || newPosStringUsedDeclCond != NIL)
        # Already figured out the dependencies, no need to produce the same
        # code again.
        IF newPosStringUsedDecl != NIL
          ctx.scope.addUsedItems(newPosStringUsedDecl)
        }
        IF newPosStringUsedDeclCond != NIL
          Declaration savedCond = ctx.scope.usedCondition
          FOR cond IN newPosStringUsedDeclCond.keys()
            ctx.scope.usedCondition = cond
            ctx.scope.addUsedItems(newPosStringUsedDeclCond[cond])
          }
          ctx.scope.usedCondition = savedCond
        }
        RETURN ""
      }

      ctx.scope.wantBacktrace = TRUE

      Z.Pos pos = ctx.zcPos(posn)

      # Z.Pos.NEW()
      Zui.MethodCall call = NEW()
      call.setPos(posn)
      Zui.Expression name = call.newName().setType(Zui.ExprType.eMEMBER)
      name.setPos(posn)

      Zui.Expression zcName = name.newLeft().setType(Zui.ExprType.eID)
      zcName.setName("Z")
      zcName.setPos(posn)

      name.newRight().setType(Zui.ExprType.eID)
                     .setName("Pos")

      # (filename, lnum, col)
      Zui.Expression expr = NEW().setType(Zui.ExprType.eSTRING)
      expr.setPos(posn)
          .setStringValue(pos.filename)
      call.addArgument(expr)

      expr = NEW().setType(Zui.ExprType.eINT)
      expr.setNumber(pos.lnum)
      call.addArgument(expr)

      expr = NEW().setType(Zui.ExprType.eINT)
      expr.setNumber(pos.col)
      call.addArgument(expr)

      SContext tmpCtx = ctx.copyNewOut()
      int undef
      set<Declaration> usedDecl
      dict<Declaration, set<Declaration>> usedDeclCond
      IF !ctx.gen.writing
        usedDecl = ctx.scope.swapUsedDecl(newPosStringUsedDecl)
        usedDeclCond = ctx.scope.swapUsedDeclCond(newPosStringUsedDeclCond)
      }
      Generate.generateNewCall(&undef, call, name, tmpCtx, FALSE, NIL)
      IF !ctx.gen.writing
        # Remember which Declarations were used in the NEW call.
        newPosStringUsedDecl = ctx.scope.restoreUsedDecl(usedDecl)
        newPosStringUsedDeclCond = ctx.scope.restoreUsedDeclCond(usedDeclCond)
      }
      RETURN tmpCtx.out.ToString()
    }

    # Write byteString as used inside a C string.
    # Handle limited set of special characters.  The rest is done with octal.
    PROC writeByteString(byteString s, Output out)
      FOR i IN 0 UNTIL s.Size()
        int c = s[i]
        IF c == '\n'
          out.write("\\n")
        ELSEIF c == '\r'
          out.write("\\r")
        ELSEIF c == '\t'
          out.write("\\t")
        ELSEIF c == '"'
          out.write("\\\"")
        ELSEIF c == '\\'
          out.write("\\\\")
        ELSEIF c < 32 || c >= 127
          out.write(Generate.toOctal(c))
        ELSE
          out.write(c.asString())
        }
      }
    }

    # Write |s| as used inside a Javascript string.
    # Handle limited set of special characters.  The rest is done literally.
    PROC writeString(string s, Output out)
      FOR i IN 0 UNTIL s.Size()
        int c = s[i]
        IF c == '\n'
          out.write("\\n")
        ELSEIF c == '\r'
          out.write("\\r")
        ELSEIF c == '\t'
          out.write("\\t")
        ELSEIF c == '"'
          out.write("\\\"")
        ELSEIF c == '\\'
          out.write("\\\\")
        ELSEIF c < 32
          out.write(Generate.toOctal(c))
        ELSE
          out.write(c.asString())
        }
      }
    }

    #= Return TRUE if the expression evaluates to a fixed integer.
    FUNC exprIsFixedInt(Zui.Expression expr, SContext ctx) bool
      bool isContextFree
      ExprEval.evalInt(expr, ctx, FALSE, &isContextFree)
      RETURN isContextFree
    }

    # Return TRUE if this statement has the arguments of a FOR loop with ints
    # only.
    FUNC simpleForLoop(Zui.ForStatement stmt, SContext ctx) bool
      RETURN exprIsFixedInt(stmt.getIter(0), ctx)
          && stmt.hasTo() && exprIsFixedInt(stmt.getTo(), ctx)
          && (!stmt.hasStep() || exprIsFixedInt(stmt.getStep(), ctx))
    }

    dict<string, string> typeStructs = [
        "int": "int__T",
        "int8": "int8__T",
        "int16": "int16__T",
        "int32": "int32__T",
        "bits": "int__T",
        "nat": "nat__T",
        "byte": "byte__T",
        "nat16": "nat16__T",
        "nat32": "nat32__T",
        "bool": "bool__T",
        "status": "status__T",
        "float": "float__T",
        "string": "string__T",
        "byteString": "byteString__T",
        "varString": "varString__T",
        "varByteString": "varByteString__T",
        "thread": "thread__T",
        "dyn": "dyn__T",
        "type": "type__T",
        ]

    # Write the third argument of array.set(): the type of the second set()
    # argument.
    PROC writeItemType(Type argType, Type itemType,
                                               Zui.Position pos, SContext ctx)
      Type t
      IF argType.ttype == Type.Enum.byteString
        ctx.out.write(", 0, ")
        t = Type.aByte
      ELSEIF argType.ttype == Type.Enum.array
        ctx.out.write(", 1, ")
        t = argType.<ContainerType>.itemType
      ELSEIF argType.ttype == Type.Enum.list
        ctx.out.write(", 2, ")
        t = argType.<ContainerType>.itemType
      ELSE
        ctx.error("Unsupported type for array.set(): "
                                                   .. argType.typeName(), pos)
      }
      IF t != NIL && !Type.compatibleTypes(t, itemType, ctx)
        ctx.error("Incompatible type for array.set(): "
                                                   .. argType.typeName(), pos)
      }
    }

    # Get the return type of |method|.
    FUNC getFuncReturnType(Zui.MethodType method, SContext ctx) Type
      Type retType

      list<Declaration> types
      IF method.sizeReturnType() > 1
        types = NEW()
      }

      FOR t IN method.getReturnTypeList()
        Zui.Expression expr = t.getName()
        IF expr.getType() == Zui.ExprType.eTHIS
          # Returning THIS, the object itself.
          retType = ctx.scope.classType.getValueType(ctx)
        ELSE
          retType = Generate.generateDeclType(expr,
                      ctx.copyNoOut(TRUE), :isDecl + :dotI + :markUsed,
                      NEW(expr.getPos(), ctx))
        }
        IF types != NIL && retType != NIL
          types.add(retType.getValueType(ctx))
        }
      }
      IF types != NIL
        retType = MultipleType.get(types, ctx)
      }
      RETURN retType
    }

    # Return a name for the virtual function |methodName| on object
    # |objectType| with arguments |arglist|.
    # Note: this changes |argList| to useful types.
    FUNC virtualFuncName(Type objectType, list<Declaration.C> arglist,
                string methodName, MethodType methodType, SContext ctx) string
      string funcName = objectType.getClassType(ctx).pName
      IF objectType.ttype == Type.Enum.iobject
        funcName ..= "_I"
      }
      string objectArgName = ""
      IF arglist != NIL
        VAR pArglist = methodType.arguments
        FOR i IN 0 UNTIL arglist.Size()
          Declaration.C d = arglist[i]
          IF d != NIL
            IF d.type.ttype == Type.Enum.unknown
                || d.type.ttype == Type.Enum.nilval
                || (d.type ISA ContainerType
                                  && d.type.<ContainerType>.itemType == NIL)
                || d.type.isValueType()
              # The argument is NEW(), NIL or [], use the argument type
              # of the found method.
              # For value types also use the argument type of the found
              # method.  E.g., for a "9" (natval) may use an "int" type.
              d = pArglist[i]
              arglist[i] = d
            }
            IF d.type.ttype == Type.Enum.iobject
              objectArgName ..= "__" .. d.type.getClassType(ctx).pName .. "_I"
            ELSEIF d.type.ttype == Type.Enum.object
                                            || d.type.ttype == Type.Enum.class
              objectArgName ..= "__" .. d.type.getClassType(ctx).pName
            ELSE
              objectArgName ..= "__" .. d.type.ttype.ToString()
            }
          }
        }
      }
      RETURN funcName .. "__M" .. methodName .. "_I" .. objectArgName
    }

    # Arguments for $generateVirtualFunc()
    CLASS VirtFuncArgs @items=public
      string              $funcKey
      Type                $varType
      string              $methodName
      Zui.Position        $pos
      int                 $undef
      list<Declaration.C> $callArglist
      bool                $haveTwoMethods
      list<int>           $indexes
      Type                $retType
      MethodType          $retTypeMethod
    }

    # Make a list with list of possible symbols for THIS and each argument.
    # altList[0] for A0 THIS  
    # altList[1] for A1 arg 1
    # altList[1] for A2 arg 2
    # etc.
    FUNC getDeclAltList(VirtFuncArgs args, SContext ctx
                       ) list<list<Declaration>>
      list<list<Declaration>> altList = NEW()
      
      # Fill altList[0]: THIS
      list<Declaration> alist
      IF args.varType.ttype == Type.Enum.iobject
                                  || args.varType.ttype == Type.Enum.interface
        ClassType class = args.varType.getClassType(ctx)

        IF !ctx.doError()
          # Another class might be added later, therefore always come back here
          # when that happens.
          class.scope.addScopeDependency(ctx.scope)
        }
        alist = interfaceClassList(class, NIL, ctx)
        IF alist.Size() == 0
          IF ctx.doError()
            ctx.error("No classes implementing " .. class.name, args.pos)
          }
          RETURN NIL
        }
      ELSE
        alist = NEW()
        Type t = args.varType.getValueType(ctx)
        alist.add(t)
      }
      altList.add(alist)

      # Find all functions for the possible classes that have the right name
      # and number of arguments.
      list<Declaration> functions = NEW()
      FOR l IN alist
        addMatchingMethods(args.methodName, l.type, args.callArglist.Size(),
                                                                    functions)
      }
      IF functions.Size() == 0  # No matching functions
        args.undef += 10
        IF ctx.doError()
          ctx.error("No matching methods for " .. args.methodName, args.pos)
        }
        RETURN NIL
      }

      # Fill altList[1] and further from the argument types.
      FOR di IN 0 UNTIL args.callArglist.Size()
        Declaration.C d = args.callArglist[di]
        IF d == NIL || d.type == NIL
          args.undef += 10  # Error is given where arg is parsed.
          RETURN NIL
        }
        IF d.type.ttype == Type.Enum.iobject
          # If all possible functions have the same argument type there is no
          # need to try all possible implementing classes.  This saves an
          # awful lot of time.
          alist = NIL
          Declaration.C validArg
          FOR f IN functions
            IF f.type ISNOTA MethodType
              args.undef += 10
              RETURN NIL
            }
            Declaration.C arg = f.type.<MethodType>.getArgList()[di]
            IF arg.type != NIL && arg.type.ttype != Type.Enum.unknown
              IF validArg == NIL
                validArg = arg
              ELSE
                IF !Type.matchingTypes(validArg.type, arg.type, ctx)
                  # Two possible types for this argument, add all possible
                  # types to find the right method (with conversion etc.).
                  alist = interfaceClassList(d.type.getClassType(ctx), NIL, ctx)
                  IF alist.Size() == 0
                    args.undef += 10
                    IF ctx.doError()
                      ctx.error("No classes implement "
                                   .. d.type.getClassType(ctx).name, args.pos)
                    }
                    RETURN NIL
                  }
                  BREAK
                }
              }
            }
          }
          IF alist == NIL
            IF validArg == NIL
              # No argument type on any possible function.
              args.undef += 10
              IF ctx.doError()
                ctx.error("Unknown argument type for " .. args.methodName,
                                                                     args.pos)
              }
              RETURN NIL
            }

            # All methods use the same type for this arg.
            alist = NEW()
            alist.add(validArg)
          }
        ELSE
          alist = NEW()
          IF d.type == NIL
            IF ctx.doError()
              ctx.error("Unknown type for " .. d.name, args.pos)
            }
            args.undef += 5
            RETURN NIL
          }
          Type t = d.type.getValueType(ctx)
          Declaration.C td = NEW("copy")
          td.type = t
          alist.add(td)
        }
        altList.add(alist)
      }

      RETURN altList
    }

    # Get a list of all functions called |name| in |parent| with |argCount|
    # arguments.  Does not check visibility. Excludes abstract methods.
    PROC addMatchingMethods(string name, Type parent, int argCount,
                                                  list<Declaration> functions)
      Type type = parent
      WHILE type != NIL
        IF type.getObjectDeclDict() != NIL
          FOR l IN type.getObjectDeclDict().values()
            FOR decl IN l
              IF decl.name == name && !decl.type.isAbstract()
                                  && decl.type.getArgList().Size() == argCount
                functions.add(decl)
              }
            }
          }
        }
        IF type ISNOTA ClassType
          BREAK
        }
        type = type.<ClassType>.parent
      }
    }

    FUNC createAltList(VirtFuncArgs args, SContext ctx
                      ) list<list<Declaration>>
      # Make a list with list of possible symbols for THIS and each argument.
      # altList[0] for A0 THIS
      # altList[1] for A1 arg 1
      # altList[1] for A2 arg 2
      # etc.
      list<list<Declaration>> altList = getDeclAltList(args, ctx)
      IF altList == NIL
        RETURN NIL
      }

      args.indexes = NEW()
      FOR l IN altList
        args.indexes.add(0)
      }

      # Find out for what arguments with more than one possible type, the type
      # makes us pick another method.  If the type doesn't matter, just use the
      # first one.  This avoids adding a switch where all alternatives are
      # equal.
      FOR tryIdx IN 0 UNTIL altList.Size()
        IF altList[tryIdx].Size() > 1
          # For every possible combination of types for arguments other than
          # tryIdx see if the picked method changes if we use a different type
          # for tryIdx.
          bool pickedAnother = FALSE
          args.indexes.map({ i => 0 })
          WHILE !pickedAnother
            # Gather the arguments for this combination.
            args.indexes[tryIdx] = 0
            list<Declaration.C> argtry = NEW()
            FOR idx IN 1 UNTIL altList.Size()
              Declaration.C decl = NEW("")
              decl.type = altList[idx][args.indexes[idx]].type
              argtry.add(decl)
            }

            # Try every type of altList[tryIdx], see if the picked method
            # changes
            Type pickedMethod
            FOR tryIdxVal IN 0 UNTIL altList[tryIdx].Size()
              args.indexes[tryIdx] = tryIdxVal
              IF tryIdx > 0 && tryIdxVal > 0
                # Change the argument at tryIdx to tryIdxVal
                argtry[tryIdx - 1].type = altList[tryIdx][tryIdxVal].type
              }
              Declaration object = altList[0][args.indexes[0]]
              Declaration mdecl
              mdecl = Generate.findMethodArglist(object.type, args.methodName,
                                    TRUE, argtry, NIL, ctx, TRUE,
                                    :searchParent + :allowInvisible,
                                    ctx.doError(), args.pos, "", &args.undef)
              IF mdecl == NIL
                # can't find method, error given elsewhere
                pickedAnother = TRUE
                BREAK
              }
              # Compare the methods using pName, several declarations can
              # stand for the same produced method.
              IF pickedMethod == NIL
                pickedMethod = mdecl.type
              ELSEIF mdecl.type.pName != pickedMethod.pName
                pickedAnother = TRUE
                BREAK
              }
            }
            IF pickedAnother
              BREAK
            }

            # Next combination of arguments other than tryIdx.
            bool didinc
            FOR i IN 0 UNTIL args.indexes.Size()
              IF i != tryIdx && altList[i].Size() > 1
                IF args.indexes[i] + 1 < altList[i].Size()
                  ++args.indexes[i]
                  didinc = TRUE
                  BREAK
                }
                args.indexes[i] = 0
              }
            }
            IF !didinc
              BREAK
            }
          }

          IF !pickedAnother
            # type of this argument doesn't matter, set its size to one.
            altList[tryIdx].remove(1, -1)
          }
        }
      }

      # If there is only one matching function we can skip all the conditions
      # and just write that one.
      # TODO: can skip a lot of stuff now that we figure out haveTwoMethods
      # early.
      FOR l IN altList
        IF l.Size() > 1
          args.haveTwoMethods = TRUE
          ctx.addUsedItem(Declaration.throwCstringBadValue)
          BREAK
        }
      }

      args.indexes.map({ i => 0 })

      RETURN altList
    }

    FUNC virtFuncFindMethod(VirtFuncArgs args,
                            list<list<Declaration>> altList,
                            list<Declaration.C> argtry, SContext ctx
                           ) Declaration
      FOR idx IN 1 UNTIL altList.Size()
        Declaration.C decl = NEW("")
        decl.type = altList[idx][args.indexes[idx]].type
        argtry.add(decl)
      }

      Declaration object = altList[0][args.indexes[0]]
      Declaration mdecl
      mdecl = Generate.findMethodArglist(object.type, args.methodName, TRUE,
                  argtry, NIL,
                  ctx, TRUE, :searchParent + :allowInvisible,
                  ctx.doError(), args.pos, "", &args.undef)
      Type mtype = mdecl?.type
      IF mtype == NIL
        ++args.undef
        IF ctx.out.writing
          ctx.error("Missing implementation for " .. args.methodName
                                  .. " in " .. object.getName(TRUE), args.pos)
        }
      ELSE
        IF mtype.ttype == Type.Enum.func && mtype.<MethodType>.returnType != NIL
          # Check the return types of all methods are equal: store the return
          # type of the first method and compare it with all that follow.
          Type retType = mtype.<MethodType>.returnType
          IF args.retType == NIL
            args.retType = retType
            args.retTypeMethod = mtype
          ELSEIF !Type.matchingTypes(args.retType, retType, ctx)
            ++args.undef
            IF ctx.doError()
              Generate.typeError(args.retType, retType, args.pos, ctx)
              ctx.error("First method here", args.retTypeMethod.zuiDecl)
              ctx.error("Current method here", mtype.zuiDecl)
            }
          }
        }
      }
      RETURN mdecl
    }

    # Advance to the next class for the argument.
    # Return the updated |depth|.
    FUNC advanceToNextClass(list<list<Declaration>> altList,
                              VirtFuncArgs args, int depthArg, Output out) int
      int depth = depthArg
      int idx = altList.Size()
      WHILE idx > 0
        idx--
        IF depth > idx * 2
          depth--
        }
        IF altList[idx].Size() > 1
          args.indexes[idx]++
          IF args.indexes[idx] < altList[idx].Size()
            BREAK
          }
          args.indexes[idx] = 0
          IF depth > idx * 2
            depth--
            IF out != NIL
              out.write(" }}\n")
            }
          }
        ELSE
          depth--
        }
      }
      RETURN depth
    }

    # For an |expr| that is a dict value, figure out the key and value types.
    # Update |type|.
    # Give an error when the type can't be figured out.
    PROC getDictTypes(Zui.Expression expr, SContext ctx,
                                            ContainerType type, Type destType)
      IF expr.sizeDictItem() == 0
        # empty dict: [:]
        string error
        IF destType == NIL || destType.getTtype() != Type.Enum.dict
          error = "Type of Dict unknown"
        ELSE
          ContainerType ct = destType.getEffType()
          type.keyType = ct.keyType
          type.itemType = ct.itemType
          IF ct.keyType == NIL
            error = "key type of Dict unknown"
          }
          IF ct.itemType == NIL
            error = "item type of Dict unknown"
          }
        }
        IF error != NIL && ctx.doError()
          ctx.error(error, expr.getPos())
        }
      ELSE
        # Type is based on the first pair.
        Zui.ExprPair pair = expr.getDictItem(0)
        Type keyType
        Type itemType
        IF destType != NIL && destType.getTtype() == Type.Enum.dict
          ContainerType containerType = destType.getEffType()
          IF containerType.keyType != NIL
            keyType = containerType.keyType
          }
          IF containerType.itemType != NIL
            itemType = containerType.itemType
          }
        }
        type.keyType = Generate.genExpr(pair.getKey(), ctx.copyNoOut(), keyType)
        IF type.keyType == NIL
          IF ctx.doError()
            Generate.genExpr(pair.getKey(), ctx, keyType)
          }
        }
        IF keyType != NIL && keyType.isParentOf(type.keyType)
          # The destination specifies a parent of the key type, use that.
          type.keyType = keyType
        }

        type.itemType = Generate.genExpr(
                                   pair.getValue(), ctx.copyNoOut(), itemType)
        IF type.itemType == NIL
          IF ctx.doError()
            Generate.genExpr(pair.getValue(), ctx)
          }
        }
        IF itemType != NIL && itemType.isParentOf(type.itemType)
          # The destination specifies a parent of the item type, use that.
          type.itemType = itemType
        }
      }
    }

  }
}
