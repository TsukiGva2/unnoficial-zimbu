#
# The Zimbu compiler written in Zimbu
#
# WriteC class and module: Methods are invoked from Generate for each
# statement and expression to generate C code.
#
# Copyright 2009-2012 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

# Names used for the generated C code:
# A.*                   method argument
# C.*                   class name
# F.*                   function name
# I[a-z]                special purpose
# Iaa, Iab, Iaaa, etc.  Unique IDs from getUid()
# J.*                   Initialize function
# M.*                   module name
# V.*                   local variable
# Z.*                   internal function
#
# Typedefs:
# Ti   64 bit int
# Ti16 16 bit int
# Ti32 32 bit int
# Tip  int that can hold a pointer
# Tz   int that can hold any int, nat, float or pointer
# Tu   64 bit unsigned
# Tc   unsigned char, used for string, byteString
# Tu16 nat16
# Tu32 nat32
# Tb   bool
# Ts   status
# Te   enum
# Tbs  small BITS 32 bit
# Tbb  big BITS 64 bit
# Tj   xobject ref (has np and mt fields, like all objects)
# Tr   iobject ref
# To   object description
#
# Tf   float
# Tf32 float32
#
# Tx   dyn
# Tt   type
# Tto  type with object description
#
# Ty   varByteString, varString
# Tv   pieceval
# Tp   piece
# Tcd  cord
# Tg   grow array
#
# Tfe  FOR in enum
# Tfs  FOR in string
# Tfr  FOR in range
#
# Tcode  code location
# Tcb    callback, method reference with extra info
# Tn     environment struct
# Ta     array head
# Td     dict head
# Tl     list head
#

IMPORT.PROTO ../parser/zui.proto

IMPORT WriteArrayC.zu
IMPORT WriteListC.zu
IMPORT WriteDictC.zu
IMPORT WriteIMT.zu

IMPORT ../ArrayStuff.zu
IMPORT ../Arguments.zu
IMPORT ../BitsType.zu
IMPORT ../BitsValueType.zu
IMPORT ../BlockScope.zu
IMPORT ../Builtin.zu
IMPORT ../CallbackType.zu
IMPORT ../ClassRefType.zu
IMPORT ../ClassType.zu
IMPORT ../CodeTable.zu
IMPORT ../CodeWriter.zu
IMPORT ../Config.zu
IMPORT ../ContainerType.zu
IMPORT ../Conversion.zu
IMPORT ../DeclStore.zu
IMPORT ../Declaration.zu
IMPORT ../DictStuff.zu
IMPORT ../EnumType.zu
IMPORT ../EnumValueType.zu
IMPORT ../ExprArg.zu
IMPORT ../ExprEval.zu
IMPORT ../FileScope.zu
IMPORT ../ForLoopInfo.zu
IMPORT ../Generate.zu
IMPORT ../ListStuff.zu
IMPORT ../MainFile.zu
IMPORT ../ManageMemory.zu
IMPORT ../MethodRefType.zu
IMPORT ../MethodScope.zu
IMPORT ../MethodType.zu
IMPORT ../ModuleScope.zu
IMPORT ../ModuleType.zu
IMPORT ../MultipleType.zu
IMPORT ../NoAllocType.zu
IMPORT ../Output.zu
IMPORT ../ReferenceType.zu
IMPORT ../Report.zu
IMPORT ../Resolve.zu
IMPORT ../SContext.zu
IMPORT ../Scope.zu
IMPORT ../SwitchScope.zu
IMPORT ../SymUse.zu
IMPORT ../TargetLang.zu
IMPORT ../TopScope.zu
IMPORT ../TryScope.zu
IMPORT ../TupleType.zu
IMPORT ../Type.zu
IMPORT ../UsedFile.zu
IMPORT ../ValueType.zu
IMPORT ../WriteCommon.zu
IMPORT ../ZimbuFile.zu
IMPORT ../ZuiCodeBlockExt.zu
IMPORT ../ZuiExpressionExt.zu
IMPORT ../ZuiMethodCallExt.zu
IMPORT ../ZuiStatementExt.zu
IMPORT ../ZuiTryStatementExt.zu

# The methods that are implemented for the Resolve.I interface are commented
# in resolve.zu.
CLASS WriteC EXTENDS WriteCommon IMPLEMENTS Resolve.I
                           @public @items=public   # TODO: restrict visibility

  TargetLang $targetLang

  NEW()
    $writing = TRUE
    $targetLang.c = TRUE
    IF codeWriters == NIL
      codeWriters = NEW()
      initCodeWriters()
    }
  }

  FUNC $getLangName() string @replace
    RETURN "C"
  }

  FUNC $getTargetLang() TargetLang @replace
    RETURN $targetLang
  }

  FUNC $thisName(bool insideNew) string
    RETURN cThisName
  }

  PROC $writeThisName(SContext ctx)
    ctx.out.write(ctx.scope.getThisName())
  }

  PROC $writeClosureThis(SContext ctx)
  }

  PROC $writeTrueArgument(Output out)
    out.write(", 1")
  }

  PROC $writeFalseArgument(Output out)
    out.write(", 0")
  }

  # Write statement and line end, usually ";\n".
  PROC $statementLineEnd(Output out)
    out.write(";\n")
  }

  # Return TRUE if an abstract method method is not to be generated.
  FUNC $skipAbstractMethod() bool
    RETURN TRUE
  }

  # Return TRUE if a method from the parent is to be written in a child class.
  FUNC $doWriteParentMethod(Declaration decl) bool
    RETURN TRUE
  }

  PROC $startBlock(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("{\n")
  }

  # Write code for the end of a scope.
  # |willJump| is true when there is a jump next, no need to jump out of the
  # scope here.
  # |statements| can be NIL.
  PROC $writeScopeEnd(bool writeLabel, bool willJump,
               list<Zui.Statement> statements, Zui.Position pos, SContext ctx)
    bool needAStmt
    IF writeLabel && ctx.scope.retLabel != NIL
      ctx.out.write(ctx.scope.retLabel .. ":\n")
      # We need a statement after the label, unless in the method scope.
      needAStmt = ctx.scope ISNOTA MethodScope
    }

    IF ctx.scope.writeEndOfScope(ctx.out)
      needAStmt = FALSE
    }

    Zui.Statement lastStmt
    IF statements != NIL && statements.Size() > 0
      lastStmt = statements[-1]
    }

    # Call Finish for any objects located on the stack.
    # For a method scope it's done in $writeBeforeReturn().
    IF ctx.scope ISNOTA MethodScope
      $writeScopeEndFinish(lastStmt == NIL ? pos : lastStmt.getPos(), ctx)
    }

    bool isLoopOrSwitchScope =
                          ctx.scope.isLoopScope() || ctx.scope.isCaseScope()
    IF isLoopOrSwitchScope
      # When in the loop scope may break or continue.
      # Clear the break and continue flags from "rt", leaving only the flag
      # indicating return.
      IF ctx.scope.hasBreak
        ctx.out.writeIndent(ctx.scope.depth)
        ctx.out.write("if (rt == " .. scopeBreak)
        ctx.out.write(") { rt &= " .. scopeReturn .. "; break; }\n")
        needAStmt = FALSE
      }
      IF ctx.scope.hasContinue
        ctx.out.writeIndent(ctx.scope.depth)
        ctx.out.write("if (rt == " .. scopeContinue)
        ctx.out.write(") { rt &= " .. scopeReturn .. "; continue; }\n")
        needAStmt = FALSE
      }
    }

    IF ctx.scope ISNOTA MethodScope
           && !willJump
           && (ctx.scope.needRetFlag
               || (ctx.scope.hasBreak || ctx.scope.hasContinue)
                                                      && !isLoopOrSwitchScope)
      ctx.out.writeIndent(ctx.scope.depth)

      bool skipIf
      IF lastStmt != NIL && lastStmt.getType() == Zui.StatementType.eBREAK
        # The check for rt being non-zero is not needed after a BREAK, it is
        # always set to 2.  However, if this is inside a TRY with a FINALLY,
        # rt will not have be set.
        Scope s = ctx.scope.tryScope(TRUE, FALSE)
        IF s == NIL || !s.<TryScope>.hasFinally
          skipIf = TRUE
        }
      }
      IF !skipIf
        ctx.out.write("if (rt) ")
      }

      # At the end of a TRY block, if jumping out of it, need to restore
      # tryCtxUsed.
      IF ctx.scope.outer ISA TryScope
        ctx.out.write("{ te->tryCtxUsed = try_index; ")
      }
      $writeJumpToLabel(ctx)
      IF ctx.scope.outer ISA TryScope
        ctx.out.write(" }")
      }
      ctx.out.write("\n")

      needAStmt = FALSE
    }

    IF needAStmt
      # May not have written something after the label.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write(";\n")
    }
  }

  # Write a goto to the end of the outer scope.
  # Caller must write the indent.
  PROC $writeJumpToLabel(SContext ctx)
    ctx.out.write("goto ")
    IF ctx.scope.outer ISA TryScope
      IF ctx.scope.outer.outer.retLabel == NIL
        ctx.scope.outer.outer.retLabel = getUid(ctx.scope.scopeName)
      }
      ctx.out.write(ctx.scope.outer.outer.retLabel)
    ELSE
      IF ctx.scope.outer.retLabel == NIL
        ctx.scope.outer.retLabel = getUid(ctx.scope.scopeName)
      }
      ctx.out.write(ctx.scope.outer.retLabel)
    }
    ctx.out.write(";")
  }

  # Generate the interface member lookup table, when needed.
  PROC $interfaceMemberTable(Declaration decl, Declaration itfDecl,
                                                                 SContext ctx)
    Type itf = itfDecl.type
    IF decl.type.<ClassType>.countClass()
      Declaration useDecl = decl.isUsingInterface(itf, ctx)
      IF useDecl != NIL && $isDeclUsed(useDecl)
        WriteIMT.generateInterfaceMemberTable(decl, itf, ctx)
      }
    }
  }

  # Write interface member lookup tables for a class.
  PROC $writeIMTTables(Declaration decl, set<string> imtDone, SContext ctx)
    ClassType classType = decl.type.<ClassType>

    # For the class, it's parent, parent of parent, etc. generate the
    # interface member lookup table.  Only needed for C and when the class
    # is not abstract (there can be instances).
    # Not when the class uses AUGMENTS or GROWS, the table of the parent is
    # used.
    IF classType.countClass()
      IF classType.hasCountExtends()
        # Write the the __mt table.
        WriteIMT.generateMemberTable(decl, ctx)
      }

      ClassType itfType = classType
      string cname = ""
      WHILE itfType != NIL
        cname ..= "." .. itfType.name
        # TODO: when there are no children there may be a reference to the
        # interface anyway, but it's rare.  Check if the class was used as an
        # interface and skip generating the table if not.
        IF !imtDone.has(cname)
          Declaration useDecl = decl.isUsingInterface(itfType, ctx)
          # Also do this when the last pass had undefined symbols, it could
          # possibly come from a method mismatch and we need to go in here to
          # produce the error.
          IF (useDecl != NIL && $isDeclUsed(useDecl)) || MainFile.lastPassUndef
            WriteIMT.generateInterfaceMemberTable(decl, itfType, ctx)
          }
          imtDone.add(cname)
        }

        IF itfType.interfaces != NIL
          # Also generate a table for each interface that this parent class
          # implements.  But only when not done yet, there can be
          # duplicates.
          FOR idecl IN itfType.interfaces
            string iname = idecl.getInterfaceName(ctx)
            IF !imtDone.has(iname)
              Declaration useDecl = decl.isUsingInterface(idecl, ctx)
              IF useDecl != NIL && $isDeclUsed(useDecl)
                WriteIMT.generateInterfaceMemberTable(decl, idecl.type, ctx)
              }
              imtDone.add(iname)
            }
          }
        }

        itfType = itfType.parent
      }
    }

    bool imttUsed = classType.imttDecl != NIL && $isDeclUsed(classType.imttDecl)
    bool impUsed = classType.impDecl != NIL && $isDeclUsed(classType.impDecl)
    IF imttUsed || impUsed
      # Produce a table with all InterfaceMemberTables.  This is used when
      # converting one iobject into another in ZconvertZoref().
      # And/or produce the implementerTable, used to check if an entry is for
      # an implementer instead of a child.
      WriteIMT.generateIMTTable(classType, imttUsed, impUsed, ctx)
    }

    WriteIMT.generateNeedItfTables(classType, ctx)
  }

  # Write object declaration table for a class.
  PROC $writeToTable(Declaration decl, SContext ctx)
    WriteIMT.writeToTable(decl, ctx)
  }

  FUNC $getCS(ZimbuFile zimbuFile) ZimbuFile.CodeSpecific
    RETURN zimbuFile.c
  }

  # Return TRUE if there is code at the toplevel (not allowed for imported
  # files).
  FUNC $toplevelLines(ZimbuFile zimbuFile) bool
    RETURN !zimbuFile.c.outputs.mainOut.empty()
  }

  FUNC $catchSignals() bool
    RETURN !Config.noBacktrace || $isDeclUsed(Declaration.try)
  }

  FUNC $gcSignal() bool
    RETURN $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
  }

  # Write the main() function and initialization.
  PROC $mainHead(MethodType method, SContext ctx)

    # The deadly signals are caught and can be turned into an exception.  In
    # that case the signal function does not return, thus we must make sure
    # signals are not blocked.  MingW requires another solution.
    IF $catchSignals() || $gcSignal()
      ctx.out.write(''"
#if defined(__MINGW32__) || defined(_MSC_VER)
# define CATCH_SIG(sig, func) signal(sig, func)
  typedef struct SEH_EXCEPTION_REGISTRATION_S SEH_EXCEPTION_REGISTRATION;
  struct SEH_EXCEPTION_REGISTRATION_S
  {
    SEH_EXCEPTION_REGISTRATION *prev;
    PEXCEPTION_HANDLER handler;
  };
  static EXCEPTION_DISPOSITION exception_handler(PEXCEPTION_RECORD pRecord, SEH_EXCEPTION_REGISTRATION *pReg, PCONTEXT pContext, PEXCEPTION_RECORD pRecord2) {
   Zdeadly(11);
   return ExceptionContinueSearch;
  }
#else
# define CATCH_SIG(sig, func) catch_sig(sig, func)
void catch_sig(int sig, void *func) {
 struct sigaction act;
 act.sa_handler = func;
 sigemptyset(&act.sa_mask);
 act.sa_flags = SA_NODEFER;
 sigaction(sig, &act, NULL);
}
#endif
"'')
    }

    ctx.out.write(''"
int Fmain(void);
int main(int argc, char **argv) {
 int r = 0;
 int round = 0;"'')

    # If there is no backtrace and no try-catch a crash is just a crash.
    IF $catchSignals()
      # For MingW us an exception registration structure.
      ctx.out.write(''"
#if defined(__MINGW32__) || defined(_MSC_VER)
 SEH_EXCEPTION_REGISTRATION seh_er;
 seh_er.handler = (PEXCEPTION_HANDLER)(exception_handler);
 asm volatile ("movl %%fs:0, %0" : "=r" (seh_er.prev));
 asm volatile ("movl %0, %%fs:0" : : "r" (&seh_er));
#else
# ifdef SIGSEGV
 CATCH_SIG(SIGSEGV, Zdeadly);
# endif
# ifdef SIGBUS
 CATCH_SIG(SIGBUS, Zdeadly);
# endif
# ifdef SIGFPE
 CATCH_SIG(SIGFPE, Zdeadly);
# endif
#endif"'')
    }
    IF $gcSignal()
      ctx.out.write(''"
 CATCH_SIG(GC_SIG, ZwantGC);"'')
    }

    # Force MingW to do all I/O in binary mode, don't want CR-LF to be
    # converted to LF, that causes lots of trouble.
    # Same for MSVC.
    ctx.out.write(''"
#if defined(__MINGW32__) || defined(_MSC_VER)
# ifdef __MINGW32__
 _fmode = _O_BINARY;
# else
 _set_fmode(_O_BINARY);
# endif
 _setmode(_fileno(stdin), _O_BINARY);
 _setmode(_fileno(stdout), _O_BINARY);
 _setmode(_fileno(stderr), _O_BINARY);
#endif"'')

    IF $isDeclUsed(%pthread)
      ctx.out.write(''"
 ZenvInit();"'')
    }

    # Reserve memory to be used when out of memory, so that we can throw an
    # exception.  Should be enough to contain a stack backtrace with 30
    # entries.
    ctx.out.write(''"
 emergencyAlloc = malloc("'' .. emergencyAllocSize .. ''");"'')

    # Initialize static members of builtin modules.
    # Init sequence round numbers:
    # 0           builtin modules init
    # 1           init ARG types and vars with @earlyInit or object of a class
    #             marked with @earlyInit.
    # 2-1001      Invoke EarlyInit() functions, may call ARG.disable() and do
    #             its own command line parsing.
    # -           Do standard cmdline parsing, unless disabled.
    # 2001        Init non-early vars, they can use flags.
    # 2002 - 3001 Invoke Init() functions.
    ctx.out.write(''"
 ZglobInit(round++);"'')

    # Write main() early init lines for libraries.  Must be after first
    # ZglobInit().
    FOR p IN mainEarlyinitWriters
      p(THIS, ctx.out)
    }

    # Initialize static members of other modules.
    # Call EarlyInit() functions until done.
    ctx.out.write(''"
 ZglobInit(round++);
 while (!ZglobInit(round++)) {
  if (round == 1002) ZthrowCstringInit("Early initialization not done within 1000 rounds");
 }
"'')

    # Write main() init lines for libraries.
    FOR p IN mainInitWriters
      p(THIS, ctx.out)
    }

    # Initialize static members of non-builtin modules.
    # Call Init() functions until done.
    ctx.out.write(''"
 round = 2001;
 ZglobInit(round++);
 while (!ZglobInit(round++)) {
  if (round == 3002) ZthrowCstringInit("Initialization not done within 1000 rounds");
 }
 r = Fmain();
 beforeExit();"'')

    IF (!ctx.scope?.noBacktrace && !Config.noBacktrace) || $manageMemory()
      IF $isDeclUsed(%pthread)
        ctx.out.write(''"
 if (ZgetEnv()->topFrame != NULL)"'')
      ELSE
        ctx.out.write(''"
 if (topFrame != NULL)"'')
      }
      ctx.out.write(''" fprintf(stderr, "INTERNAL: topFrame not NULL\n");"'')
    }
    ctx.out.write(''"
 return r;
}

"'')

    IF method != NIL
      $methodLeader(method, ctx.out, ctx)
    }

    # Similar to $methodStart().
    ctx.out.write(''"
int Fmain(void) {
"'')
  }

  PROC $mainMiddle(SContext ctx)
    ctx.out.write(" r = 0;\n")
  }

  PROC $mainEnd(SContext ctx)
    ctx.out.write("}\n")
  }

  PROC $writeAlloc(ClassType class, Declaration finishMethod,
                                                     Output out, SContext ctx)
    string mtName
    IF class.hasCountExtends()
      mtName = $classMemberTableName(class)
    }
    $writeAlloc(class.pName, mtName, finishMethod, out, ctx)
  }

  PROC $writeAlloc(string typeName, string mtName, Declaration finishMethod,
                                                     Output out, SContext ctx)
    IF finishMethod != NIL && $isDeclUsed(Declaration.hasFinish)
      out.write("ZaF(sizeof(" .. typeName .. "), To")
      out.write(typeName .. ", (Ts (*)(void*, Te))" .. finishMethod.pName)
      # TODO: why would scope be NIL?
      out.write(finishMethod.type.<MethodType>.scope?.notOnExit ? ", 1" : ", 0")
      out.write(", ")
      out.write(mtName ?: "NULL")
      out.write(")")
    ELSEIF mtName != NIL
      out.write("Zamt(sizeof(" .. typeName .. "), ")
      out.write((mtName ?: "NULL") .. ")")
    ELSE
      out.write("Za(sizeof(" .. typeName .. "))")
    }
  }

  # Write a call to $Init()
  PROC $writeObjectInit(Declaration initMethod, ClassType classType,
                                               Declaration dest, SContext ctx)
    IF dest.type.isNoAlloc()
      #  "%foo = NEW()" clears %foo instead of allocating an object.
      Declaration finishMethod = Generate.getFinishMethod(classType.scope, ctx)
      $writeNoAllocClear(classType.pName, classType,
                                          initMethod, finishMethod, dest, ctx)
    ELSE
      ctx.out.write(initMethod.pName .. "(NULL)")
    }
  }

  # Whether not-allocated variables are fully supported.
  FUNC $supportsNoAlloc() bool
    RETURN TRUE
  }

  # Write a statement to call Finish() on |decl|
  PROC $callFinish(Declaration decl, int reason, Zui.Position pos, SContext ctx)
    $mayFinish(decl, reason, TRUE, pos, ctx)
  }

  # Write a call to clear a not allocated object.
  PROC $writeNoAllocClear(string typeName, ClassType classType,
                        Declaration initMethod, Declaration finishMethod,
                        Declaration dest, SContext ctx)
    string className = typeName
    string mtName
    IF classType.hasCountExtends()
      # Clear the area that matches the actual type of the object.
      className = classType.pName
      mtName = classType.pName .. "__mt"
    }
    $writeNoAllocClear(className, mtName, initMethod, finishMethod,
                                                              dest.pName, ctx)
  }

  # Write a call to clear a not allocated item.
  PROC $writeNoAllocClear(string typeName, string mtName,
                          Declaration initMethod, Declaration finishMethod,
                          string destName, SContext ctx)
    Output out = ctx.out
    out.write("ZnoAllocClear(sizeof(" .. typeName .. "), &" .. destName)
    IF mtName == NIL
      out.write(", NULL")
    ELSE
      out.write(", " .. mtName)
    }
    IF $isDeclUsed(Declaration.hasFinish)
      IF finishMethod != NIL
        out.write(", (Ts (*)(void*, Te))" .. finishMethod.pName)
      ELSE
        out.write(", NULL")
      }
    }
    IF initMethod != NIL
      out.write(", (void *(*)(void*))" .. initMethod.pName)
    ELSE
      out.write(", NULL")
    }
    out.write(")")
    $setDeclUsed(%noAllocClear)
  }

  # Allocate a new string from an array.
  PROC $writeNewString(Zui.MethodCall call, int &undef, SContext ctx)
    Output out = ctx.out
    out.write("ZStringFromArray(")
    list<Zui.Expression> args = call.getArgumentList()
    ContainerType array = Generate.genExpr(args[0], ctx, Type.anArray)
    IF array == NIL || array.itemType == NIL || !array.itemType.isIntType()
      ctx.error("First argument must be an array of int or nat", args[0])
    }
    out.write(", ")
    IF args.Size() >= 2
      Generate.genExpr(args[1], ctx, Type.anInt)
    ELSE
      out.write("0")
    }
    out.write(", ")
    IF args.Size() == 3
      Generate.genExpr(args[2], ctx, Type.anInt)
    ELSE
      out.write("-1")
    }
    out.write(")")
    $setDeclUsed(%stringFromArray)
  }

  PROC $writeArrayAlloc(ContainerType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    WriteArrayC.writeArrayAlloc(type, noAllocName, call, undef, ctx)
  }

  PROC $writeListAlloc(ContainerType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    WriteListC.writeListAlloc(type, noAllocName, call, undef, ctx)
  }

  PROC $writeDictAlloc(ContainerType type, string noAllocName,
                                            Zui.MethodCall call, SContext ctx)
    WriteDictC.writeDictAlloc(type, noAllocName, call, FALSE, ctx)
  }

  # Write the code to declare a callback type.
  PROC $writeCallbackDecl(CallbackType type, Zui.Position pos, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    ctx.outs.typeOut.write("typedef struct " .. type.pName .. "__S "
                                                       .. type.pName .. ";\n")

    # Struct used to store info about the callback.
    # The start is equal to struct Tcb.
    # struct type__S {
    #  Zoh *np;      for GC
    #  void *cfunc;  method that calls "cb", first argument is this structure,
    #                extra arguments follow
    #  int toCount;  number of entries in to[]
    #  Tcb *cb;      method to call
    #  To to[N];     table with type and offset of object and arguments
    #  void *t;      object
    #  type arg1;    USE argument, more can follow
    # }
    ctx.outs.structOut.write("struct " .. type.pName .. "__S {\n"
                      .. $callbackHead()
                      .. " Tcb *cb;\n")
    int argSize = type.arguments.Size()
    int toSize = 1  # one for the object type
    list<Declaration> argClassList = NEW()
    FOR arg IN type.arguments
      # For "USE &$m" we store the object instead of the member.
      Declaration declClass = arg.getClass()
      IF declClass != NIL
        # If the method was copied from a parent, use the current class for
        # the argument, not the parent.
        declClass = type.getClass()
      }
      IF arg.type == NIL
        ctx.error("Unknown type", pos)
      ELSE
        IF arg.type.ttype == Type.Enum.byRef && declClass != NIL
          argClassList.add(declClass)
          ++toSize
        ELSE
          # Other argument, check if it's memory managed.
          argClassList.add(NIL)
          IF arg.type.isManaged()
            ++toSize
          }
        }
      }
    }
    ctx.outs.structOut.write(" To to[" .. toSize .. "];\n")

    # "t" stores the object if it was used when creating the callback:
    # callback<...> cb = NEW(obj.method, ....)  obj is stored in "t"
    ctx.outs.structOut.write(" void *t;\n")

    FOR idx IN 0 UNTIL argSize
      ctx.outs.structOut.write(" ")
      IF argClassList[idx] != NIL
        $vartype(argClassList[idx].type, TRUE, pos, ctx.outs.structOut, ctx)
      ELSE
        $vartype(type.arguments[idx].type, TRUE, pos, ctx.outs.structOut, ctx)
      }
      ctx.outs.structOut.write(" arg" .. (idx + 1))
      ctx.outs.structOut.write(";\n")
    }
    ctx.outs.structOut.write("};\n")

    # Function used to allocate a new callback struct: Za{typename}().
    Output dout = NEW()
    dout.writing = ctx.out.writing
    SContext dctx = ctx.copy(dout)
    dout.write(type.pName .. " *Za" .. type.pName .. "(")
    dout.write(type.pName .. " *p, void *t, Tt *tt, Tcb *cb")
    FOR i IN 1 TO argSize
      dout.write(", ")
      IF argClassList[i - 1] != NIL
        $vartype(argClassList[i - 1].type, TRUE, pos, dout, ctx)
      ELSE
        $vartype(type.arguments[i - 1].type, TRUE, pos, dout, ctx)
      }
      dout.write(" arg" .. i)
    }
    dout.write(")")

    ctx.outs.declOut.append(dout)
    ctx.outs.declOut.write(";\n")

    Output bodyOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    bodyOut.append(dout)
    bodyOut.write(" {\n" .. " " .. type.pName .. " *r = p == NULL ? Za(sizeof(")
    bodyOut.write(type.pName .. ")) : p;\n")
    # Use Zcb0 when t is not NULL, Zcb1 when t is NULL.
    bodyOut.write(" r->cfunc = t ? (void*)Zcb0" .. type.pName
                                   .. " : (void*)Zcb1" .. type.pName .. ";\n")
    bodyOut.write(" r->toCount = " .. toSize .. ";\n")
    bodyOut.write(" r->t = t;\n")
    bodyOut.write(" r->cb = cb;\n")
    int toIdx
    FOR i IN 1 TO argSize
      bodyOut.write(" r->arg" .. i .. " = arg" .. i .. ";\n")
      Type argType
      IF argClassList[i - 1] != NIL
        argType = argClassList[i - 1].type
      ELSE
        argType = type.arguments[i - 1].type
      }
      IF argType != NIL && argType.isManaged()
        bodyOut.write(" r->to[" .. toIdx .. "].off = (void*)(&r->arg"
                                                    .. i .. ") - (void*)r;\n")
        bodyOut.write(" r->to[" .. toIdx .. "].type = "
                                           .. getTname(argType, ctx) .. ";\n")
        ++toIdx
      }
    }

    # store type of the object
    bodyOut.write(" r->to[" .. toIdx .. "].off = (void*)(&r->t) - (void*)r;\n")
    bodyOut.write(" r->to[" .. toIdx .. "].type = tt;\n")
    bodyOut.write(" return r;\n")
    bodyOut.write("}\n")

    $writeCallbackFunc(type, argClassList, TRUE, NIL, pos, ctx)
    $writeCallbackFunc(type, argClassList, FALSE, NIL, pos, ctx)
  }

  # For a callback<> |type| is set, for a simple method ref |decl| is set.
  # For a callback<> |argClassList| has a non-NIL for an argument that is an
  # object member.
  # When |withObject| is TRUE the callback has the object, the "Zcb0" method
  # is produced.  When |withObject| is FALSE then the "Zcb1" method is
  # produced where "t" is passed in.
  PROC $writeCallbackFunc(CallbackType type, list<Declaration> argClassList,
                          bool withObject,
                          Declaration decl, Zui.Position pos, SContext ctx)
    # Function used to invoke the callback:
    # {return-type} Zcb0{typename}({typename} *cb, arg1, arg2) {
    #  [return] {type cast}cb->func(arg1, arg2, cb->arg1, cb->arg2);
    # }
    Output dout = NEW()
    dout.writing = ctx.out.writing
    SContext dctx = ctx.copy(dout)

    MethodType method
    string pName
    string typeName
    IF type == NIL
      method = decl.type.getMethod()
      pName = decl.pName
      typeName = "Tcb"
    ELSE
      method = type.methodType.getMethod()
      pName = type.pName
      typeName = pName
    }


    $writeReturnType(method, pos, dctx)
    dout.write(" Zcb" .. (withObject ? "0" : "1") .. pName)
    dout.write("(" .. typeName .. " *cb")

    int objectArgIdx
    FOR i IN 0 UNTIL argClassList.Size()
      IF argClassList[i] != NIL
        objectArgIdx = i + 1
        BREAK
      }
    }

    # The object is only passed when there is no "USE &$m" argument.
    IF method.getClassName() != NIL && objectArgIdx == 0 && !withObject
      dout.write(", " .. method.getClassName() .. " *t")
    }
    FOR i IN 0 UNTIL method.arguments.Size()
      dout.write(", ")
      $vartype(method.arguments[i].type, TRUE, pos, dout, ctx)
      dout.write("arg" .. i)
    }
    dout.write(")")

    ctx.outs.declOut.append(dout)
    ctx.outs.declOut.write(";\n")

    Output bout = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    SContext bctx = ctx.copy(bout)
    bout.append(dout)
    bout.write(" {\n ")

    IF method.returnType != NIL
      bout.write("return ")
    }
    string comma = ""
    IF type == NIL
      # For a ZCB_ we know the function to be called.
      bout.write(pName .. "(")
    ELSE
      # Need a type cast with first the arguments of the called method, then
      # the USE arguments.
      $refCast(type != NIL ? type.calledMethodType : method, TRUE,
                                                      withObject, pos, bctx)
      bout.write("cb->cb->cfunc)(cb->cb")
      comma = ", "
    }
    IF withObject
      bout.write(comma .. "cb->t")
      comma = ", "
    ELSEIF method.getClassName() != NIL
      bout.write(comma)
      IF objectArgIdx > 0
        bout.write("cb->arg" .. objectArgIdx)
      ELSE
        bout.write("t")
      }
      comma = ", "
    }

    FOR i IN 0 UNTIL method.arguments.Size()
      bout.write(comma .. "arg" .. i)
      comma = ", "
    }
    IF type != NIL
      FOR i IN 1 TO type.arguments.Size()
        bout.write(comma)
        Declaration argDecl = type.arguments[i - 1]
        IF argClassList[i - 1] != NIL
          # "USE &$m" Passed in is a pointer to the object, get a reference to
          # the member.
          bout.write("&cb->arg" .. i .. "->" .. argDecl.pName)
        ELSEIF argDecl.type == NIL
          ctx.error("Unknown type", pos)
        ELSE
          bool at = argDecl.type.isAllocType(ctx)
          IF at
            bout.write("&")
          }
          bout.write("cb->arg" .. i)
          IF at
            bout.write("->Vm")
          }
        }
        comma = ", "
      }
    }
    bout.write(");\n")
    bout.write("}\n")
  }

  # Allocate a new callback for |type|.
  PROC $writeCallbackAlloc(CallbackType type,
                           string noAllocName,
                           Generate.CallbackInfo cbInfo,
                           Zui.MethodCall call,
                           int &undef,
                           SContext ctx)
    list<Zui.Expression> args = call.getArgumentList()
    int argOffset = cbInfo != NIL ? 0 : 1
    IF args.Size() != type.arguments.Size() + argOffset
      ctx.error("Expected " .. (type.arguments.Size() + argOffset)
                        .. " arguments, found " .. args.Size(), call.getPos())
      RETURN
    }
    ctx.out.write("Za" .. type.pName .. "(")
    IF noAllocName == NIL
      ctx.out.write("NULL, ")
    ELSE
      ctx.out.write("&" .. noAllocName .. ", ")
    }

    bool isObject
    bool isIobject
    bool isXobject
    Zui.Expression methodExpr = cbInfo != NIL ? call.getName() : args[0]
    Type leftType
    Zui.Expression left
    IF methodExpr.getType() == Zui.ExprType.eMEMBER
      left = methodExpr.getLeft()
      leftType = genExpr(left, ctx.copyNoOut())
      IF leftType != NIL
        isIobject = leftType.isIobject(ctx)
        isXobject = leftType.isXobject(ctx)
        isObject = leftType.getTtype() == Type.Enum.object
      }
    }

    IF (isObject || isIobject || isXobject)
                                     && type.calledMethodType.classType != NIL
      # Generating a method from object.method while the target is
      # Class.func<>, do not pass the object.
      IF TRUE # TODO: if there are use arguments
        Report.error("Cannot drop object (yet)")
      }
    ELSEIF isObject
      Type objType = genExpr(left, ctx)
      ctx.out.write(", " .. $getDynType(objType, left.getPos(), ctx) .. ", ")
    ELSEIF isIobject || isXobject
      string tmpName = mayGetTempVar(left, "Tr ", ctx)
      IF tmpName != NIL
        ctx.out.write("(\(tmpName) = ")
      }
      genExpr(left, ctx)
      IF tmpName != NIL
        ctx.out.write(")")
      }
      IF isIobject
        ctx.out.write(".ptr")
      }
      ctx.out.write(", (Tt*)(")
      IF tmpName != NIL
        ctx.out.write(tmpName)
      ELSE
        genExpr(left, ctx)
      }
      IF isIobject
        ctx.out.write(").table[0], ")
      ELSE
        ctx.out.write(")->mt[0], ")
      }
    ELSE
      ctx.out.write("NULL, NULL, ")
    }


    # Write the function reference.
    IF cbInfo == NIL
      # We don't want to bind the object here, the destination type is
      # Class.proc<>.
      MethodType mt = type.calledMethodType.copyType()
      mt.classType = leftType?.getClassType(ctx)
      Generate.genExpr(methodExpr, ctx, mt.getMethodRef())
    ELSEIF isIobject || isXobject
      $iobjectFuncUse(cbInfo.methodType, leftType, left, ctx)
      SymUse symUse = NEW(methodExpr.getPos(), ctx)
      Generate.markMethodsUsed(cbInfo.methodType,
                         leftType?.getClassType(ctx), cbInfo.methodType.name,
                                                                symUse, ctx)
    ELSE
      $namelessFuncUse(cbInfo.methodType, ctx)
    }

    FOR i IN argOffset UNTIL args.Size()
      ctx.out.write(", ")
      Generate.genExpr(args[i], ctx, type.arguments[i - 1].type)
    }
    ctx.out.write(")")
  }

  # Allocate a new closure for |type|.
  PROC $writeClosureAlloc(CallbackType type, MethodType method, bool typeCast,
                          Zui.Expression objectExpr,
                                      int &undef, Output curOut, SContext ctx)
    IF typeCast
      ctx.out.write("(Tcb*)")
    }
    # Second argument can be an object, third the type.
    ctx.out.write("Za" .. type.pName .. "(NULL, ")
    IF objectExpr != NIL
      Type destType = method.classType.getValueType(ctx)
      string tmpName
      IF destType.getTtype() == Type.Enum.iobject
        ctx.out.write("(")
        tmpName = mayGetTempVar(objectExpr, $vartypeString(
                               destType, TRUE, objectExpr.getPos(), ctx), ctx)
        IF tmpName != NIL
          ctx.out.write("\(tmpName) = ")
        }
      }
      genExpr(objectExpr, ctx, destType)
      IF destType.isIobject(ctx)
        ctx.out.write(").ptr")
      }
      ctx.out.write(", ")
      IF destType.isIobject(ctx)
        ctx.out.write("(Tt*)((")
        IF tmpName != NIL
          ctx.out.write(tmpName)
        ELSE
          genExpr(objectExpr, ctx, destType)
        }
        ctx.out.write(").table[0])")
      ELSEIF destType.isXobject(ctx)
        ctx.out.write("(Tt*)((")
        IF tmpName != NIL
          ctx.out.write(tmpName)
        ELSE
          genExpr(objectExpr, ctx, destType)
        }
        ctx.out.write(")->mt[0])")
      ELSE
        ctx.out.write("(Tt*)(&")
        ctx.out.write(method.classType.pName)
        ctx.out.write("__T)")
      }
      ctx.out.write(", ")
    ELSE
      ctx.out.write("NULL, NULL, ")
    }

    $namelessFuncUse(type.calledMethodType, ctx)

    FOR l IN [method.useArguments, method.autoArguments]
      FOR arg IN l
        ctx.out.write(", ")
        IF arg.type ISA MethodRefType
          # PROC foo(USE funcName): generate callback decl for funcName
          Generate.generateMethodUse(undef, arg.type.getMethod(),
                                                    arg.type.getMethod(), ctx)
        ELSE
          Declaration argClass = arg.getClass()
          IF arg.type.ttype == Type.Enum.byRef && argClass != NIL
            # Pass the object reference, so that it remains referenced for
            # garbage collection.  Need a type cast for when a method is also
            # present in a child class, the type of THIS differs.
            ctx.out.write("(void *)")
            ctx.out.write(ctx.scope.getThisName())
          ELSE
            IF arg.type.ttype == Type.Enum.byRef
              ctx.out.write("&")
            }
            IF arg.getClass() != NIL && !arg.type.isAllocType(ctx)
              ctx.out.write(ctx.scope.getThisName() .. "->")
            }
            ctx.out.write(arg.pName)
          }
        }
      }
    }
    ctx.out.write(")")
  }

  # Write the code to declare a tuple type.
  PROC $writeTupleDecl(TupleType tupleType, Zui.Position zuiPos, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    Output typeOut = ctx.outs.typeOut
    Output structOut = ctx.outs.structOut
    Output declOut = ctx.outs.declOut

    typeOut.write("typedef struct \(tupleType.pName)__S \(tupleType.pName); /* \(tupleType.typeName(FALSE)) */\n")

    # Struct used to store info about the tuple.
    structOut.write("struct \(tupleType.pName)__S {\n")
    IF $hasNpField()
      structOut.write(linkedDecl)
    }

    int toSize = 1
    string tableName = "To" .. tupleType.getTypeName(ctx)
    Output tmpOut = NEW()
    tmpOut.writing = TRUE

    FOR index IN 0 UNTIL tupleType.types.Size()
      Type type = tupleType.types[index].type
      IF type == NIL
        CONTINUE  # Error given later
      }
      string pName = "m" .. index
      structOut.write(" ")
      $vartype(type, TRUE, zuiPos, structOut, ctx)
      structOut.write(pName .. ";\n")

      IF type.isManaged()
        tmpOut.write(" {offsetof(\(tupleType.pName), \(pName)), (Tt*)&" .. type.getTypeName(ctx) .. "__T},\n")
        ++toSize
      }
    }
    structOut.write("};\n")

    # Declaration of the To struct.
    structOut.write("To " .. tableName .. "[" .. toSize .. "];\n")

    Output bodyOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    bodyOut.write("To " .. tableName .. "[] = {\n")
    bodyOut.write(" {" .. (toSize - 1) .. ", 0},\n")
    bodyOut.append(tmpOut)
    bodyOut.write("};\n")

    # Whether tuple<>.ToString() is used.
    bool useTupleToString = $isDeclUsed(Type.aDyn)
                              || (tupleType.toStringDecl != NIL
                                       && $isDeclUsed(tupleType.toStringDecl))
    IF useTupleToString
      # Write function for tuple.ToString().
      $writeTupleToString(tupleType, zuiPos, ctx)
    }

    string tcName = $writeStaticString(tupleType.typeName(), ctx)
    declOut.write("Tto " .. tupleType.pName .. "__T = {320, (Tc*)&"
                                                            .. tcName .. ", ")
    IF useTupleToString
      declOut.write(tupleType.pName .. "ToString")
    ELSE
      declOut.write("0")
    }
    IF $ttoHasMemberNames()
      # TODO: list of member names
      declOut.write(", 0")
    }
    IF $ttoHasAssign()
      declOut.write(", 0")
    }
    IF $ttoHasMethods()
      # TODO: Size()
      declOut.write(", 0")

      # TODO: Finish()
      declOut.write(", 0")

      # TODO: Equal()
      declOut.write(", 0")

      # TODO: Compare()
      declOut.write(", 0")
    }

    declOut.write(", " .. tableName .. "};\n")

    # Function used to allocate a new tuple struct: Za{typename}(a1, a2).
    Output dout = NEW()
    dout.writing = ctx.out.writing
    SContext dctx = ctx.copy(dout)
    dout.write(tupleType.pName .. " *Za" .. tupleType.pName .. "(")
    dout.write(tupleType.pName .. " *p")
    FOR i IN 0 UNTIL tupleType.types.Size()
      dout.write(", ")
      $vartype(tupleType.types[i].type, TRUE, zuiPos, dout, ctx)
      dout.write("arg" .. i)
    }
    dout.write(")")

    ctx.outs.declOut.append(dout)
    ctx.outs.declOut.write(";\n")

    bodyOut.append(dout)
    bodyOut.write(" {\n")
    bodyOut.write(" " .. tupleType.pName .. " *r = p == NULL ? Za(sizeof(")
    bodyOut.write(tupleType.pName .. ")) : p;\n")
    FOR i IN 0 UNTIL tupleType.types.Size()
      bodyOut.write(" r->m" .. i .. " = arg" .. i .. ";\n")
    }
    bodyOut.write(" return r;\n")
    bodyOut.write("}\n")
  }

  PROC $writeTupleAlloc(TupleType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    list<Zui.Expression> args = call.getArgumentList()
    IF args.Size() == 0
      # NEW() allocates without setting values.
      IF noAllocName == NIL
        ctx.out.write("Za(sizeof(" .. type.pName .. "))")
      ELSE
        $writeNoAllocClear(type.pName, NIL, NIL, NIL, noAllocName, ctx)
      }
    ELSEIF args.Size() != type.types.Size()
      ctx.error("Expected " .. (type.types.Size() + 1)
                        .. " arguments, found " .. args.Size(), call.getPos())
    ELSE
      # NEW(a1, a2) allocates and sets values.
      ctx.out.write("Za" .. type.pName .. "(")
      IF noAllocName == NIL
        ctx.out.write("NULL")
      ELSE
        ctx.out.write("&" .. noAllocName)
      }
      FOR i IN 0 UNTIL args.Size()
        ctx.out.write(", ")
        Generate.genExpr(args[i], ctx, type.types[i].type)
      }
      ctx.out.write(")")
    }
  }

  # Generate a call for tuple.ToString().
  PROC $callTupleToString(Zui.MethodCall call,
                                 Type type, Zui.Expression expr, SContext ctx)
    Output out = ctx.out
    out.write(type.getEffType().pName .. "ToString(")
    Generate.generateVarname(expr, ctx, type)
    out.write(")")
  }

  # Generate a function for tuple.ToString().
  PROC $writeTupleToString(TupleType tupleType, Zui.Position pos, SContext ctx)
    Output dout = NEW()
    dout.writing = TRUE
    dout.write("Tc *" .. tupleType.pName .. "ToString(")
    $vartype(tupleType, TRUE, pos, dout, ctx)
    dout.write("t)")
    ctx.outs.declOut.append(dout)
    ctx.outs.declOut.write(";\n")

    Output bodyOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    bodyOut.append(dout)
    bodyOut.write(''" {
 Tg ga;"'')
    IF !$manageMemory()
      bodyOut.write(''"
 Tc *r;"'')
    }
    bodyOut.write(''"
 if (t == NULL) return (Tc*)&ZNilString;
 ga.data = NULL;
 ga.used = 0;
 ga_append(&ga, "[");"'')
    FOR i IN 0 UNTIL tupleType.types.Size()
      IF i > 0
        bodyOut.write("\n ga_append(&ga, \", \");")
      }
      Type type = tupleType.types[i].type
      IF type == NIL
        CONTINUE
      }
      SContext newCtx = ctx.copyNewOut()
      int undef
      int t = getArgumentType(type, pos, &undef, newCtx)
      bodyOut.write("\n ZitemToString(" .. getTname(type, ctx))
      IF t < 100
        bodyOut.write(", 1, (Tz)t->m" .. i)
      ELSEIF t == 360
        # dyn is a struct, take its reference
        bodyOut.write(", 1, (Tz)(void*)&t->m" .. i)
      ELSE
        bodyOut.write(", 1, (Tz)(void*)t->m" .. i)
      }
      bodyOut.write(", &ga);")
    }

    bodyOut.write(''"
 ga_append(&ga, "]");"'')
    IF $manageMemory()
      bodyOut.write(''"
 return ZnewString(ga.data, ga.used);"'')
    ELSE
      bodyOut.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
      $setDeclUsed(%zfree)
    }
    bodyOut.write("\n}\n")

    $setDeclUsed(%garray)
    $setDeclUsed(Declaration.itemToString)
  }

  PROC $callTypeToString(Zui.Expression expr, SContext ctx)
    ctx.out.write("Ztype2string(")
    genExpr(expr, ctx, Type.aType)
    ctx.out.write(")")
  }

  PROC $callTypeName(Zui.Expression expr, SContext ctx)
    ctx.out.write("ZtypeName(")
    genExpr(expr, ctx, Type.aType)
    ctx.out.write(")")
  }

  PROC $writeNewThis(MethodType method, Declaration initMethod,
                     Declaration finishMethod, Zui.Position pos, SContext ctx)
    string thisName = ctx.scope.getThisName()
    ctx.out.writeIndent(1)
    ctx.out.write("if (" .. thisName .. " == NULL) {")
    IF !ctx.scope.noBacktrace && !Config.noBacktrace && !ctx.scope.primitive
      $writeSetStackPos(pos, TRUE, ctx)
      ctx.out.write("; ")
    }

    IF initMethod == NIL
      $writeClassAlloc(method, finishMethod, ctx)
    ELSE
      ctx.out.write(thisName)
      ctx.out.write(" = ")
      ctx.out.write(initMethod.pName .. "(NULL)")
    }
    ctx.out.write(";}\n")
  }

  PROC $writeClassAlloc(MethodType method, Declaration finishMethod,
                                                                 SContext ctx)
    string thisName = ctx.scope.getThisName()
    ClassType class = method.getClass()

    ctx.out.write(thisName)
    ctx.out.write(" = ")
    $writeAlloc(class, finishMethod, ctx.out, ctx)
  }

  PROC $writeNewArg(bool useThis, ClassType classType, Declaration dest,
                    Declaration initMethod, Declaration finishMethod,
                    bool hasArg, SContext ctx)
    IF useThis
      # calling NEW() inside NEW(): pass the already constructed object
      ctx.out.write(ctx.scope.getThisName())
    ELSEIF classType != NIL
      $writeNoAllocClear(classType.pName, classType,
                                          initMethod, finishMethod, dest, ctx)
    ELSE
      # calling NEW() elsewhere: pass null so that a new object is
      # constructed.
      ctx.out.write("NULL")
    }
    IF hasArg
      ctx.out.write(", ")
    }
  }

  # Return TRUE when stack frames are used.  Also true when @backtrace=no is
  # used but the stack frame is needed for garbage collection.
  FUNC $doStackFrame(SContext ctx) bool
    RETURN ($manageMemory()
              || (!ctx.scope.noBacktrace
                  && !Config.noBacktrace
                  && ctx.scope.wantBacktrace))
          && !ctx.scope.primitive
  }

  # Return TRUE when |method| has local variables that might be allocated or
  # a DEFER statement.
  FUNC $useFrameOffsets(MethodType method, SContext ctx) bool
    RETURN $doStackFrame(ctx) && $hasNpField()
          && (method.scope?.refVars != NIL || method.scope?.hasDefer)
  }

  # Return the code to write at the end of a function to undo ZsD().
  # Excludes the indent, includes the line break;
  FUNC $stackBack() string
    IF $isDeclUsed(%pthread)
      RETURN "e->topFrame = sf.prev;\n"
    }
    RETURN "topFrame = sf.prev;\n"
  }

  # Write the code that goes before writing " return r;" in a normal function.
  PROC $writeBeforeReturn(Zui.Position pos, SContext ctx)
    # If an object located on the stack has a Finish() method, call it.
    $writeScopeEndFinish(pos, ctx)

    IF ctx.scope.methodScope != NIL
      IF ctx.scope.methodScope.hasDefer
        ctx.out.write(" ZdeferCall(&deferList);\n")
      }
      IF ctx.scope.methodScope.hasCtxAdd
        ctx.out.write(" " .. $getEnvCode() .. "->ctxUsed = ctxUsed;\n")
      }
    }

    IF $doStackFrame(ctx)
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write($stackBack())
    }
  }

  # For variables declared in the current scope, which are allocated on the
  # stack, call their Finish() method.
  PROC $writeScopeEndFinish(Zui.Position pos, SContext ctx)
    IF !$isDeclUsed(Declaration.hasFinish)
      RETURN
    }

    bool didOne
    FOR declList IN ctx.scope.declDict?.values()
      FOR decl IN declList
        didOne = $mayFinish(decl, 2, didOne, pos, ctx)
      }
    }
  }

  FUNC $mayFinish(Declaration decl, int reason, bool alreadyDidOne,
                                          Zui.Position pos, SContext ctx) bool
    bool didOne = alreadyDidOne
    Declaration finish
    bool childHasFinish
    bool isIobj
    IF decl.type != NIL && decl.type.isNoAlloc()
      ClassType class = decl.type.getClassType(ctx)
      IF class != NIL
        isIobj = decl.type.getTtype() == Type.Enum.iobject
        finish = Generate.getFinishMethod(class.scope, ctx)
        IF finish == NIL && isIobj && class.hasFinishMethod(ctx)
          # Some child class has Finish().
          childHasFinish = TRUE
        }
      }
    }
    IF finish != NIL || childHasFinish
      IF !didOne
        didOne = TRUE
        $setStackPos(pos, TRUE, ctx)
      }
      IF isIobj
        $setDeclUsed(%finishIobj)
        ctx.out.writeIndent(ctx.scope.depth)
        IF decl.type.isIobject(ctx)
          ctx.out.write("ZFinishIobj(&" .. decl.pName .. ", \(reason));\n")
        ELSE
          ctx.out.write("ZFinishXobj(&" .. decl.pName .. ", \(reason));\n")
        }
      ELSE
        ctx.out.writeIndent(ctx.scope.depth)
        ctx.out.write("if (" .. decl.pName .. ".np" .. " != NULL) {")
        ctx.out.write(finish.pName .. "((void*)&")
        ctx.out.write(decl.pName .. ", \(reason)); "
                                        .. decl.pName .. ".np = NULL;}\n")
      }
    }
    RETURN didOne
  }

  PROC $writeNewReturn(Zui.Position pos, SContext ctx)
    $writeBeforeReturn(pos, ctx)
    ctx.out.write(" return " .. cThisName .. ";\n")
  }

  # Write the name of this symbol, surrounding it with what is required to
  # access it.
  # When |top| is TRUE the symbol is the whole expression.
  # When |read| is TRUE the symbol is read from, not assigned to or called.
  # When |objectMember| is TRUE may prepend "THIS.".
  PROC $writeSymName(Declaration decl, Type type, Type destType,
                                     Resolve.SymNameFlags flags, SContext ctx)
    IF ctx.out.writing
      IF decl == NIL
        THROW "decl is NIL: " .. type.typeToString()
      ELSEIF decl.pName == NIL
        THROW "decl.pName is NIL: " .. type.typeToString()
      ELSEIF type.ttype == Type.Enum.byRef
        ctx.out.write("(*" .. decl.pName .. ")")
      ELSEIF type.isAllocType(ctx)
        ctx.out.write(decl.pName .. "->Vm")
      ELSEIF decl.getClass() != NIL && !type.isMethodType()
        $writeThisName(ctx)
        IF decl.type.isNoAlloc()
          ctx.out.write(".")
        ELSE
          ctx.out.write("->")
        }
        ctx.out.write(decl.pName)
      ELSEIF type.ttype == Type.Enum.proc || type.ttype == Type.Enum.func
        $namelessFuncUse(decl, ctx)
      ELSE
        bool close
        IF ($generatingArg || flags.top) && decl.isUsedInTry
          # Remove the "volatile" attribute.
          ctx.out.write("((")
          $vartype(decl.type, FALSE, decl.zuiPos, ctx)
          ctx.out.write(")")
          close = TRUE
        ELSEIF decl.type.isXobject(ctx)
                                   && decl.type.isNoAlloc() && destType != NIL
          # Type cast from the union type to the allocated type.
          ctx.out.write("(")
          $vartype(destType, TRUE, decl.zuiPos, ctx)
          IF destType.isNoAlloc()
            ctx.out.write("*")
          }
          ctx.out.write(")(")
          close = TRUE
        }
        $writeVarName(decl, ctx)
        IF close
          ctx.out.write(")")
        }
      }
    }
  }

  PROC $writeVarName(Declaration decl, SContext ctx)
    IF decl.type.isNoAlloc() && !decl.type.isIobject(ctx)
      ctx.out.write("(&" .. decl.pName .. ")")
    ELSE
      ctx.out.write(decl.pName)
    }
  }

  PROC $namelessFuncUse(Declaration decl, SContext ctx)
    IF ctx.out.writing
      ctx.out.write("(&" .. directRefName(decl.pName) .. ")")
      useDirectRef(decl)
    }
  }

  PROC $namelessFuncReference(Declaration decl, ClassType class, SContext ctx)
    useDirectRef(decl)
  }

  # Using an object method as a function reference.  Need to allocate a
  # callback to store the object in.
  FUNC $objectCallbackUse(Declaration decl, Zui.Expression expr, SContext ctx
                         ) int
    MethodType methodType = decl.type
    CallbackType cb = methodType.getCallback(ctx)
    int undef
    $writeClosureAlloc(cb, methodType, TRUE, expr, &undef, ctx.out, ctx)
    RETURN 0
  }

  PROC $writeReturnType(MethodType method, Zui.Position pos, SContext ctx)
    IF method.returnType == NIL
      ctx.out.write("void")
    ELSE
      $vartype(method.returnType, FALSE, pos, ctx)
    }
  }

  PROC $refCast(Type type, Zui.Position pos, SContext ctx)
    $refCast(type, FALSE, FALSE, pos, ctx)
  }

  # Generate the type cast for a proc_ref or func_ref.
  PROC $refCast(Type type, bool callback, bool withObject,
                                               Zui.Position pos, SContext ctx)
    Output out = ctx.out
    MethodType method = type.getMethod()
    # ((returnType (*)(arg1Type, arg2Type))Vobj->Vmember)(arg1, arg2)
    out.write("((")
    $writeReturnType(method, pos, ctx)
    out.write(" (*)(")

    string comma = ""
    IF callback
      out.write(comma .. "Tcb *")
      comma = ", "
    }
    bool didObject
    IF (type.ttype == Type.Enum.procRef || type.ttype == Type.Enum.funcRef)
      Type ct = method.classType
      IF ct != NIL
        # THIS for an object method
        out.write(comma)
        IF withObject
          # avoid "Tr"
          out.write("void *")
        ELSE
          $vartype(ct, FALSE, pos, ctx)
        }
        comma = ", "
        didObject = TRUE
      }
    ELSEIF type.getClassName() != NIL
      # THIS for an object method
      out.write(comma .. type.getClassName() .. " *")
      comma = ", "
      didObject = TRUE
    }
    IF withObject && !didObject
      out.write(comma .. "void *")
      comma = ", "
    }

    IF method.arguments != NIL
      FOR arg IN method.arguments
        out.write(comma)
        $vartype(arg.type, FALSE, pos, ctx)
        comma = ", "
      }
    }
    out.write("))")
  }

  PROC $refCast(SContext ctx)
    ctx.out.write("(void*)")
  }

  # Generate an object initializer.
  PROC $objectInit(Zui.Expression initExpr, Declaration dest, SContext ctx)
    Type destType = dest?.type
    ClassType classType = destType?.getClassType(ctx)
    IF classType == NIL
      IF ctx.doError()
        ctx.error("Destination must be an object", initExpr.getPos())
      }
    ELSE
      bool useTempVar
      string separator = ", "
      string tmpvar = genTempUseStart(initExpr,
                      $vartypeString(destType, TRUE, initExpr.getPos(), ctx),
                      &useTempVar, &separator, ctx)
      Generate.generateEmptyNewCall(initExpr.getPos(), destType, ctx)

      SymUse symUse = NEW(initExpr.getPos(), ctx)
      FOR init IN initExpr.getInitItemList()
        string name = init.getName()
        Zui.Expression expr = init.getValue()
        Declaration decl = classType.findObjectMember(name, symUse,
                                                           :searchParent, TRUE)
        IF decl == NIL
          IF ctx.doError()
            ctx.error("Member not found in class: " .. name, expr.getPos())
          }
        ELSE
          ctx.out.write(separator .. tmpvar .. "->" .. decl.pName .. " = ")
          Generate.genExprDoConv(expr, ctx, decl.type)
          initExpr.<ZuiExpressionExt>.undefined +=
                                          expr.<ZuiExpressionExt>.undefined
        }
      }
      IF useTempVar
        ctx.out.write(", " .. tmpvar .. ")")
      }
    }
  }


  # Write the stack frame offset table.
  PROC $methodLeader(MethodType method, Output out, SContext ctx)
    IF $useFrameOffsets(method, ctx)
      dict<string, Declaration> refVars = method.scope.refVars
      out.write("Zfo " .. method.pName)
      out.write("fo[" .. ((refVars == NIL ? 0 : refVars.Size())
                                      + (method.scope?.hasDefer ? 1 : 0) + 1))
      out.write("] = {")

      int i
      FOR pName IN refVars?.keys()
        out.write("{0,(Tt*)&")
        Type t = refVars[pName].type
        IF t.getTtype() != Type.Enum.class || !t.<ClassType>.hasCountExtends()
          out.write(t.getTypeName(ctx))
        ELSE
          # Here we use xobj__T instead of {class.pName}__T.
          out.write("xobj")
        }
        out.write("__T},")
      }
      IF method.scope?.hasDefer
        out.write("{0,(Tt*)&defer__T},")
      }
      out.write("{0,0}};\n")
    }
  }

  FUNC $methodReturnType(Zui.Declaration decl, bool isNew, bool isInit,
                                                          SContext ctx) Type
    Type retType
    Zui.TypeEnum type = decl.getType().getType()
    IF isNew || isInit
      retType = ctx.scope.classType
      ctx.out.write(retType.getClassName() .. " *")
    ELSEIF type == Zui.TypeEnum.eFUNC
      Zui.MethodType method = decl.getType().getMethodDecl()
      retType = getFuncReturnType(method, ctx)
      IF retType != NIL
        $vartype(retType, TRUE, method.getReturnType(0).getName().getPos(), ctx)
      }
    ELSE
      ctx.out.write("void ")
    }
    RETURN retType
  }

  FUNC $hasThisArgument(Declaration decl, SContext ctx) bool
    RETURN ctx.scope.isClassScope() && decl.getClassName() != NIL
  }

  PROC $methodStart(Declaration decl, bool isNew, bool hasArguments,
                                                                 SContext ctx)
    ctx.out.write(decl.pName .. "(")
    IF $hasThisArgument(decl, ctx)
      ctx.out.write(decl.getClass().pName)
      ctx.out.write(" *")
      ctx.out.write(ctx.scope.getThisName())
      IF hasArguments
        ctx.out.write(", ")
      }
    }

    # If this is an Init() or EarlyInit() method we need a variable to hold
    # the result.
    IF decl.name == "Init" || decl.name == "EarlyInit"
                                                  && !ctx.scope.isClassScope()
      string pName = decl.pName
      string readyName
      IF decl.name[0] == 'E'
        pName ..= "__e"
        readyName = "EarlyReady"
      ELSE
        pName ..= "__r"
        readyName = "Ready"
      }
      IF decl.scopeName != NIL
        readyName = decl.scopeName .. "." .. readyName
      ELSE
        readyName = ctx.scope.name .. "." .. readyName
      }
      ctx.outs.declOut.write("int " .. pName .. " = 0; /* "
                                                      .. readyName .. " */\n")
    }
  }

  PROC $methodBodyStart(MethodType method, bool isNew, bool isInit,
                                               Zui.Position pos, SContext ctx)
    bool useStackFrameTable = $useFrameOffsets(method, ctx)
    IF $doStackFrame(ctx)
      ctx.out.write($stackDeeper(" ",
         $hasNpField() && useStackFrameTable ? method.pName .. "fo" : "NULL"))
    }

    Type retType = method.returnType
    IF retType != NIL && !isNew && !isInit
      # Need a var for the return value.  When it's reference counted need to
      # init to zero.
      IF retType.getTtype() == Type.Enum.multiple
        # make sure it has been given a name
        retType.getTypeName(ctx)
      }
      ctx.out.writeIndent(1)
      $vartype(retType, TRUE, pos, ctx)
      IF retType.isIobject(ctx) || retType.getTtype() == Type.Enum.dyn
        ctx.out.write("r = {NULL};\n")
      ELSEIF retType.getTtype() == Type.Enum.multiple
        ctx.out.write("r;\n")
      ELSE
        ctx.out.write("r = 0;\n")
      }
    }

    IF method.scope?.hasDefer
      # The init is either for the "np" field or for "itemType".
      ctx.out.write(" Tl deferList = {NULL};\n")
    }

    # When using CTX.add() need to get the current context length.
    IF method.scope?.hasCtxAdd
      ctx.out.write(" int ctxUsed = " .. $getEnvCode() .. "->ctxUsed;\n")
    }

    # Declare pointer variables.
    IF method.scope?.refVars != NIL
      dict<string, Declaration> refVars = method.scope.refVars
      FOR decl IN refVars
        IF !decl.isArg
          $writeDeclaration(decl, method.scope, FALSE, TRUE, FALSE,
                                                                 ctx.out, ctx)
        }
      }
    }

    IF useStackFrameTable
      # Declare the flag indicating whether the table has been initialized.
      ctx.out.write(" static int sfF = 0;\n")
    }

    # Declare remaining temp variables.
    IF method.scope?.tempVars != NIL
      FOR decl IN method.scope.tempVars
        IF !decl.inMethodScope
          $writeDeclaration(decl, method.scope, FALSE, TRUE, FALSE,
                                                                 ctx.out, ctx)
        }
      }
    }

    IF isInit
      ctx.out.writeIndent(1)
      ctx.out.write("if (")
      ctx.out.write(ctx.scope.getThisName())
      ctx.out.write(" == NULL) {")
      $writeClassAlloc(method, NIL, ctx)
      ctx.out.write(";}\n")
    }
    IF ctx.scope.needRetFlag
      IF ctx.scope.retFlagInTry
        ctx.out.write(" volatile")
      }
      ctx.out.write(" int rt = 0;\n")
    }

    IF $doStackFrame(ctx)
      IF $hasNpField()
        IF useStackFrameTable
          ctx.out.write(" if (!sfF) {\n")
          ctx.out.write("  sfF = 1;\n")
          int i
          FOR pName IN method.scope.refVars?.keys()
            ctx.out.write("  ")
            ctx.out.write(method.pName)
            ctx.out.write("fo[" .. i .. "].off = ")
            string close = ";\n"
            IF method.scope.refVars[pName].type.isNoAlloc()
#                             || $isIobject(method.scope.refVars[pName].type)
              # Variables on the stack have one added to the offset, so that
              # the GC knows this is not a pointer but the object itself.
              # This is used in ZgcMarkItems().
              ctx.out.write("1 + (int)(")
              close = ");\n"
            }
            ctx.out.write("(void*)&sf - (void*)&")
            ctx.out.write(pName)
            ctx.out.write(close)
            ++i
          }
          IF method.scope?.hasDefer
            ctx.out.write("  ")
            ctx.out.write(method.pName)
            ctx.out.write("fo[" .. i
                     .. "].off = 1 + (int)((void*)&sf - (void*)&deferList);\n")
          }
          ctx.out.write(" }\n")
        }
      }

      ctx.out.write($initStackFrame(" "))
    }

    string thisName

    IF ctx.scope.isClassScope() && ctx.scope.getThisName() != NIL
                                                          && !isNew && !isInit
      thisName = ctx.scope.getThisName()
    ELSEIF ctx.scope.insideBuiltin()
            && method.arguments.Size() > 0
            && method.arguments[0].name == "this"
               # not when "this" is a valuetype
            && ["INT", "INT8", "INT16", "INT32", "NAT", "BOOL", "STATUS", "DYN"]
                  .find(ctx.scope.outer.name) < 0
      thisName = "Athis"
    }
    IF thisName != NIL
      # Throw an exception when THIS is NIL
      # Except for Size() in a library module.
      # Not when the first statement is IFNIL.
      IF ctx.scope.statements.Size() == 0
              || ctx.scope.statements[0].getType() != Zui.StatementType.eIFNIL
        ctx.out.write(" if (")
        ctx.out.write(thisName)
        ctx.out.write(" == NULL) {\n ")
        $beforeStatement(pos, TRUE, ctx)
        ctx.out.write("  ZthrowThisNil();\n")
        ctx.out.write(" }\n")
      }
    }
  }

  PROC $writeMethodCall(Declaration funcDecl, bool moreArgs, SContext ctx)
    # If THIS is an xobject and the class has children, a child may actually
    # use another method, need to use the member table.
    bool objectMethod = funcDecl.getClass() != NIL
    IF objectMethod
      IF ctx.scope.classType.hasUsedCountChildren(ctx)
        ctx.out.write("(")
        $objectMethodCall(funcDecl, funcDecl.type.<MethodType>,
                    ctx.scope.getThisName(), ctx.scope.classType, FALSE,  ctx)
      ELSE
        ctx.out.write(funcDecl.pName)
        ctx.out.write("(")
        # If the method comes from the parent, and we didn't create a copy,
        # then the type of "THIS" differs, requires a type cast.
        ClassType ct = funcDecl.type.<MethodType>.classType
        IF ct != NIL &&  ct ISNOT ctx.scope.classType
          ctx.out.write("(\(ct.pName) *)")
        }
        ctx.out.write(ctx.scope.getThisName())
      }
      IF moreArgs
        ctx.out.write(", ")
      }
    ELSE
      ctx.out.write(funcDecl.pName)
      ctx.out.write("(")
    }
  }

  # object.Type()
  PROC $callObjectType(Zui.MethodCall call, ClassType class, Type object,
                                            Zui.Expression expr, SContext ctx)
    IF object.isXobject(ctx)
      ctx.out.write("(Tt*)(")
      Generate.generateVarname(expr, ctx, object)
      ctx.out.write("->mt[0])")
    ELSEIF object.isIobject(ctx)
      ctx.out.write("(Tt*)(")
      Generate.generateVarname(expr, ctx, object)
      ctx.out.write(".table[0])")
    ELSE
      ctx.out.write("(Tt*)(&")
      ctx.out.write(class.pName)
      ctx.out.write("__T)")
    }
  }

  # $Type()
  PROC $callObjectType(Zui.MethodCall call, ClassType class, SContext ctx)
    IF !class.hasCountExtends()
      ctx.out.write("(Tt*)(&")
      ctx.out.write(class.pName)
      ctx.out.write("__T)")
    ELSEIF class.isIobject(ctx)
      ctx.out.write("(Tt*)(")
      ctx.out.write(ctx.scope.getThisName())
      ctx.out.write(".table[0])")
    ELSE
      ctx.out.write("(Tt*)(")
      ctx.out.write(ctx.scope.getThisName())
      ctx.out.write("->mt[0])")
    }
  }

  # object.ToString()
  PROC $callObjectToString(Zui.MethodCall call, ClassType class, Type object,
                                            Zui.Expression expr, SContext ctx)
    IF object.getEffType().ttype == Type.Enum.object
      ctx.out.write("ZobjectToStringval(&")
      ctx.out.write(class.pName)
      ctx.out.write("__T, ")
    ELSEIF object.isXobject(ctx)
      # For an xobject the type will be figured out at runtime.
      ctx.out.write("ZxobjectToStringval(")
    ELSE
      # For an iobject the type will be figured out at runtime.
      ctx.out.write("ZiobjectToStringval(")
    }
    Generate.generateVarname(expr, ctx, object)
    ctx.out.write(")")
  }

  # Add a DEFER'ed function to the defer list
  PROC $addDefer(Zui.MethodCall call, Generate.CallbackInfo cbInfo,
                                                                 SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("ZdeferAdd(&deferList, (Tcb*)")
    int undef
    $writeCallbackAlloc(cbInfo.callback, NIL, cbInfo, call, &undef, ctx)
    ctx.out.write(");\n")
  }

  # Call to a function reference.
  # Either |decl| is set, the reference is stored in a variable, or |expr| is
  # set, the reference is the result of an expression, e.g. aList[idx](arg).
  FUNC $functionRefCall(Zui.MethodCall call,
                        Declaration decl, Zui.Expression expr,
                        string funcName, Type destType, SContext ctx
                       ) Type
    Type refType
    MethodType type
    string close = ")"

    string name
    IF decl != NIL
      refType = decl.type
      IF refType == NIL
        ctx.error("Unknown reference type", call.getPos())
        RETURN Type.anUnknown
      }
    ELSE
      name = getUid(ctx.scope.scopeName)
      ctx.outs.varOut.write(" Tcb *" .. name .. " = NULL;\n")
      # Put the whole thing in () to avoid the comma being used as part of an
      # argument list.
      close = "))" 
      ctx.out.write("(")
      ctx.out.write(name)
      ctx.out.write(" = ")
      refType = Generate.genExpr(expr, ctx)
      IF refType == NIL || (!refType?.isMethodOrRefType() && ctx.doError())
        ctx.error("Method reference expected, got \(Type.typeName(refType))",
                                                                         expr)
        RETURN Type.anUnknown
      }
      ctx.out.write(", ")
    }
    type = refType.getMethod()

    $refCast(refType, TRUE, FALSE, call.getPos(), ctx)
    # When funcName is NIL call the method directly:  { => "foo" }()
    Type useType = funcName == NIL ? type : refType
    IF decl != NIL
      $writeSymName(decl, useType, NIL, :read + :objectMember, ctx)
    ELSE
      ctx.out.write(name)
    }
    ctx.out.write("->cfunc)((Tcb*)")
    IF decl != NIL
      $writeSymName(decl, useType, NIL, :read + :objectMember, ctx)
    ELSE
      ctx.out.write(name)
    }
    IF call.sizeArgument() > 0
      ctx.out.write(", ")
    }
    Generate.generateArgumentsCheck(call, funcName, ctx, type, destType)
    ctx.out.write(close)
    RETURN type.returnType
  }

  # Call to a method reference.
  FUNC $methodRefCall(Zui.MethodCall call,
                  Type mtype,
                  Type object,
                  Zui.Expression objExpr,
                  string pName,
                  Type destType,
                  SContext ctx) Type
    # Need to generate a type cast, since the variable is declared as
    # "void *".
    $refCast(mtype, TRUE, FALSE, objExpr.getPos(), ctx)
    Output varnameOut = NEW()
    varnameOut.writing = ctx.out.writing
    SContext varnameCtx = ctx.copy(varnameOut)
    Declaration decl = Generate.generateVarname(objExpr, varnameCtx, object)
    Type type = decl == NIL ? NIL : decl.type
    # TODO: if the name has side effects need to use a temp var.
    $member(varnameOut, objExpr.getPos(), type, NIL, FALSE, pName, ctx)
    ctx.out.write("->cfunc")
    ctx.out.write(")(")
    $member(varnameOut, objExpr.getPos(), type, NIL, FALSE, pName, ctx)
    IF call.sizeArgument() > 0
      ctx.out.write(", ")
    }

    MethodType mt = mtype.getMethod()
    string methodName = call.getName().getRight().getName()
    Generate.generateArgumentsCheck(call, methodName, ctx, mt, destType)
    ctx.out.write(")")

    IF mt != NIL && mt.returnType != NIL
      RETURN mt.returnType
    }
    RETURN NIL
  }

  FUNC $objectCall(Zui.MethodCall call,
                   bool i_object_arg,
                   list<Declaration.C> arglist,
                   Declaration mdecl,
                   Type objectType,
                   Zui.Expression objExpr,
                   string pName,
                   Type destType,
                   SContext ctx) Type
    MethodType methodType
    bool isCallback
    IF mdecl.type ISA CallbackType
      # The method is actually a callback:
      #     {object}->callback({object}->callback, {object}, args)
      # A bit like functionRefCall()
      methodType = mdecl.type.<CallbackType>.methodType
      isCallback = TRUE
    ELSE
      # Normal method: method({object}, args)
      methodType = mdecl.type
    }
    Zui.Expression nameExpr = call.getName()   # object.method()
    string methodName = nameExpr.getRight().getName()  # method
    Type retType = methodType.returnType
    string close = ")"

    # Default is to use the argument type list of the method.
    # But when generating a virtual function we use the types of the arguments
    # passed in.
    list<Declaration.C> useArglist = methodType.getArgList()

    IF !(ctx.scope.isClassScope() && ctx.scope.classType.isAbstract())
      # For C we need to call the right function and pass "THIS".
      # But we don't write anything for an abtract class.
      ClassType class = objectType.getClassType(ctx)

      bool dotnil = nameExpr.hasDotnil() && nameExpr.getDotnil()
      string objVarName
      string objectExpr
      Type objectExprType = objectType
      bool objectIsInterface = objectType.isIobject(ctx)

      IF !$exprIsaName(objExpr, ctx) && ctx.out.writing
          && (dotnil || isCallback
                  || (objectType.ttype == Type.Enum.iobject && !i_object_arg))
        # Need to store "{object}" in a variable, so that it is evaluated only
        # once.
        # Declare a variable to hold the pointer to the object.
        objVarName = getUid(ctx.scope.scopeName)
        ctx.outs.varOut.writeIndent(ctx.scope.depth)
        IF objectIsInterface
          ctx.outs.varOut.write("Tr " .. objVarName .. " = {NULL,NULL,-1};\n")
        ELSE
          ctx.outs.varOut.write(class.pName)
          ctx.outs.varOut.write(" *" .. objVarName .. " = NULL;\n")
        }
        close = "))"

        ctx.out.write("(")
        ctx.out.write(objVarName)
        ctx.out.write(" = ")
        Generate.genExprParent(objExpr, ctx, objectExprType)
        ctx.out.write(", ")
        objectExpr = objVarName
      ELSE
        # Evaluate the expression once and store the resulting string in
        # objectExpr.
        Output varnameOut = NEW()
        varnameOut.writing = ctx.out.writing
        $generatingArg = TRUE
        Generate.genExprParent(objExpr, ctx.copy(varnameOut), objectExprType)
        $generatingArg = FALSE
        objectExpr = varnameOut.ToString()
      }
      IF dotnil
        # with "{object}" just being an ID:
        #    (id == NULL ? 0 : call(id, ...))
        # otherwise:
        #    (objVarName = {object}, objVarName == NULL
        #                                         ? 0 : call(objVarName, ...))
        IF objVarName == NIL
          ctx.out.write("(")
          ctx.out.write(objectExpr)
          close = "))"
        ELSE
          ctx.out.write(objVarName)
        }
        IF objectIsInterface
          ctx.out.write(".ptr")
        }
        ctx.out.write(" == NULL ? ")
        $writeNilValue(retType, ctx.out, ctx)
        ctx.out.write(" : ")
      }

      IF !i_object_arg && (objectType.ttype == Type.Enum.object
          || !class.hasExtends()
          || !class.hasUsedCountChildren(ctx))
        # object.method(arg) -> method_name(object, arg)
        IF isCallback
          # object.method(arg) -> object.callback(object.callback, object, arg)
          $refCast(methodType, TRUE, FALSE, objExpr.getPos(), ctx)
          ctx.out.write(objectExpr)
          ctx.out.write("->")
          ctx.out.write(mdecl.pName)
          ctx.out.write("->cfunc)")
        ELSE
          ctx.out.write(pName)
        }
        ctx.out.write("(")
        IF isCallback
          ctx.out.write("(Tcb*)")
          ctx.out.write(objectExpr)
          ctx.out.write("->")
          ctx.out.write(mdecl.pName)
          ctx.out.write(", ")
        ELSEIF !objectIsInterface
          ctx.out.write("(" .. methodType.classType.pName .. " *)")
        }
        ctx.out.write(objectExpr)
      ELSEIF objectType.ttype == Type.Enum.iobject && !i_object_arg
        # object.method(arg)
        #      -> (p3 = object, ((ret (*)(args))(p3->table[method_idx]))
        #                                                    (p3->ptr, arg))
        # Assignment to p3 is needed to avoid evaluating the expression twice.
        # Except when the expression is just an ID:
        #      -> ((ret (*)(args))(Vi->table[method_idx]))(Vi->ptr, arg)
        #
        # TODO: doesn't work for PARENT.method()
        ctx.out.write("(")
        IF methodType.hasIfnil()
          # If the method has IFNIL and expr is NULL, then we use the actual
          # method name, since we can't use expr->table[2].  Do the function
          # typecast as for when using ->table, the argument types are
          # different.
          ctx.out.write(objectExpr)
          IF objectIsInterface
            ctx.out.write(".ptr")
          }
          ctx.out.write(" == NULL ? ")
          ctx.out.write("(")
          Generate.generateMethodReturnType(methodType, ctx)
          ctx.out.write(" (*)(")
          Generate.generateMethodArgTypes(methodType, ctx)
          ctx.out.write("))(")
          ctx.out.write(methodType.pName)
          ctx.out.write(")")
          ctx.out.write(" : ")
        }
        $objectMethodCall(mdecl, methodType, objectExpr, class,
                                                      objectIsInterface,  ctx)
      ELSE
        # One of the arguments is of i_object type.
        # object.method(arg) -> method_func(object, arg)
        # Define a function that does the work:
        # RetType method_func(objectType *object, argType arg) {
        #   switch(object->type)
        #     case 1:
        #       switch(arg->type)
        #         case 1: return func11(object, arg)
        #         case 2: return func12(object, arg)
        #     case 2:
        #       switch(arg->type)
        #         case 1: return func21(object, arg)
        #         etc.
        # }
        # TODO: doesn't work for PARENT.method()
        #
        # Make a function name that includes all the argument types to
        # make it unique.
        VirtFuncArgs vargs = NEW()
        vargs.funcKey = virtualFuncName(objectType, arglist,
                                                  methodName, methodType, ctx)
        vargs.varType = objectType
        vargs.methodName = nameExpr.getRight().getName()
        vargs.pos = nameExpr.getPos()
        vargs.callArglist = arglist
        Declaration.C fd = $generateVirtualFunc(vargs, ctx)
        IF fd != NIL
          retType = fd.type
          vargs.funcKey = fd.name  # use the short name
        ELSE
          retType = NIL
        }
        ctx.out.write(vargs.funcKey .. "(")
        ctx.out.write(objectExpr)

        # Must generate the arguments for the virtual function, same types as
        # the arguments that are passed in (thus no iobject -> object
        # conversion).
        useArglist = arglist
      }
      IF call.hasArgument() || methodType.optionalArgCount > 0
        ctx.out.write(", ")
      }

      # Generate the arguments.
      Generate.generateArgumentsCheck(call, methodName, ctx, useArglist,
                                                         methodType, destType)
      ctx.out.write(close)
    }
    RETURN retType
  }

  # Write the code to call a method using the member table:
  # "(type)(obj->mt[idx])(obj"
  PROC $objectMethodCall(Declaration mdecl, MethodType methodType,
            string objectExpr, ClassType class, bool objectIsInterface,
            SContext ctx)
    $objectMethodName(mdecl, methodType, objectExpr, class,
                                                       objectIsInterface, ctx)
    ctx.out.write("(")
    ctx.out.write(objectExpr)
    IF objectIsInterface
      ctx.out.write(".ptr")
    }
  }

  # Write the code for a method using the member table:
  # "(type)(obj->mt[idx]))"
  # Note the extra ")" at the end.
  PROC $objectMethodName(Declaration mdecl, MethodType methodType,
            string objectExpr, ClassType class, bool objectIsInterface,
            SContext ctx)
    ctx.out.write("(")
    Generate.generateMethodReturnType(methodType, ctx)
    ctx.out.write(" (*)(")
    Generate.generateMethodArgTypes(methodType, ctx)
    ctx.out.write("))(")
    ctx.out.write(objectExpr)
    IF objectIsInterface
      ctx.out.write(".table[")
    ELSE
      ctx.out.write("->mt[")
    }
    ctx.out.write(WriteIMT.classMemberTableIndex(class,
                      mdecl, objectIsInterface, ctx.doError(), ctx) .. "")
    ctx.out.write("]))")
  }

  # Return TRUE when |expr| evaluates to a variable name.
  # E.g. "x" or "IO.stderr".
  FUNC $exprIsaName(Zui.Expression expr, SContext ctx) bool
    IF expr.getType() == Zui.ExprType.eID
      RETURN TRUE
    }
    IF expr.getType() != Zui.ExprType.eMEMBER
      RETURN FALSE
    }
    Type type = Generate.genExpr(expr.getLeft(), ctx.copyNoOut())
    IF type == NIL || !(type.ttype == Type.Enum.module
                     || type.ttype == Type.Enum.builtinModule
                     || type.ttype == Type.Enum.class)
      RETURN FALSE
    }
    SymUse symUse = NEW(expr.getPos(), ctx)
    Declaration decl = type.findMember(expr.getRight().getName(), symUse)
    RETURN decl != NIL && (type.ttype != Type.Enum.class || !decl.inShared())
  }

  PROC $usingIobjectMethod(Declaration mdecl,
                   list<Declaration.C> arglist,
                   Type objectType,
                   int &udef,
                   string methodName,
                   Zui.Position pos,
                   string baseFuncName,
                   SContext ctx)
  }

  # Generate a function that takes an object or i_object and a list of
  # arguments and figures out what method is to be invoked.
  # Returns a Declaration with the return type (NIL for a PROC) and the name
  # of the generated function.
  # Keep in sync with Resolve.generateVirtualFunc()!!!
  # Keep in sync with WriteJS.generateVirtualFunc()!!!
  FUNC $generateVirtualFunc(VirtFuncArgs args, SContext ctx) Declaration
    IF $virtualFuncMap.has(args.funcKey)
      RETURN $virtualFuncMap.get(args.funcKey)
    }

    # Make a list with list of possible symbols for THIS and each argument.
    # altList[0] for A0 THIS
    # altList[1] for A1 arg 1
    # altList[1] for A2 arg 2
    # etc.
    list<list<Declaration>> altList = createAltList(args, ctx)
    IF altList == NIL
      RETURN NIL
    }

    # For every permutation find a matching function.
    # E.g. A0 is an i_object with 2 possible classes, A2 is an i_object with
    # three possible classes
    #        switch (A0->type) {
    #          case 0:
    #                  switch (A2->type) {
    #                    case 0:
    #                             return func_obj0_obj0(A0->ptr, A1, A2->ptr);
    #                    case 1:
    #                             return func_obj0_itf(A0->ptr, A1, A2);
    #                    case 2:
    #                             return func_obj0_itf(A0->ptr, A1, A2);
    #                  }
    #          case 1:
    #                  switch (A2->type) {
    #                    case 0:
    #                             return func_obj1_obj0(A0->ptr, A1, A2->ptr);
    #                    case 1:
    #                             return func_obj1_obj1(A0->ptr, A1, A2->ptr);
    #                    case 2:
    #                             return func_obj1_obj2(A0->ptr, A1, A2->ptr);
    #                  }
    #        }
    #
    # Every possible class must have a matching method, either with that class
    # or with an interface.

    Output tmpOut = NEW()
    tmpOut.writing = ctx.out.writing
    string lastCall
    set<int> argNotNull = NEW()  # argument indices that can't be NIL
    int maxTmpIdx

    # depth indicates what to do when a matching func is found:
    # 0: write "switch" for A0
    # 1: write "case" for A0
    # 2: write "switch" for A1
    # 3: write "case" for A1
    # etc.
    int depth

    WHILE TRUE
      list<Declaration.C> argtry = NEW()
      Declaration mdecl = virtFuncFindMethod(args, altList, argtry, ctx)
      MethodType mtype = mdecl?.type
      IF mtype != NIL
        WHILE depth < 2 * altList.Size()
          int idx = depth / 2
          IF altList[idx].Size() > 1
            ClassType argClass
            IF idx == 0
              argClass = args.varType.getClassType(ctx)
            ELSE
              argClass = args.callArglist[idx - 1].type.getClassType(ctx)
            }
            IF (depth & 1) == 0
              argNotNull.set(idx)
              IF argClass.isIobject(ctx)
                tmpOut.write(" { switch (A" .. idx)
                tmpOut.write(".type) {\n")
              ELSE
                tmpOut.write(" { switch ((Tip)A" .. idx)
                tmpOut.write("->mt[1]) {\n")
              }
            ELSE
              tmpOut.writing = ctx.out.writing
              IF argClass.isIobject(ctx)
                tmpOut.write("  case " .. args.indexes[idx] .. ":\n")
              ELSE
                ClassType ct = altList[idx][args.indexes[idx]]
                                                       .type.getClassType(ctx)
                IF $isDeclUsed(ct)
                  tmpOut.write("  case " .. ct.rootIndex .. ":\n")
                ELSE
                  tmpOut.writing = FALSE
                }
              }
            }
          }
          depth++
        }

        # Generate the function call only if it was marked as used.
        IF $isDeclUsed(mdecl)
          IO.StringWriter sw = NEW()
          sw.write("   ")
          IF mtype.ttype == Type.Enum.func
            sw.write("return ")
          }
          IF args.varType.isXobject(ctx)
            # xobject -> xobject (possibly of other type)
            sw.write(mdecl.pName .. "((void*)A0")
          ELSE
            sw.write(mdecl.pName .. "(A0")
            IF args.varType.isIobject(ctx)
              # iobject -> xobject
              sw.write(".ptr")
            }
          }
          IF args.varType.ttype == Type.Enum.iobject
            argNotNull.set(0)
          }
          int tmpIdx
          list<Declaration.C> methodArgList = mtype.getArgList()
          FOR ai IN 0 UNTIL argtry.Size()
            IF args.callArglist[ai].type.ttype == Type.Enum.iobject
              ClassType srcClass = args.callArglist[ai].type.getClassType(ctx)
              ClassType destClass = methodArgList[ai].type.getClassType(ctx)
              IF argtry[ai].type.ttype != Type.Enum.iobject
                          && methodArgList[ai].type.ttype != Type.Enum.iobject
                # iobject -> object
                int idx = srcClass.childIndex(destClass, FALSE)
                IF idx < 0
                  ctx.error("Class type mismatch " .. srcClass.typeName()
                                          .. " to " .. destClass.typeName(),
                                                                     args.pos)
                }
                IF args.callArglist[ai].type.isXobject(ctx)
                  sw.write(", (")
                  sw.write(destClass.pName)
                  sw.write(" *)A" .. (ai + 1))
                ELSE
                  sw.write(",(void*)Zio(" .. idx .. ", ")
                  sw.write($getPosNumber(args.pos, ctx))
                  sw.write(", &A" .. (ai + 1))
                  sw.write(")")
                }
              ELSEIF srcClass IS destClass
                # iobject -> iobject of same class
                sw.write(",A" .. (ai + 1))
              ELSEIF srcClass.isXobject(ctx) && destClass.isXobject(ctx)
                # xobject -> xobject of other class
                sw.write(",(void*)A" .. (ai + 1))
              ELSE
                argNotNull.set(ai + 1)
                bool addTable = TRUE
                IF srcClass.isIobject(ctx)
                  IF destClass.isXobject(ctx)
                    # iobject -> xobject
                    sw.write(",Ziobj2xobj(A" .. (ai + 1))
                    addTable = FALSE
                  ELSE
                    # iobject -> iobject of other class
                    sw.write(",ZconvertZioref(A" .. (ai + 1))
                  }
                ELSE
                  # xobject -> iobject
                  sw.write(",ZconvertZiopref(A" .. (ai + 1))
                }
                string close = $convertZorefArgs(srcClass, destClass,
                                                      addTable, args.pos, ctx)
                sw.write(close)
              }
            ELSEIF args.callArglist[ai].type.ttype == Type.Enum.object
                                      && methodArgList[ai].type.isIobject(ctx)
              # object -> iobject
              ClassType srcClass = args.callArglist[ai].type.getClassType(ctx)
              ClassType destClass = methodArgList[ai].type.getClassType(ctx)
              Output convOut = NEW()
              convOut.writing = TRUE
              string tmpName
              tmpName = "t" .. tmpIdx++
              string close = $object2iobject(srcClass, destClass, tmpName,
                                                       args.pos, convOut, ctx)
              sw.write(",")
              sw.write(convOut.ToString())
              sw.write("A" .. (ai + 1))
              sw.write(close)
            ELSEIF args.callArglist[ai].type.ttype == Type.Enum.byRef
                            && methodArgList[ai].type.ttype != Type.Enum.byRef
              # &var -> var
              sw.write(",*A" .. (ai + 1))
            ELSEIF methodArgList[ai].type.isXobject(ctx)
              sw.write(",(void*)A" .. (ai + 1))
            ELSE
              sw.write(",A" .. (ai + 1))
            }
          }
          sw.write(");")
          IF maxTmpIdx < tmpIdx
            maxTmpIdx = tmpIdx
          }

          # The call up to here is remembered for if there is only one method.
          lastCall = sw.ToString()
          tmpOut.write(lastCall)
          sw.clear()

          IF mtype.ttype != Type.Enum.func
            tmpOut.write(" return;")
          }
          tmpOut.write("\n")
        ELSE
          tmpOut.write("   return")
          IF mtype.ttype == Type.Enum.func
            tmpOut.write(" 0")
          }
          tmpOut.write(";\n")
        }
      }

      # Advance to the next class for the argument.
      tmpOut.writing = ctx.out.writing
      depth = advanceToNextClass(altList, args, depth, tmpOut)
      IF depth <= 0
        BREAK
      }
    }

    $virtualDeclOut.writing = ctx.out.writing
    $virtualBodyOut.writing = ctx.out.writing

    Output headOut = NEW()
    headOut.writing = ctx.out.writing
    SContext virtualCtx = ctx.copy(headOut)

    # Write return type.
    IF args.retType == NIL || args.retType.ttype == Type.Enum.unknown
      headOut.write("void ")
    ELSE
      $vartype(args.retType, TRUE, args.pos, virtualCtx)
    }

    # When writing use a short name instead of the function key name.
    string funcName = args.funcKey
    IF ctx.out.writing
      funcName = getUid(args.funcKey)
    }
    headOut.write(funcName .. "(")

    # produce the arguments: "(classType A0, arg1Type A1, arg2Type A2)"
    IF args.varType.ttype == Type.Enum.object
      $vartype(args.varType.getClassType(ctx), TRUE, args.pos, virtualCtx)
    ELSE
      $vartype(args.varType, TRUE, args.pos, virtualCtx)
    }
    headOut.write("A0")
    int argIdx = 1
    FOR d IN args.callArglist
      headOut.write(", ")
      # TODO: remove unknown
      IF d.type.ttype == Type.Enum.nilval || d.type.ttype == Type.Enum.unknown
        # Should be a NIL.
        headOut.write("void *")
      ELSE
        $vartype(d.type.getEffType(), TRUE, args.pos, virtualCtx)
      }
      headOut.write("A" .. argIdx)
      argIdx++
    }
    headOut.write(")")

    # Append the function declaration to virtualDeclOut.
    $virtualDeclOut.append(headOut)
    $virtualDeclOut.write("; /* " .. args.funcKey .. " */\n")

    # Append the function body to virtualBodyOut.
    $virtualBodyOut.append(headOut)
    $virtualBodyOut.write(" {\n")

    FOR i IN 0 UNTIL maxTmpIdx
      $virtualBodyOut.write(" Tr t" .. i .. ";\n")
    }

    IF args.haveTwoMethods
      # The type of object matters.  When an argument is NIL we don't know
      # what method to call, thus throw an exception.
      IF argNotNull.Size() > 0
        FOR ai IN argNotNull.keys()
          string what
          IF ai == 0
            what = "object"
          ELSE
            what = "argument " .. ai
          }
          $setDeclUsed(Declaration.throwCstringNil)
          ClassType argClass
          IF ai == 0
            argClass = args.varType.getClassType(ctx)
          ELSE
            argClass = args.callArglist[ai - 1].type.getClassType(ctx)
          }
          $virtualBodyOut.write(" if (A" .. ai)
          IF argClass.isIobject(ctx)
            $virtualBodyOut.write(".ptr")
          }
          $virtualBodyOut.write(" == NULL) ZthrowCstringNil(\""
              .. args.methodName .. ": "
              .. what .. " is NIL, cannot select method to invoke\");\n")
        }
      }

      $virtualBodyOut.append(tmpOut)
      # If we get to the end something is wrong.
      $virtualBodyOut.write(
          " ZthrowCstringBadValue(\""
              .. args.methodName .. ": cannot select method to invoke\");\n")
      $setDeclUsed(Declaration.throwCstringBadValue)
      # Avoid a compiler warning for missing return.
      IF args.retType == NIL || args.retType.ttype == Type.Enum.unknown
        $virtualBodyOut.write(" return;\n")
      ELSE
        $virtualBodyOut.write(" return ")
        $writeNilValue(args.retType, $virtualBodyOut, ctx)
        $virtualBodyOut.write(";\n")
      }
    ELSE
      # There is only one method to call, do that directly here.
      $virtualBodyOut.write(lastCall)
      $virtualBodyOut.write("\n")
    }
    $virtualBodyOut.write("}\n")

    Declaration.C funcDecl = NEW(funcName)
    funcDecl.type = args.retType
    IF args.retType != NIL && args.retType.ttype == Type.Enum.object
      # It is possible that a child is found for a class later, then
      # the type changes from object to iobject and we need to come
      # back here to take care of that.
      ClassType ct = args.retType.getClassType(ctx)
      IF ct != NIL
        ct.scope.addScopeDependency(ctx.scope)
      }
    }

    IF ctx.out.writing
      $virtualFuncMap[args.funcKey] = funcDecl
    }
    RETURN funcDecl
  }

  # "object.member.(expr)(arg)" -> (cast)(expr)(object.member, arg);
  FUNC $memberExpr(Zui.MethodCall call, Generate.CallbackInfo cbInfo,
                                             SContext ctx, Type destType) Type
    Zui.Expression nameExpr = call.getName()
    ZuiMethodCallExt callExt = call

    # We don't want an iobject "Tr" here but the actual class.
    bool avoidTr = callExt.typeObj.getMethod().classType != NIL
    $refCast(callExt.typeObj, TRUE, avoidTr, call.getPos(), ctx)

    # Evaluate "(expr)": function pointer
    ctx.out.write("(")
    # TODO: when the expression has side effects need a temp var.
    genExpr(nameExpr.getRight(), ctx)

    ctx.out.write(")")
    ctx.out.write("->cfunc")
    ctx.out.write(")(")
    genExpr(nameExpr.getRight(), ctx)
    ctx.out.write(", (")

    # Evaluate "object.member", the THIS argument for the method.
    MethodType mt = callExt.typeObj.getMethod()
    Type exprType = genExpr(nameExpr.getLeft(), ctx,
                                               mt.classType.getValueType(ctx))
    ctx.out.write(")")
    IF exprType?.isIobject(ctx)
      # TODO: is this the right way?
      ctx.out.write(".ptr")
    }

    # Evaluate "(arg)"
    list<Declaration.C> argList = callExt.typeObj.getArgList()
    IF argList != NIL && argList.Size() > 0
      ctx.out.write(", ")
      Generate.generateArgumentsCheck(call, "{expr}", ctx, argList, NIL,
                                                                     destType)
    }
    ctx.out.write(")")

    IF callExt.typeObj != NIL
      RETURN callExt.typeObj.getReturnType()
    }
    RETURN NIL
  }

  PROC $argWithType(bool first, Type type, Zui.Position pos,
                                               string argName, SContext ctx)
    IF !first
      ctx.out.write(", ")
    }
    $vartype(type, TRUE, pos, ctx)
    ctx.out.write(argName)
  }

  # Write a varargs argument for |args[startIndex]| .. |args[args.Size() - 1]|
  # |decl| has the type of the method varargs.
  # Return the number of undefined symbols.
  FUNC $writeVarargs(Zui.MethodCall call, Type type, TupleType tupleType,
                  list<Zui.Expression> args, int startIndex, SContext ctx) int
    WriteArrayC.writeVarargs(call, type, tupleType, args, startIndex, ctx)
    RETURN 0
  }

  # Return TRUE when forward declarations are to be written.
  FUNC $doWriteDecl() bool
    RETURN TRUE
  }

  FUNC $subscript(Zui.Expression expr, SContext ctx, Type destType) Type
    Zui.Expression left = expr.getLeft()
    Zui.Expression right = expr.getRight()

    # Get type of "expr".
    # TODO: this is a hack, it should be possible to use expr.typeObj
    Type type = genExpr(left, ctx.copyNoOut())

    Type ret
    IF type != NIL && type.ttype != Type.Enum.unknown
      # Flatten typedef
      type = type.getEffType()

      IF type.ttype == Type.Enum.array
        ret = WriteArrayC.generateSubscript(type.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF type.ttype == Type.Enum.list
        ret = WriteListC.generateSubscript(type.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF type.ttype == Type.Enum.dict
        ret = WriteDictC.generateSubscript(type.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF type.ttype == Type.Enum.string
          || type.ttype == Type.Enum.stringval
        ctx.out.write("ZstringGetChar(")
        $genArg(left, ctx, Type.aString)
        ctx.out.write(", ")
        $genArg(right, ctx, Type.anInt)
        ctx.out.write(")")
        ret = Type.anInt
#      ELSEIF type.type == Type.Enum.varString
#        # TODO
#        ret = Type.anInt
      ELSEIF type.ttype == Type.Enum.byteString
        ctx.out.write("ZbyteStringGetByte(")
        $genArg(left, ctx, Type.aByteString)
        ctx.out.write(", ")
        $genArg(right, ctx, Type.anInt)
        ctx.out.write(", 0)")
        ret = Type.anInt
#      ELSEIF type.type == Type.Enum.varByteString
#        # TODO
#        ret = Type.anInt
      ELSEIF type.ttype == Type.Enum.tuple
        # tupleVar[3]
        ret = $tupleSubscript(type.<TupleType>, left, right, ctx)
      ELSEIF type.ttype == Type.Enum.multiple
        # multiRetFunc()[3]
        ret = $multipleSubscript(type.<MultipleType>, left, right, ctx)
      ELSEIF ctx.doError()
        ctx.error("type does not allow subscript: " .. type.typeName(), expr)
      }
    ELSEIF ctx.out.writing
      # Generate the error message for "expr"
      genExpr(left, ctx)
    }
    RETURN ret
  }


  FUNC $tupleSubscript(TupleType type, Zui.Expression left,
                                      Zui.Expression right, SContext ctx) Type
    bool dummy
    int idx = ExprEval.evalInt(right, ctx, TRUE, &dummy)
    IF idx < 0 || idx >= type.types.Size()
      IF ctx.doError()
        ctx.error("Subscript out of range: " .. idx
                       .. ", must be 0 .. " .. (type.types.Size() - 1), right)
      }
      RETURN NIL
    }
    RETURN $tupleItem(type, left, idx, ctx)
  }

  FUNC $tupleItem(TupleType type, Zui.Expression left, int idx,
                                                            SContext ctx) Type
    ctx.out.write("(")
    genExpr(left, ctx, type)
    ctx.out.write(")->m")
    ctx.out.write(idx)
    RETURN type.types[idx].type
  }

  PROC $tupleItem(string tempName, int idx, Zui.Position pos, SContext ctx)
    ctx.out.write(tempName)
    ctx.out.write("->m")
    ctx.out.write(idx)
  }

  FUNC $multipleSubscript(MultipleType type, Zui.Expression left,
                                      Zui.Expression right, SContext ctx) Type
    bool dummy
    int idx = ExprEval.evalInt(right, ctx, TRUE, &dummy)
    IF idx < 0 || idx >= type.types.Size()
      IF ctx.doError()
        ctx.error("Subscript out of range: " .. idx
                       .. ", must be 0 .. " .. (type.types.Size() - 1), right)
      }
      RETURN NIL
    }
    ctx.out.write("(")
    genExpr(left, ctx, type)
    ctx.out.write(").a" .. idx)
    RETURN type.types[idx].type
  }

  PROC $multiReturnItem(Declaration tempDecl, int i,
                                   Zui.Position pos, Output out, SContext ctx)
    out.write(tempDecl.pName)
    out.write(".a" .. i)
  }

  FUNC $varnameSubscript(Type type, Zui.Expression expr, bool lvalue,
                                             SContext ctx, Type destType) Type
    Type.Enum ttype = type?.getTtype()
    IF ttype == Type.Enum.tuple
      # tupleVar[3]
      RETURN $tupleSubscript(type.getEffType().<TupleType>,
                                         expr.getLeft(), expr.getRight(), ctx)
    }

    Type effType = type?.getEffType()
    IF effType != NIL && effType ISA ContainerType
      ContainerType cont = effType
      IF ttype == Type.Enum.array
        WriteArrayC.generateSubscript(cont, expr, lvalue, ctx, destType)
      ELSEIF ttype == Type.Enum.list
        WriteListC.generateSubscript(cont, expr, lvalue, ctx, destType)
      ELSEIF ttype == Type.Enum.dict
        WriteDictC.generateSubscript(cont, expr, lvalue, ctx, destType)
      }
      RETURN cont?.itemType
    }

# TODO: unused
#    ELSE
#      bool cast
#      IF ttype == Type.Enum.string || ttype == Type.Enum.byteString
#        cast = TRUE
#        ctx.out.write("((Tc*)(")
#      }
#      Generate.generateVarnamePart(expr.getLeft(), FALSE, ctx, destType)
#      IF cast
#        ctx.out.write("))")
#      }
#      ctx.out.write("[")
#      genExpr(expr.getRight(), ctx, Type.anInt)
#      ctx.out.write(" + ZOH_OFF]")
#    }
    RETURN NIL
  }

  FUNC $useDictAssignFunction() bool
    RETURN FALSE
  }

  FUNC $dictAssign(string varname, string key, SContext ctx) string
    RETURN ""
  }

  FUNC $funcCallForRef(Zui.Expression expr, Generate.LhsEntry entry,
                                                          SContext ctx) string
    RETURN NIL
  }

  FUNC $dictGet(ContainerType type, Zui.Expression dictExpr,
                                                       Zui.Expression keyExpr,
                         Zui.Expression defExpr, SContext ctx, Type destType
                 ) Type
    RETURN WriteDictC.generateGet(
                              type, dictExpr, keyExpr, defExpr, ctx, destType)
  }

  FUNC $classMemberTableName(ClassType class) string
    RETURN class.pName .. "__mt"
  }

  # Generate accessing an object member |objDecl| of an interface |itfType|.
  # When |genVarname| is TRUE use generateVarnamePart instead of genExpr.
  PROC $iobjectMember(Declaration objDecl, Type itfType,
                      Zui.Expression expr, bool dotnil,
                               SContext ctx, Type destType, bool genVarname)
    int idx = WriteIMT.interfaceMemberTableIndex(itfType, objDecl, TRUE, ctx)
    $iobjectMemberIdx(objDecl, itfType, expr, dotnil,
                                               ctx, destType, genVarname, idx)
  }

  # Like $iobjectMember() but for a callback, where |methodDecl| is used to
  # find the method index and |callbackDecl| is the actual callback to invoke.
  PROC $iobjectCallbackMember(Declaration methodDecl,
                      Declaration callbackDecl, Type itfType,
                      Zui.Expression expr, bool dotnil,
                               SContext ctx, Type destType, bool genVarname)
    int idx = WriteIMT.interfaceMemberTableIndex(itfType, methodDecl, TRUE, ctx)
    ++idx  # callback is in table[] after the method
    IF methodDecl.hasDirectRef
      ++idx  # a Tcb is in between the method and the callback
    }
    $iobjectMemberIdx(callbackDecl, itfType, expr, dotnil,
                                               ctx, destType, genVarname, idx)
  }

  PROC $iobjectMemberIdx(Declaration objDecl, Type itfType,
                      Zui.Expression expr, bool dotnil,
                        SContext ctx, Type destType, bool genVarname, int idx)
    # some.member -> (*(type *)(some->ptr + (size_t)some->table[index]))
    # BUT: if "some" may have side effects do it like this:
    #      (*(type *)ZoM(some, index))
    ClassType itfClassType = itfType.getClassType(ctx)
    ctx.out.write("(*(")
    $vartype(objDecl.type, FALSE, expr.getPos(), ctx)
    ctx.out.write("*)")
    Zui.Expression left = expr.getLeft()
    IF left.getType() == Zui.ExprType.eID && !dotnil
      ctx.out.write("(")
      IF !itfType.isIobject(ctx)
        ctx.out.write("(Tc*)")
      }
      IF genVarname
        Generate.generateVarnamePart(left, FALSE, ctx, itfType)
      ELSE
        genExpr(left, ctx, itfType)
      }
      IF itfType.isIobject(ctx)
        ctx.out.write(".ptr")
      }
      ctx.out.write(" + (size_t)")
      IF genVarname
        Generate.generateVarnamePart(left, FALSE, ctx, itfType)
      ELSE
        genExpr(left, ctx, itfType)
      }
      IF itfType.isIobject(ctx)
        ctx.out.write(".table[")
      ELSE
        ctx.out.write("->mt[")
      }
      ctx.out.write(idx .. "")
      ctx.out.write("])")
    ELSE
      IF dotnil
        IF itfType.isXobject(ctx)
          ctx.out.write("ZoXd(")
        ELSE
          ctx.out.write("ZoMd(")
        }
      ELSEIF itfType.isXobject(ctx)
        ctx.out.write("ZoX(")
      ELSE
        ctx.out.write("ZoM(")
      }
      IF genVarname
        Generate.generateVarnamePart(left, FALSE, ctx, destType)
      ELSE
        genExpr(left, ctx, destType)
      }
      ctx.out.write(", ")
      ctx.out.write(WriteIMT.interfaceMemberTableIndex(
                                          itfType, objDecl,  TRUE, ctx) .. "")
      ctx.out.write(")")
    }
    ctx.out.write(")")
  }

  FUNC $iobjectFuncUse(Declaration objDecl, Type itfType,
                                        Zui.Expression expr, SContext ctx) int
    ctx.out.write("(Tcb*)(")
    genExpr(expr, ctx, Type.aParent)
    IF itfType.isXobject(ctx)
      ctx.out.write(")->mt[")
    ELSE
      ctx.out.write(").table[")
    }
    ctx.out.write(WriteIMT.interfaceMemberTableIndex(
                                  itfType, objDecl, ctx.doError(), ctx) .. "")
    # The IMT stores the ZCB pointer in the next entry.
    ctx.out.write(" + 1]")
    RETURN 0
  }

  # Binary operator with int values.
  FUNC $numberOp(Zui.Expression expr, SContext ctx, Type destType) Type
    IF expr.getType() == Zui.ExprType.eREMAINDER
                        && expr.<ZuiExpressionExt>.leftExprType?.getTtype()
                                                            == Type.Enum.float
      # float % requires a function call.
      $setDeclUsed(%math)
      ctx.out.write("fmod(")
      genExpr(expr.getLeft(), ctx, Type.aFloat)
      ctx.out.write(", ")
      genExpr(expr.getRight(), ctx, Type.aFloat)
      ctx.out.write(")")
      RETURN Type.aFloat
    }
    RETURN numberOp(expr, ctx)
  }

  FUNC $stringConcat(Zui.Expression expr, string cast, SContext ctx) string
    ctx.out.write(" = ")
    IF cast != NIL
      ctx.out.write(cast)
    }
    ctx.out.write(" ZcS(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(", ")
    RETURN ")"
  }

  FUNC $varStringConcatAssign(Zui.Assignment assign, SContext ctx) int
    ctx.out.write("ZvarStringConcatAssign(")
    Generate.generateLVarname(assign.getLhs(), TRUE, ctx, NIL)
    ctx.out.write(", ")
    genExpr(assign.getRhs(), ctx, Type.aByteString)
    ctx.out.write(");\n")
    RETURN 0
  }

  PROC $concatStringOp(Zui.Expression expr, SContext ctx, Type destType)
    ctx.out.write("ZcS(")
    # The .. operator supports automatic conversion string or byteString.
    $generatingArg = TRUE
    Generate.genExprDoConv(expr.getLeft(), ctx, destType)
    ctx.out.write(", ")
    Generate.genExprDoConv(expr.getRight(), ctx, destType)
    $generatingArg = FALSE
    ctx.out.write(")")
  }

  # A sequence of 3 or more string concatenation operators.
  PROC $concatStringOp(list<Zui.Expression> concats,
                                                  SContext ctx, Type destType)
    int size = concats.Size()
    int unused
    list<Zui.Expression> doHere = concats
    string comma = ""
    IF size == 3
      ctx.out.write("ZcS3(")
      $setDeclUsed(%concat3)
      unused = 0
    ELSEIF size <= 5
      ctx.out.write("ZcS5(")
      $setDeclUsed(%concat5)
      unused = 5 - size
    ELSEIF size <= 8
      ctx.out.write("ZcS8(")
      $setDeclUsed(%concat8)
      unused = 8 - size
    ELSE
      ctx.out.write("ZcS12(")
      $setDeclUsed(%concat12)
      IF size > 12
        IF size == 13
          # split into 3 + 10
          $concatStringOp(concats.slice(0, 2), ctx, destType)
          doHere = concats.slice(3)
          unused = 1
        ELSE
          # split into N + 11
          $concatStringOp(concats.sliceWrap(0, -12), ctx, destType)
          doHere = concats.sliceWrap(-11)
          unused = 0
        }
        comma = ", "
      ELSE
        unused = 12 - size
      }
    }

    $generatingArg = TRUE
    FOR expr IN doHere
      ctx.out.write(comma)
      Generate.genExprDoConv(expr, ctx, destType)
      comma = ", "
    }
    $generatingArg = FALSE

    FOR i IN 1 TO unused
      ctx.out.write(", (Tc*)1")
    }
    ctx.out.write(")")
  }

  PROC $concatVarStringOp(Zui.Expression expr, SContext ctx, Type destType)
    Type valType = (destType.ttype == Type.Enum.varByteString)
                                             ? Type.aByteString : Type.aString
    string types

    Type.Enum left = Generate.resultType(expr.getLeft(), ctx)
    Type leftType
    IF left == Type.Enum.stringval || left == valType.ttype
      leftType = valType
      types = "V"
    ELSE
      leftType = destType
      types = "B"
    }

    Type.Enum right = Generate.resultType(expr.getRight(), ctx)
    Type rightType
    IF right == Type.Enum.stringval || right == valType.ttype
      rightType = valType
      types ..= "V"
    ELSE
      rightType = destType
      types ..= "B"
    }

    ctx.out.write("ZconcatVarString" .. types .. "(")
    # The .. operator supports automatic conversion varString or varByteString.
    Generate.genExprDoConv(expr.getLeft(), ctx, leftType)
    ctx.out.write(", ")
    Generate.genExprDoConv(expr.getRight(), ctx, rightType)
    ctx.out.write(")")
  }

  # Generate code for a literal number.
  PROC $generateInt(Zui.Expression expr, SContext ctx)
    int n = expr.getNumber()
    IF n > 0x7fff'ffff
               || n < (expr.getType() == Zui.ExprType.eNAT ? 0 : -0x7fff'ffff)
      IF expr.getType() == Zui.ExprType.eNAT
        # The nat was stored as an int, turn it back into a nat here.
        nat u = n
        ctx.out.write(u .. "UL")
      ELSE
        # The largest negative integer causes a compiler warning with C99,
        # because it first uses the unsigned number before it applies the "-"
        # sign. Need this weird solution.
        IF n == -0x8000'0000'0000'0000
          ctx.out.write("(-0x7fffffffffffffffLL - 1)")
        ELSE
          ctx.out.write(n .. "LL")
        }
      }
    ELSE
      ctx.out.write(n .. "")
    }
  }

  # Generate code for a literal float number.
  PROC $generateFloat(Zui.Expression expr, SContext ctx)
    # With 64 bits there are about 16 significant digits.
    ctx.out.write(expr.getFnumber().ToString(".16g"))
  }

  # Keep track of what strings have already been generated. Each one has to be
  # produced only once.
  dict<string, string> $generatedStrings = NEW()

  # Keep track of what string sizes have already been generated. A typedef is
  # generated for each new one.
  set<int> $generatedSizes = NEW()

  # Generate C code for a string from a stringLiteral |expr|.
  # Also handle "string .. string", generate it as one long string.
  PROC $literalStringValue(Zui.Expression expr, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    $writeStringValue(Generate.stringExprToString(expr), ctx)
  }

  # Write a string value.
  PROC $writeStringValue(string value, SContext ctx)
    string pName = $writeStaticString(value, ctx)
    Output out = ctx.out
    out.write("((Tc*)&")
    out.write(pName)
    out.write(")")
  }

  # Generate C code for a byteString from a byteStringLiteral |expr|.
  # Also handle "string .. string", generate it as one long string.
  PROC $literalByteStringValue(Zui.Expression expr, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    byteString value = Generate.byteStringExprToString(expr)
    string pName = $writeStaticString(value.asString(), ctx)
    Output out = ctx.out
    out.write("((Tc*)&")
    out.write(pName)
    out.write(")")
  }

  # Write a declaration for a static string to declOut.
  # Return the name of the struct.
  FUNC $writeStaticString(string value, SContext ctx) string @replace
    IF !ctx.out.writing
      RETURN ""
    }

    string pName = $generatedStrings.get(value, NIL)
    IF pName == NIL
      IF value == "NIL"
        pName = "ZNilString"
      ELSE
        pName = getUid(value)
      }
      $writeNewStaticString(value, pName, ctx)
    }
    RETURN pName
  }

  PROC $writeNewStaticString(string value, string pName, SContext ctx)
    $generatedStrings.add(value, pName)

    # Write the size as a varint, MSB first.
    int size = value.asByteString().Size()
    int len = size + 1
    string s = ""
    int add = 0
    DO
      s = Generate.toOctal(add + (size & 127)) .. s
      size = size >> 7
      add = 128
      ++len
    UNTIL size == 0
    IF !$generatedSizes.has(len)
      $generatedSizes.set(len)
      Output sout = ctx.outs.structOut
      sout.write("typedef struct {\n")
      IF $hasNpField()
        sout.write(linkedDecl)
      }
      sout.write(" char text[")
      sout.write(len)
      sout.write("];\n")
      sout.write("} Zs")
      sout.write(len)
      sout.write(";\n")
    }

    Output dout = ctx.outs.declOut
    dout.write("Zs" .. len)
    dout.write(" ")
    dout.write(pName)
    dout.write(" = {")
    IF $hasNpField()
      dout.write("&Zstatic, ")
    }
    dout.write("\"")
    dout.write(s)
    WriteCommon.writeByteString(value.asByteString(), dout)
    dout.write("\\000\"};\n")
  }

  # Generate code to set varByteString |dest| from a stringLiteral |expr|.
  PROC $varByteStringSetString(Zui.Expression expr, Declaration dest, SContext ctx)
    Output out = ctx.out
    out.write("ZvarByteStringSet(&")
    out.write(dest.pName)
    out.write(", ")
    $literalByteStringValue(expr, ctx)
    out.write(")")
    $setDeclUsed(%varByteStringSet)
  }

  PROC $incrdecrOp(Zui.Expression expr, SContext ctx)
    incrdecrOp(expr, ctx)
  }

  # "expr ISA classType" and "expr ISNOTA classType"
  PROC $isaOp(Zui.Expression expr, SContext ctx)
    Type rightType = $isaOpType(expr, ctx)
    IF rightType != NIL
      IF $isDeclUsed(rightType) || $isDeclUsed(rightType.getClassType(ctx))
        $writeIsa(expr, expr.getType() == Zui.ExprType.eISNOTA,
                                                rightType, expr.getPos(), ctx)
      ELSEIF expr.getType() == Zui.ExprType.eISNOTA
        # The RHS type is not used, ISNOTA is always true.
        ctx.out.write("1")
      ELSE
        # The RHS type is not used, ISA is always false.
        ctx.out.write("0")
      }
    }
  }

  # Produce code for ISA, ISNOTA and CATCH.
  # When |expr| is NIL the value to is the thrown exception, otherwise it's
  # an expresion in expr.getLeft().
  # |rightSym| is the classType to compare with.
  PROC $writeIsa(Zui.Expression expr, bool isnota, Type rightType,
                                               Zui.Position pos, SContext ctx)
    Output tmpOut = NEW()
    tmpOut.writing = ctx.out.writing
    ClassType rightClass = rightType.getClassType(ctx)
    bool rightIsInterface = rightClass.ttype == Type.Enum.interface

    Type leftType
    Output saveOut = ctx.setOut(tmpOut)
    IF expr == NIL  # catch
      ctx.out.write("te->thrown[te->thrownUsed - 1]")
      leftType = Builtin.getExceptionDotIType()
    ELSE
      # generate "expr"
      leftType = genExpr(expr.getLeft(), ctx)
    }
    ctx.setOut(saveOut)

    IF leftType == NIL
      RETURN  # error already given
    }
    ClassType leftClass = leftType?.getClassType(ctx)

    IF leftType.ttype != Type.Enum.iobject
      IF leftType.ttype == Type.Enum.object
        # We know the left type, result only depends on the object being NIL
        # or not.
        ctx.out.append(tmpOut)
        IF rightIsInterface ? leftClass.hasInterface(rightClass, ctx)
                            : leftClass IS rightClass
          ctx.out.write(isnota ? " == NULL" : " != NULL")
        ELSE
          ctx.out.write(isnota ? " != NULL" : " == NULL")
        }
      ELSE
        ctx.error("Expected object type, got " .. leftType.typeName(),
                                                               expr.getLeft())
      }
      RETURN
    }
    IF leftClass == NIL
      ctx.error("class unknown", expr == NIL ? pos : expr.getLeft().getPos())
      RETURN
    }

    IF rightIsInterface
      # For a ISA I_foo we need to use a table lookup.
      IF isnota
        ctx.out.write("!")
      }
      IF leftType.isIobject(ctx)
        ctx.out.write(WriteIMT.interfaceTableName(leftClass, rightClass, ctx))
        ctx.out.write("[")
      ELSE
        $setDeclUsed(%xobjIsaTab)
        ctx.out.write("ZxobjIsaTab(")
      }
    ELSEIF rightType.ttype == Type.Enum.iobject
                                       || rightClass.hasUsedCountChildren(ctx)
      # If "rightType" is an iobject or has children we need to check a range
      # of types.
      IF isnota
        ctx.out.write("!")
      }
      IF leftType.isIobject(ctx)
        $setDeclUsed(%typeInRange)
        ctx.out.write("ZTypeInRange(")
      ELSE
        $setDeclUsed(%typepInRange)
        ctx.out.write("ZTypepInRange(")
      }
    ELSEIF leftType.isXobject(ctx)
      $setDeclUsed(%xobjIsa)
      IF isnota
        ctx.out.write("!")
      }
      ctx.out.write("ZxobjIsa(")
    ELSEIF !leftType.isIobject(ctx)
      $setDeclUsed(%objIsa)
      IF isnota
        ctx.out.write("!")
      }
      ctx.out.write("ZobjIsa(")
    }
    IF leftType.isIobject(ctx)
      ctx.out.write("(")
    }
    ctx.out.append(tmpOut)

    IF leftType.isIobject(ctx)
      ctx.out.write(").type")
    }

    bool error
    IF rightIsInterface
      IF leftType.isIobject(ctx)
        ctx.out.write("]")
      ELSE
        ctx.out.write(", ")
        ctx.out.write(WriteIMT.interfaceTableName(leftClass, rightClass, ctx))
        ctx.out.write(")")
      }
    ELSEIF rightType.ttype == Type.Enum.iobject
                                       || rightClass.hasUsedCountChildren(ctx)
      int low
      int high
      ClassType tableClass
      IF leftType.isIobject(ctx)
        low = leftClass.childIndex(rightClass, FALSE)
        error = low < 0
        high = leftClass.childIndex(rightClass, TRUE)
        tableClass = leftClass
      ELSE
        low = rightClass.rootIndex
        high = rightClass.nextRootIndex()
        tableClass = leftClass.rootClass()
      }

      ctx.out.write(", ")
      ctx.out.write(low)
      ctx.out.write(", ")
      ctx.out.write((high - 1))
      ctx.out.write(", ")
      IF expr == NIL || Type.isInterfaceLike(rightType)
        # Do not rule out interface type for CATCH and for Class.I
        ctx.out.write("NULL")
      ELSE
        ctx.out.write(WriteIMT.implementerTableName(tableClass))
      }
      ctx.out.write(")")
    ELSE
      # Must be a class, otherwise isaOpType() would have returned NIL.
      IF leftType.isIobject(ctx)
        IF isnota
          ctx.out.write(" != ")
        ELSE
          ctx.out.write(" == ")
        }
      }
      int i
      IF leftType.isXobject(ctx)
        i = rightClass.rootIndex
      ELSE
        i = leftClass.childIndex(rightType, FALSE)
      }
      error = i < 0
      IF leftType.isIobject(ctx)
        ctx.out.write("" .. i)
      ELSEIF leftType.isXobject(ctx)
        ctx.out.write(", " .. i .. ")")
      ELSE
        ctx.out.write(", &" .. rightClass.pName .. "__T)")
      }
    }
    IF error
      ctx.error("Incompatible types : \(leftClass.typeName()) ISA \(rightClass.typeName())", pos)
    }
  }

  # When |expr| results in an i_object, dereference it, otherwise produce it
  # directly.
  PROC $mayDeref(Zui.Expression expr, SContext ctx)
    Type type = genExpr(expr, ctx.copyNoOut(), Type.aNil)
    IF type != NIL && type.isIobject(ctx)
        ctx.out.write("((")
        $genArg(expr, ctx, Type.aNil)
        ctx.out.write(").ptr)")
    ELSE
      $wrapExpr(expr, ctx, Type.aNil)
    }
  }

  PROC $booleanOp(Zui.Expression expr, bool isCompare, SContext ctx)
    bool isNot = expr.getType() == Zui.ExprType.eNOTEQUAL
              || expr.getType() == Zui.ExprType.eISNOT
              || expr.getType() == Zui.ExprType.eNOMATCH
              || expr.getType() == Zui.ExprType.eNOMATCHIC
    bool isMatch = expr.getType() == Zui.ExprType.eMATCH
                || expr.getType() == Zui.ExprType.eMATCHIC
                || expr.getType() == Zui.ExprType.eNOMATCH
                || expr.getType() == Zui.ExprType.eNOMATCHIC
    Zui.Expression left = expr.getLeft()
    Zui.Expression right = expr.getRight()
    ZuiExpressionExt exprExt = expr

    # val == NAN and NAN == val need to use isNan().
    IF left.getType() == Zui.ExprType.eNAN && !isMatch
      IF isNot
        ctx.out.write("!")
      }
      $isNan(right, ctx)
      RETURN
    }
    IF right.getType() == Zui.ExprType.eNAN && !isMatch
      IF isNot
        ctx.out.write("!")
      }
      $isNan(left, ctx)
      RETURN
    }

    IF exprExt.leftExprType == NIL
      # Avoid checking for NIL many times.
      exprExt.leftExprType = Type.anUnknown
    }
    IF exprExt.rightExprType == NIL
      # Avoid checking for NIL many times.
      exprExt.rightExprType = Type.anUnknown
    }

    # "not-alloced type == NIL" checks if it was initialized.
    IF exprExt.leftExprType.isNoAlloc()
        && (expr.getType() == Zui.ExprType.eEQUAL
              || expr.getType() == Zui.ExprType.eEQUALIC
              || expr.getType() == Zui.ExprType.eNOTEQUAL
              || expr.getType() == Zui.ExprType.eNOTEQUALIC)
        && (left.getType() == Zui.ExprType.eNIL
                                       || right.getType() == Zui.ExprType.eNIL)
      IF left.getType() == Zui.ExprType.eNIL
        genExpr(right, ctx, Type.aNil)
      ELSE
        genExpr(left, ctx, Type.aNil)
      }
      ctx.out.write("->np ")
      ctx.out.write(isNot ? "!" : "=")
      ctx.out.write("= NULL")
      RETURN
    }

    IF isMatch
      bool isIgnoreCase = expr.getType() == Zui.ExprType.eMATCHIC
                       || expr.getType() == Zui.ExprType.eNOMATCHIC
      string new = DeclStore.getPName("MREModule__CRegex",
                                            isIgnoreCase ? "MNEW__1" : "MNEW")
      string matches = DeclStore.getPName("MREModule__CRegex", "Mmatches")
      IF isNot
        ctx.out.write("!")
      }
      ctx.out.write(matches)
      ctx.out.write("(")
      ctx.out.write(new)
      ctx.out.write("(NULL, ")
      genExpr(expr.getRight(), ctx, Type.aString)
      IF isIgnoreCase
        ctx.out.write(", 1), ")
      ELSE
        ctx.out.write("), ")
      }
      genExpr(expr.getLeft(), ctx, Type.aString)
      ctx.out.write(")")
      RETURN
    }

    string op = compareOp(expr)
    IF exprExt.leftExprType.ttype == Type.Enum.dyn
                               || exprExt.rightExprType.ttype == Type.Enum.dyn
      IF isNot
        ctx.out.write("!")
      }
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
                                 && exprExt.rightExprType.ttype == Type.Enum.dyn
        $writeFuncLeftRight(expr, isCompare ? "ZdynCompare" : "ZdynEqual",
                                                               Type.aDyn, ctx)
        IF isCompare
          ctx.out.write(op)
          ctx.out.write("0")
        }
        RETURN
      }
      ctx.out.write(isCompare ? "ZdynCompareOne(" : "ZdynEqualOne(")
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
        $wrapExpr(left, ctx, Type.aDyn)
      ELSE
        $wrapExpr(right, ctx, Type.aDyn)
      }
      ctx.out.write(", ")
      Type other
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
        other = exprExt.rightExprType
        genTzArg(other, right, ctx)
      ELSE
        other = exprExt.leftExprType
        genTzArg(other, left, ctx)
      }
      ctx.out.write(", ")
      ctx.out.write($getDynType(other, expr.getPos(), ctx))
      ctx.out.write(")")
      RETURN
    }

    IF expr.getType() == Zui.ExprType.eEQUAL
            || expr.getType() == Zui.ExprType.eNOTEQUAL
            || isCompare
      # == !=  > >= < <= for container types
      string name
      IF exprExt.leftExprType.ttype == Type.Enum.array
        $setDeclUsed(isCompare ? WriteArrayC.arrayCompare
                                                     : WriteArrayC.arrayEqual)
        name = "ZArray"
      ELSEIF exprExt.leftExprType.ttype == Type.Enum.list
        $setDeclUsed(isCompare ? WriteListC.listCompare : WriteListC.listEqual)
        name = "ZList"
      ELSEIF exprExt.leftExprType.ttype == Type.Enum.dict
        $setDeclUsed(isCompare ? WriteDictC.dictCompare : WriteDictC.dictEqual)
        name = "ZDict"
      }
      IF name != NIL
        IF isNot
          ctx.out.write("!")
        }
        $writeFuncLeftRight(expr, name .. (isCompare ? "Compare" : "Equal"),
                                                                     NIL, ctx)
        IF isCompare
          ctx.out.write(op)
          ctx.out.write("0")
        }
        RETURN
      }
    }

    ctx.out.write("(")
    IF exprExt.leftExprType.ttype == Type.Enum.nilval
      $wrapExpr(left, ctx, Type.aNil)
      IF left.<ZuiExpressionExt>.resultType?.getTtype() == Type.Enum.dyn
        # dyn == NIL ->  dyn.type == NULL
        ctx.out.write(".type")
      }
      ctx.out.write(op)
      $wrapExpr(right, ctx, Type.aNil)
      IF right.<ZuiExpressionExt>.resultType?.getTtype() == Type.Enum.dyn
        # NIL == cyn ->  NULL = dyn.type
        ctx.out.write(".type")
      }
    ELSEIF exprExt.leftExprType.ttype == Type.Enum.iobject
      $mayDeref(left, ctx)
      ctx.out.write(op)
      # Types may sometimes differ, use a generic type cast.
      ctx.out.write("(void *)")
      $mayDeref(right, ctx)
    ELSEIF exprExt.leftExprType.ttype == Type.Enum.string
        || exprExt.leftExprType.ttype == Type.Enum.byteString
        || exprExt.leftExprType.ttype == Type.Enum.stringval
      $setDeclUsed(%stringCmp)
      $stringCmpOp(expr, ctx, "ZstringCmp",
                       exprExt.leftExprType.ttype == Type.Enum.string
                          || exprExt.leftExprType.ttype == Type.Enum.stringval
                                            ? Type.aString : Type.aByteString)
    ELSEIF exprExt.leftExprType.ttype == Type.Enum.varString
        || exprExt.leftExprType.ttype == Type.Enum.varByteString
      LOG.internal("Sorry, varString/varByteString compare not implemented yet")
      $setDeclUsed(%varByteStringCmp)
      $stringCmpOp(expr, ctx, "ZvarByteStringCmp",
               exprExt.leftExprType.ttype == Type.Enum.varString
                                      ? Type.aVarString : Type.aVarByteString)
    ELSEIF exprExt.leftExprType.ttype != Type.Enum.unknown
      IF exprExt.leftExprType.ttype == Type.Enum.object
        IF isNot
          ctx.out.write("!")
        }
        # Generate a call to left.Equal(right) or left.Compare(right)
        Generate.generateEqualCall(expr, isCompare, ctx)
        IF isCompare
          ctx.out.write(op)
          ctx.out.write("0")
        }
      ELSE
        $wrapExpr(expr.getLeft(), ctx, exprExt.leftExprType)
        ctx.out.write(op)
        $wrapExpr(expr.getRight(), ctx, exprExt.rightExprType)
      }
    ELSEIF ctx.doError()
      bool err = genExpr(expr.getLeft(), ctx) == NIL
      err = err || genExpr(expr.getRight(), ctx) == NIL
      IF !err
        Report.internal("booleanOp(): unknown types")
      }
    }
    ctx.out.write(")")
  }

  PROC $stringCmpOp(Zui.Expression expr, SContext ctx, string name, Type type)
    bool leftEmpty = expr.getLeft().getType() == Zui.ExprType.eSTRING
                                      && expr.getLeft().getStringValue() == ""
    bool rightEmpty = expr.getRight().getType() == Zui.ExprType.eSTRING
                                      && expr.getRight().getStringValue() == ""
    IF leftEmpty || rightEmpty
      # "" == s -> s.Size() == 0
      # "" != s -> s.Size() != 0
      # s == "" -> s.Size() == 0
      # s != "" -> s.Size() != 0
      IF type.ttype == Type.Enum.string
        || type.ttype == Type.Enum.byteString
        || type.ttype == Type.Enum.stringval
        ctx.out.write("ZbyteStringSize(")
      ELSE
        ctx.out.write("ZvarByteStringSize(")
      }
      $generatingArg = TRUE
      Generate.genExprDoConv(leftEmpty ? expr.getRight() : expr.getLeft(),
                                                                    ctx, type)
      $generatingArg = FALSE
    ELSE
      ctx.out.write(name .. "(")
      $generatingArg = TRUE
      Generate.genExprDoConv(expr.getLeft(), ctx, type)
      ctx.out.write(", ")
      Generate.genExprDoConv(expr.getRight(), ctx, type)
      $generatingArg = FALSE
    }
    IF expr.getType() == Zui.ExprType.eEQUAL
      ctx.out.write(") == 0")
    ELSE
      ctx.out.write(") != 0")
    }
  }

  PROC $andorOp(Zui.Expression expr, SContext ctx)
    andorOp(expr, ctx)
  }

  FUNC $parens(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    ctx.out.write("(")
    Type ret = Generate.genExprConv(expr.getRight(), ctx, exprArg)
    ctx.out.write(")")
    RETURN ret
  }

  FUNC $altOp(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    RETURN altOp(expr, ctx, exprArg)
  }

  int $ptrIdx
  FUNC $ifnilOp(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    int idx
    IF ctx.out.writing
      # Need to get the value, genExprConv() is recursive.
      idx = ++$ptrIdx
    }
    ctx.out.write("((p" .. idx .. " = (")
    Type typeL = Generate.genExprConv(expr.getLeft(), ctx, exprArg)
    ctx.out.write("))")
    IF exprArg.destType()?.isIobject(ctx)
      ctx.out.write(".ptr")
    }
    ctx.out.write(" == NULL ? (")

    IF ctx.out.writing && typeL != NIL
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      IF typeL.isIobject(ctx)
        ctx.outs.varOut.write("Tr ")
      ELSE
        ctx.outs.varOut.write("void *")
      }
      ctx.outs.varOut.write("p" .. idx .. ";\n")
    }

    ExprArg r = exprArg.copy()
    IF r.dest == NIL || !r.dest.type.typeDefined()
      # Helps for the argument of FOR.
      r.dest = typeL
    }
    Type typeR = Generate.genExprConv(expr.getRight(), ctx, r)
    ctx.out.write(") : p" .. idx .. ")")

    # TODO: if destType is NIL check typeL and typeR are the same type
    IF typeR == NIL || !typeR.typeDefined()
      typeR = typeL
    }
    IF typeR != NIL
      IF typeR.isValueType()
        ctx.error("Expected a reference", expr.getRight())
      }
      RETURN typeR
    }

    RETURN NIL
  }

  PROC $newVarByteString(string noAllocName, SContext ctx)
    ctx.setDeclUsed(%varByteStringType)
    IF noAllocName == NIL
      $writeAlloc("Ty", NIL, NIL, ctx.out, ctx)
    ELSE
      $writeNoAllocClear("Ty", NIL, NIL, NIL, noAllocName, ctx)
    }
  }

  PROC $listInitStart(MethodType newFromList, Declaration dest,
                                                  SContext ctx, Type destType)
    ctx.out.write(newFromList.pName .. "(")
    $writeNoAllocInit(dest, ctx)
    ctx.out.write(", ")
  }

  # Write the initialization for a not allocated type, when the destination is
  # an object.
  PROC $writeNoAllocInit(Declaration dest, SContext ctx)
    IF dest == NIL
      ctx.out.write("NULL")
    ELSE
      ClassType class = dest.type.getClassType(ctx)
      Declaration initMethod = Generate.findUsefulInit(class.scope)
      Declaration finishMethod = Generate.getFinishMethod(class.scope, ctx)
      $writeNoAllocClear(class.pName, class,
                                          initMethod, finishMethod, dest, ctx)
    }
  }

  PROC $listInitTail(SContext ctx)
    ctx.out.write(")")
  }

  PROC $dictInitStart(MethodType newFromDict, Declaration dest,
                                                  SContext ctx, Type destType)
    ctx.out.write(newFromDict.pName .. "(")
    $writeNoAllocInit(dest, ctx)
    ctx.out.write(", ")
  }

  PROC $dictInitTail(SContext ctx)
    ctx.out.write(")")
  }

  FUNC $newArrayInit(Zui.Expression expr, string noAllocName,
                                             Type destType, SContext ctx) Type
    RETURN WriteArrayC.newArrayInit(expr, noAllocName, ctx, destType)
  }

  FUNC $newListInit(Zui.Expression expr, string noAllocName,
                                             Type destType, SContext ctx) Type
    RETURN WriteListC.generateListPart(expr, noAllocName, ctx, destType)
  }

  PROC $newDictInit(Zui.Expression expr, string noAllocName,
                            SContext ctx, ContainerType type, Type destType)
    WriteDictC.generateNewDict(expr, noAllocName, ctx, type, destType)
  }

  # tuple = [item, item]
  PROC $newTupleInit(Zui.Expression expr, string noAllocName,
                                             TupleType destType, SContext ctx)
    ctx.out.write("Za")
    ctx.out.write(destType.pName)
    ctx.out.write("(")
    IF noAllocName == NIL
      ctx.out.write("NULL")
    ELSE
      ctx.out.write("&")
      ctx.out.write(noAllocName)
    }
    FOR idx IN 0 UNTIL destType.types.Size()
      ctx.out.write(", ")
      Zui.Expression item = expr.getListItem(idx)
      Generate.genExprDoConv(item, ctx, destType.types[idx].type)
    }
    ctx.out.write(")")
  }

  FUNC $dictMethodCall(ContainerType type, Zui.MethodCall call,
                                                 SContext ctx, Type destType
                      ) Type
    RETURN WriteDictC.generateMethodCall(type, call, ctx, destType)
  }

  FUNC $listMethodCall(ContainerType type, Zui.MethodCall call,
                                                   SContext ctx, Type destType
                      ) Type
    RETURN WriteListC.generateMethodCall(type, call, ctx, destType)
  }

  FUNC $arrayMethodCall(ContainerType type, Zui.MethodCall call,
                                                   SContext ctx, Type destType
                      ) Type
    RETURN WriteArrayC.generateMethodCall(type, call, ctx, destType)
  }

  # Bits assignment of |rhs| to |lhs|, of type |bitsMember|.
  # Return the number of undefined symbols in |lhs|.
  FUNC $bitsAssign(Zui.Expression lhs, Zui.Expression rhs,
                                     ValueType bitsMember, SContext ctx) int
    RETURN bitsAssign(lhs, rhs, bitsMember, ctx)
  }

  # A bool field in a BITS.
  PROC $bitsMemberBool(Zui.Expression left, ValueType memberType,
                                                                 SContext ctx)
    bitsMemberBool(left, memberType, ctx)
  }

  # An int (or nat) member of a BITS
  PROC $bitsMemberInt(Zui.Expression left, ValueType memberType,
                                                                 SContext ctx)
    bitsMemberInt(left, memberType, ctx)
  }

  FUNC $expr(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    # Assume that a conversion means using the expression as an argument.
    bool saveGeneratingArg = $generatingArg
    IF expr.<ZuiExpressionExt>.conversion != Conversion.none
      $generatingArg = TRUE
    }

    # First write the expression to a temporary output, so that we can wrap
    # the conversion around it when needed.
    Output exprOut = NEW(ctx.out.writing)
    Output saveOut = ctx.setOut(exprOut)

    Type type = Generate.genExprChecked(expr, ctx, exprArg)
    $generatingArg = saveGeneratingArg
    ctx.setOut(saveOut)

    RETURN $conversion(expr, type, exprOut, ctx, exprArg)
  }

  FUNC $conversion(Zui.Expression expr, Type type,
                           Output exprOut, SContext ctx, ExprArg exprArg) Type
    # Detect the required conversion again.  It may change when producing a
    # method for multiple subclasses.
    Type typeConverted = Resolve.exprConversion(expr, type, ctx, exprArg)

    # When needed: store the result in a temp variable: (t = expr)
    # For a eLIST "[1, 2, 3]" it's done in $newListInit().
    # For an iobject it's done in Znao().
    bool doClose
    ZuiExpressionExt exprExt = expr
    IF ctx.out.writing && exprExt.tempDecl != NIL
                       && expr.getType() != Zui.ExprType.eLIST
                       && exprExt.conversion != Conversion.object2iobject
      ctx.out.write("(")
      ctx.out.write(exprExt.tempDecl.pName)
      ctx.out.write(" = ")
      doClose = TRUE
    }

    string close = ""
    IF exprArg.destType() != NIL
                              && exprArg.destType().ttype != Type.Enum.unknown
      SWITCH exprExt.conversion
        CASE Conversion.none
          BREAK
        CASE Conversion.int2string
          $setDeclUsed(%int2string)
          ctx.out.write("Zint2string(")
          close = ")"
        CASE Conversion.nat2string
          $setDeclUsed(%nat2string)
          ctx.out.write("Znat2string(")
          close = ")"
        CASE Conversion.float2string
          $setDeclUsed(%float2string)
          ctx.out.write("Zfloat2string(")
          close = ")"
        CASE Conversion.bool2string
          $setDeclUsed(%bool2string)
          ctx.out.write("Zbool2string(")
          close = ")"
        CASE Conversion.status2string
          $setDeclUsed(%status2string)
          ctx.out.write("Zstatus2string(")
          close = ")"
        CASE Conversion.int2varString
          $setDeclUsed(%int2varString)
          ctx.out.write("Zint2varString(")
          close = ")"
        CASE Conversion.bool2varString
          $setDeclUsed(%bool2varString)
          ctx.out.write("Zbool2varString(")
          close = ")"
        CASE Conversion.status2varString
          $setDeclUsed(%status2varString)
          ctx.out.write("Zstatus2varString(")
          close = ")"
        CASE Conversion.string2byteString
          # no-op
          BREAK
        CASE Conversion.string2varString
          $setDeclUsed(%string2varString)
          ctx.out.write("Zstring2varString(")
          close = ")"
        CASE Conversion.varString2string
          ctx.setDeclUsed(%varString2string)
          ctx.out.write("ZvarString2string(")
          close = ")"
        CASE Conversion.varString2varByteString
          # no-op
          BREAK
        CASE Conversion.object2iobject
          ClassType destClass = exprArg.destType().getClassType(ctx)
          IF exprExt.retClass == NIL || destClass == NIL
            ctx.error("Target class unknown", expr)
          ELSE
            string tempName
            IF exprArg.dest != NIL && (exprArg.dest.type.isNoAlloc()
                                          || exprArg.dest.type.isIobject(ctx))
                                   && exprArg.dest.pName != NIL
                                   && !exprArg.dest.isClassMember()
              tempName = exprArg.dest.pName
            ELSEIF exprExt.tempDecl != NIL
              tempName = exprExt.tempDecl.pName
            }
            close = $object2iobject(exprExt.retClass, destClass, tempName,
                                                  expr.getPos(), ctx.out, ctx)
          }
        CASE Conversion.iobject2noalloc
          close = $object2noalloc(exprArg.dest, type, ctx)
        CASE Conversion.iobject2object
          ClassType destClass = exprArg.destType().getClassType(ctx)
          IF exprExt.retClass == NIL || destClass == NIL
            ctx.error("Target class unknown", expr)
          ELSE
            int idx = exprExt.retClass.childIndex(destClass, FALSE)
            IF idx < 0
              ctx.error("Class type mismatch " .. exprExt.retClass.typeName()
                                      .. " to " .. destClass.typeName(), expr)
            }
            $typecast(exprArg.destType(), ctx)
            IF exprExt.retClass.isIobject(ctx)
              ctx.out.write("Znio(" .. idx .. ", ")
            ELSE
              ctx.out.write("Znip(&" .. destClass.pName .. "__T, ")
            }
            ctx.out.write($getPosNumber(expr.getPos(), ctx))
            ctx.out.write(", (")
            close = ")))"
          }
        CASE Conversion.iobject2iobject
          ClassType destClass = exprArg.destType().getClassType(ctx)
          IF type.isIobject(ctx)
            ctx.out.write("ZconvertZioref(")
          ELSE
            ctx.out.write("ZconvertZiopref(")
          }
          close = $convertZorefArgs(exprExt.retClass, destClass,
                                                     TRUE, expr.getPos(), ctx)
        CASE Conversion.iobject2xobject
          ClassType destClass = exprArg.destType().getClassType(ctx)
          ctx.out.write("Ziobj2xobj(")
          close = $convertZorefArgs(exprExt.retClass, destClass,
                                                     FALSE, expr.getPos(), ctx)
        CASE Conversion.iobjectCast
          ClassType destClass = exprArg.destType().getClassType(ctx)
          ctx.out.write("(" .. destClass.pName .. "*)")

        CASE Conversion.callback2method
          ctx.out.write("((Tcb*)")
          close = ")"
          typeConverted = type.getEffType().<CallbackType>.methodType

        CASE Conversion.bool2dyn
        CASE Conversion.status2dyn
        CASE Conversion.int2dyn
        CASE Conversion.int82dyn
        CASE Conversion.int162dyn
        CASE Conversion.int322dyn
        CASE Conversion.nat2dyn
        CASE Conversion.byte2dyn
        CASE Conversion.nat162dyn
        CASE Conversion.nat322dyn
        CASE Conversion.enum2dyn
        CASE Conversion.bits2dyn
          close = $conv2dyn(type, "ZVtoDyn", NIL, expr.getPos(), ctx)

        CASE Conversion.float2dyn
          close = $conv2dyn(type, "ZFtoDyn", NIL, expr.getPos(), ctx)

        CASE Conversion.string2dyn
        CASE Conversion.byteString2dyn
        CASE Conversion.tuple2dyn
        CASE Conversion.type2dyn
        CASE Conversion.object2dyn
        CASE Conversion.array2dyn
        CASE Conversion.list2dyn
        CASE Conversion.dict2dyn
          close = $conv2dyn(type, "ZPtoDyn", NIL, expr.getPos(), ctx)

        CASE Conversion.iobject2dyn
          IF type.isXobject(ctx)
            close = $conv2dyn(type, "ZXobjtoDyn", NIL, expr.getPos(), ctx)
          ELSE
            close = $conv2dyn(type, "ZIobjtoDyn", NIL, expr.getPos(), ctx)
          }

        CASE Conversion.dyn2bool
        CASE Conversion.dyn2status
        CASE Conversion.dyn2int
        CASE Conversion.dyn2int8
        CASE Conversion.dyn2int16
        CASE Conversion.dyn2int32
        CASE Conversion.dyn2nat
        CASE Conversion.dyn2byte
        CASE Conversion.dyn2nat16
        CASE Conversion.dyn2nat32
        CASE Conversion.dyn2enum
          close = $convFromDyn(exprArg.destType(), "ZDynToV", NIL,
                                                           expr.getPos(), ctx)

        CASE Conversion.dyn2float
          close = $convFromDyn(exprArg.destType(), "ZDynToF", NIL,
                                                           expr.getPos(), ctx)

        CASE Conversion.dyn2byteString
        CASE Conversion.dyn2tuple
        CASE Conversion.dyn2type
        CASE Conversion.dyn2object
        CASE Conversion.dyn2array
        CASE Conversion.dyn2list
        CASE Conversion.dyn2dict
          close = $convFromDyn(exprArg.destType(), "ZDynToP", NIL,
                                                           expr.getPos(), ctx)

        CASE Conversion.dyn2string
          $setDeclUsed(%dynToString)
          ctx.out.write("ZdynToString(")
          close = ")"

        CASE Conversion.dyn2iobject
          IF exprArg.destType().isXobject(ctx)
            # TODO: check type properly
            close = $convFromDyn(exprArg.destType(), "ZDynToP", NIL,
                                                           expr.getPos(), ctx)
          ELSE
            ClassType ct = exprArg.destType().getEffType().getClassType(ctx)
            IF ct != NIL
              ctx.out.write("ZaoDyn(")
              close = ", " .. ct.pName .. "__imtt, "
              close ..= "sizeof(" .. ct.pName .. "__imtt) / sizeof(Tc*), (Tt*)&"
              close ..= ct.pName .. "__T, "
              close ..= $getPosNumber(expr.getPos(), ctx) .. ")"
            }
          }

        DEFAULT
          Report.internal("unsupported conversion: \(exprExt.conversion)")
      }
    }

    ctx.out.append(exprOut)
    ctx.out.write(close)

    IF doClose
      # Write the ) of  (temp = expr)
      ctx.out.write(")")
    }

    RETURN typeConverted == NIL ? type : typeConverted
  }

  # Convert a variable of type |fromClass| to a variable of type |toClass|.
  # This is iobject to iobject.
  # Writes the start of the function and returns a string with the rest.  The
  # caller is expected to write the "from" argument and then the returned
  # string.
  FUNC $convertZorefArgs(ClassType fromClass, ClassType toClass,
                         bool addTable, Zui.Position pos, SContext ctx) string
    string close = ""
    IF fromClass == NIL
      # This can happen when there is an error in the expression.
      ctx.error("Target class unknown", pos)
    ELSEIF toClass == NIL
      Report.internal("toClass is NIL", pos)
    ELSE
      # There are two valid situations:
      # 1. destType.getClass() is a parent of fromClass
      #    this always works, add something to the type index
      # 2. destType.getClass() is a child of fromClass
      #    check the type range, subtract something from the type index
      int idx = toClass.childIndex(fromClass, FALSE)
      int maxIdx
      IF idx < 0
        idx = fromClass.childIndex(toClass, FALSE)
        IF idx < 0
          ctx.error("Class type mismatch " .. fromClass.typeName()
                                .. " to " .. toClass.typeName(), pos)
        ELSE
          # 2. destType.getClass() is a child of fromClass
          maxIdx = fromClass.childIndex(toClass, TRUE)
        }
      ELSE
        # 1. destType.getClass() is a parent of fromClass
        idx = -idx
        maxIdx = 99999
      }
      close = ", "
      IF addTable
        close ..= WriteIMT.interfaceMemberTableTableName(toClass) .. ", "
      }
      close ..= idx .. ", " .. (maxIdx - 1)
                                     .. ", " .. $getPosNumber(pos, ctx) .. ")"
    }
    RETURN close
  }

  FUNC $object2iobject(ClassType symClass, ClassType destClass,
                  string destName, Zui.Position pos, Output out, SContext ctx
                      ) string
    # An actual conversion is only needed if the destination is an interface.
    # It is not needed for an actual class, the root class is used then.
    IF !destClass.isIobject(ctx)
      IF destName != NIL
        out.write("(")
        out.write(destName)
        out.write("= (")
        RETURN ")"
      }
      RETURN ""
    }

    # Need to get the pointer and set the type.  The only way to avoid
    # evaluating the expression twice is by using a function.
    IF destName != NIL
      $setDeclUsed(%noAllocObjectRef)
      out.write("*Znao(&")
      out.write(destName)
      out.write(", ")
    ELSE
      $setDeclUsed(%allocObjectRef)
      out.write("Zao(")
    }
    string tableName = Declaration.interfaceMemberTableName(
                                                     symClass, destClass, ctx)
    int idx = destClass.childIndex(symClass, FALSE)
    IF idx < 0
      string destClassName = destClass.typeName()
      IF destClass.ttype != Type.Enum.interface
        destClassName ..= ".I"
      }
      ctx.error("Cannot convert " .. symClass.typeName()
                                              .. " to " .. destClassName, pos)
    }
    RETURN ", " .. tableName .. ", " .. idx .. ")"
  }

  # Assign an object to an iobject that is not allocated.
  # This makes a shallow copy of the object, unless the source is an iobject.
  FUNC $object2noalloc(Declaration dest, Type type, SContext ctx) string
    IF type.isXobject(ctx)
      $setDeclUsed(%noAllocAssign)
      ctx.out.write("Znaa(&")
      ctx.out.write(dest.pName)
      ctx.out.write(", ")
    ELSEIF type.getTtype() == Type.Enum.object
      string pName = type.getClassType(ctx).pName
      ctx.out.write("(*(" .. pName .. " *)&")
      ctx.out.write(dest.pName)
      ctx.out.write(" = *(" .. pName .. " *)")
    ELSE
      ctx.out.write("(")
      ctx.out.write(dest.pName)
      ctx.out.write(" = ")
    }
    RETURN ")"
  }

  FUNC $iobjectType(Zui.Expression lhs, Type type, Type exprType,
                                                             SContext ctx) int
    # Set the type of the i_object.
    # TODO: if this is a different i_object the type will change.
    ctx.out.write("; ")
    Generate.generateVarname(lhs, ctx, NIL)
    ctx.out.write("->type = ")
    int idx = type.getClassType(ctx).childIndex(exprType.getClassType(ctx),
                                                                        FALSE)
    IF idx < 0
      IF ctx.doError()
        ctx.error("Type mismatch, expression result does not match the destination class", lhs)
      }
    }
    ctx.out.write("" .. idx)
    RETURN 0
  }

  # Write lines to "myOuts" to include the generated code for imported
  # files.
  PROC $writeIncludeImport(ZimbuFile import, Scope scope, Output.Group myOuts)
    # Add function for inits to bodies
    $writeInits(import, import.c.outputs)

    # Include the code of the imported file in the current file.
    string pre = "/* including " .. import.rootName
    string done = "/* " .. import.rootName .. " done */\n"

    IF !import.c.outputs.typeOut.empty()
      myOuts.typeOut.write(pre .. " typedefs */\n")
      myOuts.typeOut.append(import.c.outputs.typeOut)
      myOuts.typeOut.write(done)
    }

    IF !import.c.outputs.structOut.empty()
      myOuts.structOut.write(pre .. " structs */\n")
      myOuts.structOut.append(import.c.outputs.structOut)
      myOuts.structOut.write(done)
    }

    IF !import.c.outputs.declOut.empty()
      myOuts.declOut.write(pre .. " declarations */\n")
      myOuts.declOut.append(import.c.outputs.declOut)
      myOuts.declOut.write(done)
    }

    IF !import.c.outputs.bodyOut.empty()
      myOuts.bodyOut.write(pre .. " bodies */\n")
      myOuts.bodyOut.append(import.c.outputs.bodyOut)
      myOuts.bodyOut.write(done)
    }

    IF !(import.c.outputs.earlyInitOut.empty()
                                          && import.c.outputs.initOut.empty())
      # Call the init function.
      myOuts.initOut.write(" done &= " .. import.initFunc .. "(round);\n")
    }
  }

  # Add function for inits to bodies
  PROC $writeInits(ZimbuFile import, Output.Group outputs)
    IF outputs.earlyInitOut.empty() && outputs.initOut.empty()
      RETURN
    }
    outputs.declOut.write("int " .. import.initFunc .. "(int round);\n")

    Output bodyOut = outputs.bodyOut
    bodyOut.write("int " .. import.initFunc .. "(int round) {\n")
    bodyOut.write(" static int round_done = -1;\n")
    bodyOut.write(" int done = 1;\n")

    # Write any temp variables used in init expressions.
    MethodScope ms = import.initScope
    IF ms != NIL && ms.tempVars != NIL
      FOR decl IN ms.tempVars
        bodyOut.write(" ")
        bodyOut.write($vartypeString(decl.type, TRUE, decl.zuiPos, NIL))
        bodyOut.write(decl.pName)
        bodyOut.write(";\n")
      }
    }

    bodyOut.write(" if (round_done < round) {\n")
    IF !Config.noBacktrace || $manageMemory()
      bodyOut.write($stackDeeper("  ", "NULL"))
      bodyOut.write($initStackFrame("  "))
    }
    bodyOut.write("  round_done = round;\n")

    IF !outputs.earlyInitOut.empty()
      bool writeEarlyInitLead = outputs.earlyInitLead != NIL
      IF writeEarlyInitLead
        bodyOut.write(outputs.earlyInitLead)
      }
      bodyOut.append(outputs.earlyInitOut)
      IF writeEarlyInitLead
        bodyOut.write("  }\n")
      }
    }

    IF !outputs.initOut.empty()
      bool writeInitLead = outputs.initLead != NIL
      IF writeInitLead
        bodyOut.write(outputs.initLead)
      }
      bodyOut.append(outputs.initOut)
      IF writeInitLead
        bodyOut.write("  }\n")
      }
    }

    IF !Config.noBacktrace || $manageMemory()
      bodyOut.write("  ")
      bodyOut.write($stackBack())
    }
    bodyOut.write(" }\n")
    bodyOut.write(" return done;\n")
    bodyOut.write("}\n")
  }

  # Write after imports, before inits of the file itself.
  PROC $afterImports(Scope scope, Output.Group outs)
    $commonAfterImports(scope, outs)
  }

  # Write after inits of the file itself.
  PROC $afterGenerate(UsedFile usedFile, Output.Group outs, SContext ctx)
    $commonAfterGenerate(usedFile, outs, ctx)

    # In the main file write the static direct ref structs.
    IF usedFile.zimbuFile.isMainFile
      $writeDirectRefs(outs, ctx)
    }
  }

  # Write the direct referenced function structs.
  PROC $writeDirectRefs(Output.Group outs, SContext ctx)
    bool used
    FOR decl IN directRefs.keys()
      IF $isDeclUsed(decl)
        used = TRUE
        BREAK
      }
    }
    IF used || $isDeclUsed(Declaration.funcRef) || !Generate.skipUnused()
      outs.typeOut.write("typedef struct Tcallback__S Tcb;\n")
      outs.structOut.write("struct Tcallback__S {\n")
      outs.structOut.write($callbackHead())
      outs.structOut.write("};\n")
      IF $manageMemory()
        # Also produce the code in GC marking.
        Declaration.funcRef.setUsed(:c)
        outs.typeOut.write("typedef struct Tcallbackx__S Tcbx;\n")
        outs.structOut.write("struct Tcallbackx__S {\n")
        outs.structOut.write($callbackHead())
        outs.structOut.write(" Tcb *cb;\n")
        outs.structOut.write(" To to[1];\n")  # may be another size
        outs.structOut.write("};\n")
      }

      IF used || !Generate.skipUnused()
        # When creating a callback it's possible a copy of a declaration gets
        # added.  Keep track of the produced functions to avoid duplicates.
        set<string> done = NEW()

        outs.declOut.write("/*** callbacks for methods invoked directly ***/\n")
        FOR decl IN directRefs.keys().sort()
          IF $isDeclUsed(decl)
            MethodType method = decl.type.getMethod()
            bool withObject = method.getClassType(ctx) != NIL
                                                    && method.classType == NIL
            string cfunc = "Zcb" .. (withObject ? "0" : "1") .. decl.pName
            IF !done.has(cfunc)
              done.add(cfunc)
              $writeCallbackFunc(NIL, NIL, withObject, decl, decl.zuiPos, ctx)

              outs.declOut.write("Tcb " .. directRefName(decl.pName) .. " = {"
                  .. ($hasNpField() ? "0, " : "")   # np
                  .. cfunc                          # cfunc
                  .. ", -1};\n")                    # toCount = -1
            }
          }
        }
      }
    }
  }

  # Return the first fields of a callback struct.  This is the same as for a
  # "Tcb", a callback without extra arguments.
  FUNC $callbackHead() string
    string s = $hasNpField() ? linkedDecl : ""
    s ..= " void *cfunc;\n int toCount;\n"
    RETURN s
  }

  FUNC $needWrite(ZimbuFile zimbuFile) bool
    IF zimbuFile.c.startedWrite
      RETURN FALSE
    }
    zimbuFile.c.startedWrite = TRUE
    RETURN TRUE
  }

  PROC $writeClassDef(string name, string comment, Output typeOut)
    typeOut.write("typedef struct " .. name .. "__S " .. name .. "; /* "
        .. comment .. " */\n")
  }

  # Get the head of a object struct.  Has a newline at the end or is empty.
  FUNC $getStructHead() string
    IF $hasNpField()
      RETURN linkedDecl
    }
    RETURN ""
  }

  # Write class declaration. |structOut| has the body.
  PROC $writeClassDecl(ClassType classType, Output.Group outs,
                                               Output structOut, SContext ctx)
    string name = classType.pName
    outs.structOut.write("struct " .. name .. "__S {\n")

    $writeClassDeclHead(classType, outs.structOut, ctx)

    IF !classType.isAbstract()
      outs.structOut.append(structOut)
      outs.structOut.write("};\n")

      # We need a forward declaration.
      outs.structOut.write("extern Tto ")
      outs.structOut.write(name)
      outs.structOut.write("__T;\n")
    }

    WriteIMT.mayWriteNoAllocAssign(classType, ctx)
  }

  PROC $writeClassEnd(SContext ctx)
  }

  PROC $writeClassDeclHead(ClassType classType, Output out, SContext ctx)
    out.write($getStructHead())
    IF classType.hasCountExtends()
      out.write(memberTableDecl)
    }

    IF classType.isAbstract()
      out.write("};\n")
    ELSE
      # If the class has a Finish method, need a flag that is TRUE when Finish
      # returned OK.
      # Since parent classes must have the same struct members, do it for all.
      IF classType.rootClass().hasFinish && $isDeclUsed(Declaration.hasFinish)
        IF !classType.hasCountExtends()
          # Always need an "mt" field when using Finish, even though it's not
          # used, Otherwise the object doesn't match Zohf.
          out.write(memberTableDecl)
        }
        out.write(finishDecl)
      }
    }
  }

  # Write the default init value for |type|.
  PROC $defaultInit(Type type, Output out, SContext ctx)
    Type etype = type.getEffType()
    Type.Enum ttype = etype.getTtype()

    IF etype.isIobject(ctx)
      out.write("{NULL,0,-1}")
    ELSEIF ttype == Type.Enum.dyn
      out.write("{NULL}")
    ELSEIF type.isNoAlloc()
      IF $hasNpField()
        IF type.isXobject(ctx)
                           && type.getClassType(ctx).hasUsedCountChildren(ctx)
          out.write("{{NULL}}")
        ELSE
          out.write("{NULL}")
        }
      ELSE
        out.write("{}")
      }
    ELSE
      SWITCH ttype
        CASE Type.Enum.class
        CASE Type.Enum.iobject
        CASE Type.Enum.string
        CASE Type.Enum.stringval
        CASE Type.Enum.byteString
        CASE Type.Enum.array
        CASE Type.Enum.list
        CASE Type.Enum.dict
          out.write("NULL")
        CASE Type.Enum.multiple
          out.write("{}")
        DEFAULT
          out.write("0")
      }
    }
  }

  PROC $writeBoolVal(string intVal, SContext ctx)
    ctx.out.write(intVal)
  }

  PROC $nil(Declaration dest, SContext ctx)
    Type destType = dest.type
    Output out = ctx.out

    bool hasFinish
    IF destType.isNoAlloc()
      ClassType ct = destType.getClassType(ctx)
      IF ct != NIL
        hasFinish = ct.hasFinishMethod(ctx)
      }
    }

    IF destType.isIobject(ctx)
      IF hasFinish
        out.write("ZnoAllocNilIobj(&")
        out.write(dest.pName)
        out.write(")")
        $setDeclUsed(%noAllocNilIobj)
      ELSE
        out.write("trZero")
      }
    ELSEIF destType.isNoAlloc()
      out.write("ZnoAllocNil(&")
      out.write(dest.pName)
      IF hasFinish
        out.write(", 1)")
      ELSE
        out.write(", 0)")
      }
      $setDeclUsed(%noAllocNil)
    ELSEIF destType.getTtype() == Type.Enum.dyn
      out.write("txZero")
    ELSE
      out.write("NULL")
    }
  }

  PROC $writeNilValue(Type type, Output out, SContext ctx)
    IF type.isValueType()
      out.write("0")
    ELSEIF type.isIobject(ctx)
      out.write("trZero")
    ELSEIF type.getTtype() == Type.Enum.dyn
      out.write("txZero")
    ELSE
      out.write("NULL")
    }
  }

  PROC $writeNilReturn(SContext ctx, Output out)
    out.writeIndent(ctx.scope.depth)
    out.write("return ")
    $writeNilValue(ctx.scope.returnType, out, ctx)
    out.write(";\n")
  }

  # Write the value used for INF.
  PROC $inf(SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("INFINITY")
  }

  # Write the value used for NINF.
  PROC $ninf(SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("-INFINITY")
  }

  # Write the value used for NAN.
  PROC $nan(SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("NAN")
  }

  # Write an expression and wrap it, when needed, for the ?. operator.
  FUNC $wrapExpr(Zui.Expression expr, SContext ctx, Type destType) Type
    RETURN $wrapExprConv(expr, ctx, NEW(destType, FALSE))
  }

  # Write an expression and wrap it, when needed, for the ?. operator.
  FUNC $wrapExprConv(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    Output exprOut = NEW()
    exprOut.writing = ctx.out.writing
    Type ret = Generate.genExprConv(expr, ctx.copy(exprOut), exprArg)
    $wrapExprOutput(exprOut, FALSE, NIL, expr.getPos(), ret, ret, ctx)
    RETURN ret
  }

  # Wrap an expression when needed for the ?. operator when |dotnil| is TRUE.
  # Append |member| when it is not NIL.
  PROC $wrapExprOutput(Output exprOut, bool dotnil, string member,
                   Zui.Position pos, Type objType, Type retType, SContext ctx)
    IF dotnil
      # var?.member ->  ((pname = var) ? pname->member : NULL)
      # TODO: if exprOut is a variable name no temp var is needed.
      string pname = getUid(ctx.scope.scopeName)
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      $vartype(objType, TRUE, pos, ctx.outs.varOut, ctx)
      ctx.outs.varOut.write(pname .. ";\n")

      ctx.out.write("((")
      ctx.out.write(pname)
      ctx.out.write(" = ")
      ctx.out.append(exprOut)
      ctx.out.write(") ? ")
      ctx.out.write(pname)
      IF member != NIL
        ctx.out.write(member)
      }
      ctx.out.write(" : ")
      $writeNilValue(retType, ctx.out, ctx)
      ctx.out.write(")")
    ELSE
      ctx.out.append(exprOut)
      IF member != NIL
        ctx.out.write(member)
      }
    }
  }

  bool $generatingArg

  FUNC $genArg(Zui.Expression arg, SContext ctx, Type destType) Type
    $generatingArg = TRUE
    Type r
    IF destType == NIL
      r = Generate.genExpr(arg, ctx)
    ELSE
      r = Generate.genExpr(arg, ctx, destType)
    }
    $generatingArg = FALSE
    RETURN r
  }

  PROC $writeArgExpr(Zui.Expression arg, SContext ctx, Type destType)
    $generatingArg = TRUE
    Generate.genTopExprDoConv(arg, ctx, destType)
    $generatingArg = FALSE
  }

  PROC $member(Output varnameOut, Zui.Position pos,
           Type objType, Type retType, bool dotnil, string name, SContext ctx)
    string memberAccess = (objType.getTtype() == Type.Enum.iobject
                                                         ? "." : "->") .. name
    $wrapExprOutput(varnameOut, dotnil, memberAccess, pos,
                                                        objType, retType, ctx)
  }

  PROC $toStringFuncCast(SContext ctx)
    ctx.out.write("(Tc * (*)(void*))")
  }

  # Generate an argument for calling ToString on an iobject.
  # This is the index for ToString() in the iobject table.
  PROC $iobjectUseFunc(string what, Zui.Position pos, int &undef, Type type,
                                               Declaration func, SContext ctx)
    # Only used to mark the methods as used.
  }

  FUNC $varsInMethodScope() bool
    RETURN TRUE
  }

  # Write the declaration and init of a variable.
  PROC $declaration(Declaration.C decl,
                    Type valueType,
                    Zui.Statement stmt,
                    bool isShared,
                    Output initExprOut,
                    bool initIsConstant,
                    SContext ctx)
    Scope scope = ctx.scope
    Zui.Declaration zuiDecl = stmt.getDeclaration()

    Output varOut = ctx.outs.varOut      # output for declaring vars
    IF isShared
      # A variable in a SHARED section is written among the declarations.
      varOut = ctx.outs.declOut
    }
    SContext   varCtx = ctx.copy(varOut)

    bool staticVar = scope.scopeName == NIL
                  || scope ISA ModuleScope
                  || scope.scopeType == Scope.Stype.shared
                  || isShared
    bool initWithDecl = staticVar && initIsConstant

    # 1. Write the declaration of the variable at the start of the block.
    #    Only when not written at the start of a method.
    bool didDefaultInit
    IF decl.inMethodScope && !isShared
      # Check if the statement can be encountered twice, e.g. inside a loop.
      Scope s = ctx.scope
      WHILE s != NIL
        IF s.scopeType == Scope.Stype.for
            || s.scopeType == Scope.Stype.while
            || s.scopeType == Scope.Stype.do
            || s.scopeType == Scope.Stype.unknown
          BREAK
        }
        IF s ISA MethodScope
          didDefaultInit = TRUE
          BREAK
        }
        s = s.outer
      }
    ELSE
      didDefaultInit = $writeDeclaration(decl, scope, staticVar,
                                          FALSE, initWithDecl, varOut, varCtx)
    }

    # 2. Write the init or assignment.
    IF scope.isInitVar()
      Output iOut = ctx.out
      bool setPos
      int indent
      IF initWithDecl
        iOut = varOut
      ELSEIF staticVar
        # For global variables and for variables in a module write to the
        # ZglobInit() or I{module}() function.
        # IO.eof is written with an #ifdef.
        # Don't write anything for an abstract class.
        IF decl.scopeName == "MIOModule" && zuiDecl.getName() == "eof"
                  || (scope.classType != NIL && scope.classType.isAbstract())
          iOut = Output.noOut
        ELSEIF (zuiDecl.getType().hasAttr()
                                && zuiDecl.getType().getAttr().getEarlyInit())
                     || ((decl.type.ttype == Type.Enum.object
                            || decl.type.ttype == Type.Enum.iobject)
                         && (decl.type.zuiAttr != NIL
                                        && decl.type.zuiAttr.getEarlyInit()))
          iOut = ctx.outs.earlyInitOut
          setPos = TRUE
        ELSE
          iOut = ctx.outs.initOut
          setPos = TRUE
        }
        indent = 3
      ELSE
        # TODO: Only write the position when the init is not a constant.
        IF initExprOut != NIL && !isShared
          $beforeStatement(zuiDecl.getInit().getPos(), stmt, ctx)
        }
        indent = scope.depth
      }

      IF valueType.isAllocType(ctx)
        didDefaultInit = FALSE     # always init below
        setPos = TRUE              # allocating memory
        stmt.<ZuiStatementExt>.props.allocMem = TRUE
      }

      IF decl.type.isIobject(ctx) && initExprOut == NIL && !didDefaultInit
        # Re-init an iobject, set the pointer to NULL.
        iOut.writeIndent(indent)
        iOut.write(decl.pName)
        iOut.write(".ptr = NULL;\n")
      ELSEIF decl.type.getTtype() == Type.Enum.dyn
                                      && initExprOut == NIL && !didDefaultInit
        # Re-init a dyn, set the type to NULL.
        iOut.writeIndent(indent)
        iOut.write(decl.pName)
        iOut.write(".type = NULL;\n")
      ELSEIF initExprOut != NIL || !didDefaultInit
        # Write the init when not yet done above.
        IF setPos && !initWithDecl
          iOut.writeIndent(indent)
          $writeSetStackPos(zuiDecl.getPos(),
                                           $needPauseGC(stmt), ctx.copy(iOut))
          iOut.write(";\n")
        }

        IF decl.type.isNoAlloc()
          # Init the not allocated object with a function call, it's not
          # assigned to the variable.
          iOut.writeIndent(indent)
        ELSE
          IF !initWithDecl
            iOut.writeIndent(indent)
            iOut.write(decl.pName)
          }
          iOut.write(" = ")
        }

        IF valueType.isAllocType(ctx)
          # This is a variable used in a "USE &" argument, it is a class
          # with the actual variable as a member.  Need to allocate the
          # object.
          $writeAlloc(valueType.getClassType(ctx), NIL, iOut, ctx)
          IF initExprOut != NIL
            iOut.write(";\n")
            iOut.writeIndent(indent)
            iOut.write(decl.pName)
            iOut.write("->Vm = ")
            iOut.append(initExprOut)
          }
        ELSEIF initExprOut == NIL
          # No assignment, default init: NIL, FALSE, zero.
          $defaultInit(valueType, iOut, ctx)
        ELSE
          # Write the code for the expression, generated previously.
          iOut.append(initExprOut)
        }
        IF initWithDecl
          $declComment(scope.scopeName, decl, iOut)
        }
        iOut.write(";\n")
      }

      IF (!scope.hasStatements() || isShared) && $manageMemory()
        # Add static variables to a list.  Ones that may point to allocated
        # memory in $staticVars and ones that point to static memory but may
        # contain pointers to allocated mememory in $noallocVars.
        IF decl.type.isManaged()
          IF $staticVars == NIL
            $staticVars = NEW()
          }
          $staticVars.add(decl)
        ELSE
          int undef
          IF getArgumentType(decl.type, stmt.getPos(), &undef, ctx) >= 300
            IF $noallocVars == NIL
              $noallocVars = NEW()
            }
            $noallocVars.add(decl)
          }
        }
      }
    }
  }

  # Write the declaration of |decl| to |ctx|.out.
  # Return TRUE if the default init was written.
  FUNC $writeDeclaration(Declaration.C decl,
                    Scope scope,
                    bool isGlobal,
                    bool forceInit,
                    bool initWithDeclaration,
                    Output out,
                    SContext ctx) bool
    # Skip javatype and ctype declarations.  They will be marked as used,
    # because GENERATE_IF can't be used at the class level.  But the code
    # using the variables won't be generated.
    Type valueType = decl.type.getValueType(ctx)
    IF valueType.ttype == Type.Enum.javatype
                                        || valueType.ttype == Type.Enum.jstype
      RETURN TRUE
    }

    IF scope.outer != NIL && !isGlobal
      ctx.out.writeIndent(scope.depth)
    }

    IF valueType.isNoAlloc() && valueType.isXobject(ctx)
                      && valueType.getClassType(ctx).hasUsedCountChildren(ctx)
      # When declaring a not-allocated object we need to reserve space for the
      # biggest child.  This requires a special struct and using that.
      $noAllocVarDecl(decl, ctx)
    ELSE
      $vardecl(decl, ctx)
    }

    # If this is a module variable or a class SHARED variable init it to 0 or
    # NIL.
    # Also in a block when there is a goto label and it is a pointer.
    # Also for a global variable that is not allocated, need to mark it as not
    # initialized.
    # Not when writing the init next.
    bool didDefaultInit
    IF !initWithDeclaration
      IF forceInit || (!scope.hasStatements() && scope.isInitVar())
                   || (scope.retLabel != NIL && !valueType.isValueType())
                   || (isGlobal && valueType.isNoAlloc())
        ctx.out.write(" = ")
        $defaultInit(valueType, ctx.out, ctx)
        didDefaultInit = TRUE
      }

      ctx.out.write(";")
      $declComment(scope.scopeName, decl, ctx.out)
      ctx.out.write("\n")
    }
    RETURN didDefaultInit
  }

  PROC $noAllocVarDecl(Declaration.C decl, SContext ctx)
    ClassType classType = decl.type.getClassType(ctx)
    IF classType.noAllocTypeName == NIL
      # Create a struct that is the union of all possible children.  This
      # allows for assigning an object of these types.
      Output out = ctx.outs.declOut
      out.write("typedef union {\n ")

      # Common to all children, so that we can use ".mt".
      out.write("struct {\n")
      $writeClassDeclHead(classType, out, ctx)
      out.write(" };\n ")

      $noAllocVarDeclOne(classType, out, ctx)
      
      string uid = getUid(classType.scope.scopeName)
      out.write("} " .. uid .. ";\n")
      classType.noAllocTypeName = uid
    }

    ctx.out.write(classType.noAllocTypeName)
    ctx.out.write(" ")
    ctx.out.write(decl.pName)
  }

  PROC $noAllocVarDeclOne(ClassType classType, Output out, SContext ctx)
    IF $isDeclUsed(classType) && classType.countClass()
      out.write(classType.pName)
      out.write(" m\(classType.rootIndex);\n ")
    }
    FOR child IN classType.children
      $noAllocVarDeclOne(child, out, ctx)
    }
    FOR child IN classType.implementers
      $noAllocVarDeclOne(child, out, ctx)
    }
  }

  # Write the type of |decl| and its name: "Tc *Vname".
  PROC $vardecl(Declaration.C decl, SContext ctx)
    IF decl.isUsedInTry && ctx.scope.hasStatements()
      # The optimizer may put local variables in a register, which gets messed
      # up if longjmp() goes back to the setjmp().
      ctx.out.write("volatile ")
    }
    $vartype(decl.type, TRUE, decl.zuiPos, ctx)

    # Output variable name.
    ctx.out.write(decl.pName)

    IF decl.scopeName == "MIOModule" && decl.name == "eof"
      # IO.eof is #defined, don't declare it.
      ctx.out.write("__NOT")
    }
  }

  PROC $vartype(Type type, bool useSpace, Zui.Position pos, SContext ctx)
    $vartype(type, useSpace, pos, ctx.out, ctx)
  }

  # Write the type of a variable or return value to |out|.
  # |pos| may be NIL.
  # When |useSpace| is TRUE add a space before the "*" or after the type.
  # Use that for declarations, use FALSE for type casts.
  PROC $vartype(Type type, bool useSpace,
                                   Zui.Position pos, Output out, SContext ctx)
    IF !out.writing
      RETURN
    }
    out.write($vartypeString(type, useSpace, pos, ctx))
  }

  # Note: |ctx| can be NIL
  FUNC $vartypeString(Type type, bool useSpace,
                                        Zui.Position pos, SContext ctx) string
    RETURN $vartypeString(type, useSpace, type?.isNoAlloc(), pos, ctx)
  }


  # Note: |ctx| can be NIL
  FUNC $vartypeString(Type type, bool useSpace, bool notAllocated,
                                        Zui.Position pos, SContext ctx) string
    IF type == NIL || type.ttype == Type.Enum.unknown
      RETURN useSpace ? "void " : "void"
    }

    Type etype = type.getEffType()
    string maybeStar = notAllocated ? (useSpace ? " " : "")
                                                     : (useSpace ? " *" : "*")
    SWITCH etype.getTtype()
      CASE Type.Enum.nilval
          RETURN useSpace ? "void *" : "void*"
      CASE Type.Enum.class
      CASE Type.Enum.classDotC
      CASE Type.Enum.object
      CASE Type.Enum.iobject
          IF ctx != NIL && etype.isAbstract() && ctx.doError()
            ctx.error("Cannot use abstract class " .. etype.name, pos)
          }
          ClassType classType = etype.getClassType(ctx)
          IF classType != NIL
            IF etype.isIobject(ctx)
              # An iobject for an interface.
              RETURN "Tr" .. (useSpace ? " " : "")  # never use a star
            }
            RETURN etype.getClassType(ctx).getClassName() .. maybeStar
          }
          IF ctx != NIL
            Report.internal("no class name for " .. etype.typeToString(), pos)
          }
      CASE Type.Enum.interface
          RETURN "Tr" .. (useSpace ? " " : "")  # never use a star
      CASE Type.Enum.array
          RETURN "Ta" .. maybeStar
      CASE Type.Enum.list
          RETURN "Tl" .. maybeStar
      CASE Type.Enum.dict
          RETURN "Td" .. maybeStar
      CASE Type.Enum.tuple
          RETURN etype.pName .. maybeStar
      CASE Type.Enum.multiple
          RETURN etype.pName .. " "
      CASE Type.Enum.proc
      CASE Type.Enum.func
      CASE Type.Enum.procRef
      CASE Type.Enum.funcRef
          RETURN "Tcb" .. maybeStar
      CASE Type.Enum.callback
          RETURN etype.pName .. maybeStar
      CASE Type.Enum.string
      CASE Type.Enum.stringval
      CASE Type.Enum.byteString
          RETURN "Tc" .. maybeStar
      CASE Type.Enum.varString
      CASE Type.Enum.varByteString
          ctx.setDeclUsed(%varByteStringType)
          RETURN "Ty" .. maybeStar
      CASE Type.Enum.byRef
          RETURN $vartypeString(etype.<ReferenceType>.reference,
                                                 FALSE, pos, ctx) .. maybeStar
      CASE Type.Enum.dyn
          RETURN "Tx" .. (useSpace ? " " : "")  # never use a star
      CASE Type.Enum.type
          RETURN "Tt" .. maybeStar

      CASE Type.Enum.bool
          RETURN useSpace ? "Tb " : "Tb"
      CASE Type.Enum.status
          RETURN useSpace ? "Ts " : "Ts"
      CASE Type.Enum.bits
          RETURN etype.<BitsType>.valueType == Type.Enum.int
                   ? (useSpace ? "Tbb " : "Tbb") : (useSpace ? "Tbs " : "Tbs")
      CASE Type.Enum.bitsValue
          RETURN etype.<BitsValueType>.bitsType.valueType == Type.Enum.int
                   ? (useSpace ? "Tbb " : "Tbb") : (useSpace ? "Tbs " : "Tbs")
      CASE Type.Enum.enum
      CASE Type.Enum.enumValue
          RETURN useSpace ? "Te " : "Te"
      CASE Type.Enum.int
      CASE Type.Enum.intval
          RETURN useSpace ? "Ti " : "Ti"
      CASE Type.Enum.int8
          RETURN useSpace ? "char " : "char"
      CASE Type.Enum.int16
          RETURN useSpace ? "Ti16 " : "Ti16"
      CASE Type.Enum.int32
          RETURN useSpace ? "Ti32 " : "Ti32"
      CASE Type.Enum.nat
      CASE Type.Enum.natval
          RETURN useSpace ? "Tu " : "Tu"
      CASE Type.Enum.byte
          RETURN useSpace ? "Tc " : "Tc"
      CASE Type.Enum.nat16
          RETURN useSpace ? "Tu16 " : "Tu16"
      CASE Type.Enum.nat32
          RETURN useSpace ? "Tu32 " : "Tu32"
      CASE Type.Enum.float
      CASE Type.Enum.floatval
      CASE Type.Enum.float80    # TODO
      CASE Type.Enum.float128   # TODO
          RETURN useSpace ? "Tf " : "Tf"
      CASE Type.Enum.float32
          RETURN useSpace ? "Tf32 " : "Tf32"
      CASE Type.Enum.ctype
          RETURN useSpace ? etype.getCtypeName() .. " " : etype.getCtypeName()
      CASE Type.Enum.javatype
      CASE Type.Enum.jstype
          # TODO: throw error
          RETURN useSpace ? "void * " : "void *"
    }

    IF ctx != NIL && ctx.doError()
      ctx.error("Declaration of unknown type " .. etype.typeName(), pos)
#            LOG.reportStack()
    }
    RETURN useSpace ? "void *" : "void*"
  }

  FUNC $enum(Zui.Declaration zuiDecl, EnumType enumType, SContext ctx) int
    Output out = ctx.outs.declOut
    IF !$isDeclUsed(enumType) || !out.writing
      RETURN 0
    }

    bool useValueName = enumType.isValueNameUsed(ctx)
    string tcName
    IF enumType.usedEnumName != NIL && $isDeclUsed(enumType.usedEnumName)
      tcName = $writeStaticString(enumType.name, ctx)
    }
    out.write("Tt " .. enumType.pName .. "__T = {23, ")
    IF tcName != NIL
      out.write("((Tc*)&")
      out.write(tcName)
      out.write(")")
    ELSE
      out.write("0")
    }
    out.write(", ")
    IF useValueName
      out.write(enumType.getRoot().pName .. "__name")
    ELSE
      out.write("0")
    }
    out.write("};\n")

    IF useValueName && enumType.parent == NIL
      out = ctx.outs.structOut
      out.write("char *" .. enumType.pName .. "[] = {\n")
      out.write(" (char*)" .. enumType.totalMemberCount .. ",\n")
      FOR idx IN 0 UNTIL enumType.totalMemberCount
        Declaration.C item = enumType.getMember(idx)
        out.write(" \"" .. item.name .. "\",\n")
      }
      out.write("};\n")
      out.write("char *" .. enumType.pName .. "__name(Te n) {\n")
      out.write(" return (n < 0 || n >= (Te)(size_t)")
      out.write(enumType.pName)
      out.write("[0]) ? \"INVALID\" : ")
      out.write(enumType.pName)
      out.write("[n + 1];\n")
      out.write("};\n")
    }
    RETURN 0
  }

  FUNC $enumName(EnumValueType type, SContext ctx) string
    $setDeclUsed(%enum2string)
    ctx.out.write("Zenum2string(")
    ctx.out.write(type.enumType.getRoot().pName)
    ctx.out.write(", ")
    RETURN ")"
  }

  FUNC $enumFromString(EnumType type, SContext ctx) string
    $setDeclUsed(%enumFromString)
    ctx.out.write("ZenumFromString(")
    ctx.out.write(type.getRoot().pName)
    ctx.out.write(", ")
    RETURN ")"
  }

  # A bits declaration.
  PROC $bits(Zui.Declaration zuiDecl, BitsType bitsType, SContext ctx)
# TODO: not always needed, only when used in container
#    IF bitsType.usedBitsName != NIL && $isDeclUsed(bitsType.usedBitsName)
      string tcName = $writeStaticString(bitsType.name, ctx)
      Output out = ctx.outs.declOut
      out.write("Tt ")
      out.write(bitsType.pName)
      out.write("__T = {25, ((Tc*)&")
      out.write(tcName)
      out.write("), 0};\n")
#    }
  }

  PROC $intAsByteString(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%intAsByteString)
    ctx.out.write("ZintAsByteString(")
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSE
      genExpr(expr, ctx, Type.anInt)
    }
    ctx.out.write(")")
  }

  PROC $intAsString(Zui.Expression expr, SContext ctx)
    ctx.out.write("ZintAsString(")
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSE
      genExpr(expr, ctx, Type.anInt)
    }
    ctx.out.write(")")
  }

  PROC $stringFormat(Zui.Expression expr, Zui.Expression arg, SContext ctx)
    $setDeclUsed(%stringFormat)
    ctx.out.write("ZStringFormat(")
    genExpr(expr, ctx, Type.aString)
    ctx.out.write(", ")
    genExpr(arg, ctx, Type.aString)
    ctx.out.write(")")
  }

  PROC $intToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    IF format == NIL
      $setDeclUsed(%int2string)
      ctx.out.write("Zint2string(")
    ELSE
      $setDeclUsed(%intFormat)
      ctx.out.write("ZintFormat(")
      genExpr(format, ctx, Type.aString)
      ctx.out.write(", ")
    }
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSEIF type.ttype == Type.Enum.bits
      Type ret = genExpr(expr, ctx)
      IF ret.getTtype() != Type.Enum.bitsValue && ctx.doError()
        ctx.error("Expected bits value", expr)
      }
    ELSE
      genExpr(expr, ctx, type)
    }
    ctx.out.write(")")
  }

  PROC $natToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    IF format == NIL
      $setDeclUsed(%nat2string)
      ctx.out.write("Znat2string(")
    ELSE
      $setDeclUsed(%natFormat)
      ctx.out.write("ZnatFormat(")
      genExpr(format, ctx, Type.aString)
      ctx.out.write(", ")
    }
    IF expr.getType() == Zui.ExprType.eNAT
      nat n = expr.getNumber()  # remove the sign bit
      ctx.out.write(n .. "")
    ELSE
      genExpr(expr, ctx, type)
    }
    ctx.out.write(")")
  }

  PROC $floatSize(Zui.Expression expr, Type type, SContext ctx)
    SWITCH type.ttype
      CASE Type.Enum.float
        ctx.out.write("8")
      CASE Type.Enum.float32
        ctx.out.write("4")
      CASE Type.Enum.float80
        ctx.out.write("10")  # TODO: figure out padding
      CASE Type.Enum.float128
        ctx.out.write("16")
      DEFAULT
        LOG.internal("float Size() type not recognized: \(type.typeName())")
    }
  }

  PROC $floatToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    IF format == NIL
      $setDeclUsed(%float2string)
      ctx.out.write("Zfloat2string(")
    ELSE
      $setDeclUsed(%floatFormat)
      ctx.out.write("ZfloatFormat(")
      genExpr(format, ctx, Type.aString)
      ctx.out.write(", ")
    }
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSE
      genExpr(expr, ctx, type)
    }
    ctx.out.write(")")
  }

  # float.isNan()
  PROC $isNan(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("isnan(")
    genExpr(expr, ctx, Type.aFloat)
    ctx.out.write(")")
  }

  # float.isInfinite()
  PROC $isInfinite(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("isinf(")
    genExpr(expr, ctx, Type.aFloat)
    ctx.out.write(")")
  }

  # Float function.
  PROC $floatMethod(string name, Zui.Expression expr, Zui.Expression arg,
                                                                 SContext ctx)
    $setDeclUsed(%math)
    SWITCH name
      CASE "abs"; ctx.out.write("fabs")
      CASE "toInt"; ctx.out.write("Zfloat2int"); $setDeclUsed(%float2int)
      DEFAULT; ctx.out.write(name)
    }
    ctx.out.write("(")
    genExpr(expr, ctx, Type.aFloat)
    IF arg != NIL
    ctx.out.write(", ")
      $genArg(arg, ctx, Type.aFloat)
    }
    ctx.out.write(")")
  }

  # Function for int.Type()
  PROC $callType(Type type, SContext ctx)
    SWITCH type.getTtype()
      CASE Type.Enum.int
        ctx.out.write("&int__T")
      CASE Type.Enum.int8
        ctx.out.write("&int8__T")
      CASE Type.Enum.int16
        ctx.out.write("&int16__T")
      CASE Type.Enum.int32
        ctx.out.write("&int32__T")
      CASE Type.Enum.nat
        ctx.out.write("&nat__T")
      CASE Type.Enum.byte
        ctx.out.write("&byte__T")
      CASE Type.Enum.nat16
        ctx.out.write("&nat16__T")
      CASE Type.Enum.nat32
        ctx.out.write("&nat32__T")
      CASE Type.Enum.float
        ctx.out.write("&float__T")
      CASE Type.Enum.float32
        ctx.out.write("&float32__T")
      CASE Type.Enum.float80
        ctx.out.write("&float80__T")
      CASE Type.Enum.float128
        ctx.out.write("&float128__T")
      CASE Type.Enum.bool
        ctx.out.write("&bool__T")
      CASE Type.Enum.status
        ctx.out.write("&status__T")
      CASE Type.Enum.string
      CASE Type.Enum.stringval
        ctx.out.write("&string__T")
      CASE Type.Enum.byteString
        ctx.out.write("&byteString__T")
      CASE Type.Enum.type
        ctx.out.write("&type__T")
      DEFAULT
        IF ctx.out.writing
          Report.internal(type.typeName() .. ".Type() not implemented yet")
        }
    }
  }

  # Function for enum.Type()
  PROC $callEnumType(EnumType type, Zui.Position pos, SContext ctx)
    ctx.out.write("&")
    ctx.out.write(type.pName)
    ctx.out.write("__T")
  }

  # Function for bits.Type()
  PROC $callBitsType(BitsType type, Zui.Position pos, SContext ctx)
    ctx.out.write("&")
    ctx.out.write(type.pName)
    ctx.out.write("__T")
  }

  # Function for tuple<>.Type()
  PROC $callTupleType(TupleType type, Zui.Position pos, SContext ctx)
    ctx.out.write("(Tt*)&")
    ctx.out.write(type.pName)
    ctx.out.write("__T")
  }

  # Function for dyn.Type()
  PROC $callDynType(Zui.Expression expr, SContext ctx)
    ctx.out.write("(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(").type")
  }

  # Function for dyn.ToString()
  PROC $callDynToString(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%dynToString)
    ctx.out.write("ZdynToString(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(")")
  }

  # Function for dyn.Size()
  PROC $callDynSize(Zui.Expression expr, SContext ctx)
    ctx.out.write("ZdynSize(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(")")
  }

  # Function for type.Size()
  PROC $callTypeSize(Type type, SContext ctx)
    ctx.out.write("sizeof(Tt)")
  }

  # Function for Module.Type()
  PROC $callModuleType(ModuleType mt, Zui.Position pos, SContext ctx)
    ctx.out.write("&")
    ctx.out.write(mt.name)
    ctx.out.write("__T")
  }

  # Function for Class.Type()
  PROC $callClassType(ClassType ct, Zui.Position pos, SContext ctx)
    ctx.out.write("(Tt*)&")
    ctx.out.write(ct.pName)
    ctx.out.write("__T")
  }

  # Function to turn a bool into a string.
  PROC $boolToString(Zui.Expression expr, list<Zui.Expression> args,
                                                                 SContext ctx)
    ctx.out.write("Zstr((")
    $genArg(expr, ctx, Type.aBool)
    IF args.Size() == 1
      IF args[0].getType() == Zui.ExprType.eSTRING
        IF args[0].getStringValue() == "1b"
          ctx.out.write(") ? \"1\" : \"0\")")
        ELSEIF args[0].getStringValue() == "b"
          ctx.out.write(") ? \"TRUE\" : \"FALSE\")")
        ELSEIF ctx.doError()
          ctx.error("format must be \"b\" or \"1b\"", args[0])
        }
      ELSE
        $setDeclUsed(%cstring)
        ctx.out.write(") ? (strcmp((char*)ZcString(")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write("), \"1b\") == 0 ? \"1\" : \"TRUE\") : (strcmp((char*)ZcString(")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write("), \"1b\") == 0 ? \"0\" : \"FALSE\"))")
      }
    ELSE
      ctx.out.write(") ? \"TRUE\" : \"FALSE\")")
    }
  }

  # Function to turn a status into a string.
  PROC $statusToString(Zui.Expression expr, list<Zui.Expression> args,
                                                                 SContext ctx)
    ctx.out.write("Zstr((")
    $genArg(expr, ctx, Type.aStatus)
    IF args.Size() == 1
      IF args[0].getType() == Zui.ExprType.eSTRING
        IF args[0].getStringValue() == "1t"
          ctx.out.write(") ? \"1\" : \"0\")")
        ELSEIF args[0].getStringValue() == "t"
          ctx.out.write(") ? \"OK\" : \"FAIL\")")
        ELSEIF ctx.doError()
          ctx.error("format must be \"t\" or \"1t\"", args[0])
        }
      ELSE
        $setDeclUsed(%cstring)
        ctx.out.write(") ? (strcmp((char*)ZcString(")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write("), \"1t\") == 0 ? \"1\" : \"OK\") : (strcmp((char*)ZcString(")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write("), \"1t\") == 0 ? \"0\" : \"FAIL\"))")
      }
    ELSE
      ctx.out.write(") ? \"OK\" : \"FAIL\")")
    }
  }

  # Function to return the size of an int or nat.
  PROC $intSize(Type type, SContext ctx)
    SWITCH type.getTtype()
      CASE Type.Enum.intval
      CASE Type.Enum.int
          ctx.out.write("sizeof(Ti)")
      CASE Type.Enum.natval
      CASE Type.Enum.nat
          ctx.out.write("sizeof(Tu)")

      CASE Type.Enum.int8; ctx.out.write("sizeof(char)")
      CASE Type.Enum.int16; ctx.out.write("sizeof(Ti16)")
      CASE Type.Enum.int32; ctx.out.write("sizeof(Ti32)")

      CASE Type.Enum.byte; ctx.out.write("sizeof(Tc)")
      CASE Type.Enum.nat16; ctx.out.write("sizeof(Tu16)")
      CASE Type.Enum.nat32; ctx.out.write("sizeof(Tu32)")
      DEFAULT
        LOG.internal("intSize() type not recognized: \(type.typeName())")
    }
  }

  # Function to return the size of a bool.
  PROC $boolSize(SContext ctx)
    # Although we use "int", when stored in an array a bool only uses one
    # byte.
    ctx.out.write("1")
  }

  # Function to return the size of a status.
  PROC $statusSize(SContext ctx)
    # Although we use "int", when stored in an array a status only uses one
    # byte.
    ctx.out.write("1")
  }

  # Function to check if a number is a digit character.
  PROC $isDigit(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("isdigit(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is a hex digit character.
  PROC $isHexDigit(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("isxdigit(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is an alphabetic character.
  PROC $isAlpha(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("isalpha(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is a lower case character.
  PROC $isLower(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("islower(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is an upper case character.
  PROC $isUpper(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("isupper(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to turn a number into a lower case character.
  PROC $intToLowerAscii(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    # TODO: only ASCII
    ctx.out.write("tolower(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to turn a number into an upper case character.
  PROC $intToUpperAscii(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    # TODO: only ASCII
    ctx.out.write("toupper(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function make a number positive.
  PROC $intAbs(Zui.Expression expr, SContext ctx)
    # First find out what the type would be without conversion.
    Type t = $genArg(expr, ctx.copyNoOut(), NIL)
    IF t.isNatType()
      # Avoid a compiler warning for applying llabs() to an unsigned number.
      $genArg(expr, ctx, NIL)
    ELSE
      ctx.out.write("(Tu)llabs(")
      $genArg(expr, ctx, Type.anInt)
      ctx.out.write(")")
    }
  }

  PROC $writeCompare(Zui.Expression var_expr, list<Zui.Expression> args,
                                                      Type type, SContext ctx)
    IF type.ttype == Type.Enum.int
      || type.ttype == Type.Enum.bool
      || type.ttype == Type.Enum.status
      $setDeclUsed(%intCompare)
      ctx.out.write("ZintCompare(")
    ELSEIF type.ttype == Type.Enum.nat
      $setDeclUsed(%natCompare)
      ctx.out.write("ZnatCompare(")
    ELSEIF type.ttype == Type.Enum.float
      $setDeclUsed(%floatCompare)
      ctx.out.write("ZfloatCompare(")
    ELSEIF type.ttype == Type.Enum.dyn
      $setDeclUsed(Declaration.dynCompare)
      ctx.out.write("ZdynCompare(")
    ELSEIF type.ttype == Type.Enum.type
      $setDeclUsed(%typeCompare)
      ctx.out.write("ZtypeCompare(")
    }
    $genArg(var_expr, ctx, type)
    ctx.out.write(", ")
    $genArg(args[0], ctx, type)
    ctx.out.write(")")
  }

  PROC $writeEqual(Zui.Expression var_expr, list<Zui.Expression> args,
                                                      Type type, SContext ctx)
    string middle = " == "
    IF type.ttype == Type.Enum.dyn
      $setDeclUsed(Declaration.dynEqual)
      ctx.out.write("ZdynEqual")
      middle = ", "
    }
    ctx.out.write("(")
    $genArg(var_expr, ctx, type)
    ctx.out.write(middle)
    $genArg(args[0], ctx, type)
    ctx.out.write(")")
  }

  PROC $stringToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    string name
    IF radix == 10
      name = "ZstringToInt"
    ELSEIF radix == 2
      name = "ZstringBinToInt"
    ELSE
      name = "ZstringHexToInt"
    }
    ctx.out.write(name .. "(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(", ")
    int flags = 0
    IF args.Size() == 0
      flags += 1
    }
    IF dotnil
      flags += 2
    }
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      $genArg(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $varStringToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    string name
    IF radix == 10
      name = "ZvarStringToInt"
    ELSEIF radix == 2
      name = "ZvarStringBinToInt"
    ELSE
      name = "ZvarStringHexToInt"
    }
    ctx.out.write(name .. "(")
    $genArg(expr, ctx, Type.aVarString)
    int flags = 0
    IF args.Size() == 0
      flags += 1
    }
    IF dotnil
      flags += 2
    }
    ctx.out.write(", ")
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      $genArg(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $stringQuotedToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    string name
    IF radix == 10
      name = "ZstringQuotedToInt"
    ELSEIF radix == 2
      name = "ZstringQuotedBinToInt"
    ELSE
      name = "ZstringQuotedHexToInt"
    }
    ctx.out.write(name .. "(")
    $genArg(expr, ctx, Type.aString)
    int flags
    IF args.Size() == 0
      flags = 1
    }
    IF dotnil
      flags += 2
    }
    ctx.out.write(", ")
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      $genArg(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $varStringQuotedToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    string name
    IF radix == 10
      name = "ZvarStringQuotedToInt"
    ELSEIF radix == 2
      name = "ZvarStringQuotedBinToInt"
    ELSE
      name = "ZvarStringQuotedHexToInt"
    }
    ctx.out.write(name .. "(")
    $genArg(expr, ctx, Type.aVarString)
    int flags
    IF args.Size() == 0
      flags = 1
    }
    IF dotnil
      flags += 2
    }
    ctx.out.write(", ")
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      $genArg(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $stringToFloat(Zui.Position pos, Zui.Expression expr, bool dotnil,
                      list<Zui.Expression> args, SContext ctx)
    $setDeclUsed(%stringToFloat)
    ctx.out.write("Zstring2float(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(", ")
    IF args.Size() == 0
      ctx.out.write("0")
    ELSE
      $genArg(args[0], ctx, Type.anIntRef)
    }
    ctx.out.write(")")
  }

  PROC $stringCaseCommon(string name, Zui.Expression expr,
                                                      SContext ctx, Type type)
    ctx.out.write(name)
    ctx.out.write("(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $stringToLowerAscii(Zui.Expression expr, SContext ctx, Type type)
    $stringCaseCommon("ZstringToLowerAscii", expr, ctx, type)
  }

  PROC $stringToUpperAscii(Zui.Expression expr, SContext ctx, Type type)
    $stringCaseCommon("ZstringToUpperAscii", expr, ctx, type)
  }

  PROC $stringToLower(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%stringToLower)
    $stringCaseCommon("ZstringToLower", expr, ctx, type)
  }

  PROC $stringToUpper(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%stringToUpper)
    $stringCaseCommon("ZstringToUpper", expr, ctx, type)
  }

  PROC $varStringToLowerAscii(Zui.Expression expr, SContext ctx, Type type)
    $stringCaseCommon("ZvarStringToLowerAscii", expr, ctx, type)
  }

  PROC $varStringToUpperAscii(Zui.Expression expr, SContext ctx, Type type)
    $stringCaseCommon("ZvarStringToUpperAscii", expr, ctx, type)
  }

  PROC $varStringToLower(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%varStringToLower)
    $stringCaseCommon("ZvarStringToLower", expr, ctx, type)
  }

  PROC $varStringToUpper(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%varStringToUpper)
    $stringCaseCommon("ZvarStringToUpper", expr, ctx, type)
  }

  PROC $stringFindCharF(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx,
                                                 string funcname, Type dest)
    string name = "Z" .. dest.ttype.ToString() .. funcname
    IF args.Size() == 2
      ctx.out.write(name .. "2(")
      $genArg(var_expr, ctx, dest)
      ctx.out.write(", ")
      $genArg(args[0], ctx, Type.anInt)
      ctx.out.write(", ")
      $genArg(args[1], ctx, Type.anInt)
    ELSE                                      # s.find(int c)
      ctx.out.write(name .. "(")
      $genArg(var_expr, ctx, dest)
      ctx.out.write(", ")
      $genArg(args[0], ctx, Type.anInt)
    }
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $stringFindChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindChar", Type.aString)
  }

  PROC $varStringFindChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindChar", Type.aVarString)
  }

  PROC $byteStringGetByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.out.write("ZbyteStringGetByte(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $byteStringGetChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.out.write("ZbyteStringGetChar(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $byteStringGetCharSize(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.out.write("ZbyteStringGetCharSize(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $byteStringFindByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindByte", Type.aByteString)
  }

  PROC $varByteStringFindByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindByte",
                                                          Type.aVarByteString)
  }

  PROC $stringFindLastChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindLastChar", Type.aString)
  }

  PROC $varStringFindLastChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindLastChar", Type.aVarString)
  }

  PROC $byteStringFindLastByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindLastByte", Type.aByteString)
  }

  PROC $varByteStringFindLastByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindLastByte",
                                                          Type.aVarByteString)
  }

  PROC $stringSameArgF(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx,
                                              string funcname, Type dest)
    string name = "Z" .. dest.ttype.ToString() .. funcname
    IF name == "ZbyteStringStartsWith"
      name = "ZstringStartsWith"  # works exactly the same way
    ELSEIF name == "ZbyteStringEndsWith"
      name = "ZstringEndsWith"  # works exactly the same way
    ELSEIF name == "ZvarByteStringStartsWith"
      name = "ZvarStringStartsWith"  # works exactly the same way
    ELSEIF name == "ZvarByteStringEndsWith"
      name = "ZvarStringEndsWith"  # works exactly the same way
    ELSEIF name == "ZbyteStringCompare"
      name = "ZstringCompare"  # works exactly the same way
    ELSEIF name == "ZbyteStringEqual"
      name = "ZstringEqual"  # works exactly the same way
    }
    IF args.Size() == 2
      name ..= "2"
    }
    ctx.out.write(name .. "(")
    $genArg(var_expr, ctx, dest)
    ctx.out.write(", ")
    $genArg(args[0], ctx, dest)
    IF args.Size() == 2
      ctx.out.write(", ")
      $genArg(args[1], ctx, Type.anInt)
    }
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $stringCompare(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Compare", Type.aString)
  }

  PROC $stringEqual(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Equal", Type.aString)
  }

  PROC $byteStringCompare(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Compare", Type.aByteString)
  }

  PROC $byteStringEqual(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Equal", Type.aByteString)
  }

  PROC $stringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Find", Type.aString)
  }

  PROC $stringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "FindLast", Type.aString)
  }

  PROC $varStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Find", Type.aVarString)
  }

  PROC $varStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "FindLast", Type.aVarString)
  }

  PROC $byteStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Find", Type.aByteString)
  }

  PROC $byteStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "FindLast", Type.aByteString)
  }

  PROC $varByteStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Find", Type.aVarByteString)
  }

  PROC $varByteStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "FindLast", Type.aVarByteString)
  }

  PROC $stringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "StartsWith", Type.aString)
  }

  PROC $stringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "EndsWith", Type.aString)
  }

  PROC $varStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "StartsWith", Type.aVarString)
  }

  PROC $varStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "EndsWith", Type.aVarString)
  }

  PROC $byteStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "StartsWith", Type.aByteString)
  }

  PROC $byteStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "EndsWith", Type.aByteString)
  }

  PROC $varByteStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "StartsWith", Type.aVarByteString)
  }

  PROC $varByteStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "EndsWith", Type.aVarByteString)
  }

  PROC $stringSliceWrap(Zui.Expression var_expr, bool dotnil,
                               Zui.MethodCall call, SContext ctx, Type dest)
    ctx.out.write("Z" .. dest.ttype.ToString() .. "SliceWrap(")
    $genArg(var_expr, ctx, dest)
    ctx.out.write(", ")
    Generate.generateSliceArgs(call, dotnil, ctx)
    ctx.out.write(")")
  }

  PROC $stringSliceWrap(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSliceWrap(var_expr, dotnil, call, ctx, Type.aString)
  }

  PROC $varStringSliceWrap(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSliceWrap(var_expr, dotnil, call, ctx, Type.aVarString)
  }

  PROC $byteStringSliceWrap(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSliceWrap(var_expr, dotnil, call, ctx, Type.aByteString)
  }

  PROC $varByteStringSliceWrap(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSliceWrap(var_expr, dotnil, call, ctx, Type.aVarByteString)
  }

  PROC $varAdd(Zui.Expression var_expr, list<Zui.Expression> args, SContext ctx,
                                               Type valtype, Type vartype)
    # Check the type of the argument.
    Type type = genExpr(args[0], ctx.copyNoOut(), valtype)
    IF type == NIL
      type = genExpr(args[0], ctx.copyNoOut())
    }
    IF type != NIL
      IF type.ttype == valtype.ttype || type.ttype == Type.Enum.stringval
        ctx.out.write("ZvarStringAddVal(")
        $genArg(var_expr, ctx, vartype)
        ctx.out.write(", ")
        $genArg(args[0], ctx, valtype)
        ctx.out.write(")")
      ELSE
        ctx.error("Sorry, ZvarStringAddBytes not implemented yet", var_expr)
        $setDeclUsed(%varStringAddBytes)
        ctx.out.write("ZvarStringAddBytes(")
        $genArg(var_expr, ctx, vartype)
        ctx.out.write(", ")
        $genArg(args[0], ctx, vartype)
        ctx.out.write(")")
      }
    }
  }

  PROC $varStringAdd(Zui.Expression var_expr,
                                      list<Zui.Expression> args, SContext ctx)
    $varAdd(var_expr, args, ctx, Type.aString, Type.aVarString)
  }

  PROC $varByteStringAdd(Zui.Expression var_expr,
                                      list<Zui.Expression> args, SContext ctx)
    $varAdd(var_expr, args, ctx, Type.aByteString, Type.aVarByteString)
  }

  PROC $split(Zui.Expression var_expr, bool dotnil,
          list<Zui.Expression> args, SContext ctx, Type vartype, Type argtype)
    string name = "Z" .. vartype.ttype.ToString() .. "Split"
    ctx.out.write(name .. "(")
    $genArg(var_expr, ctx, vartype)
    ctx.out.write(", ")
    $genArg(args[0], ctx, argtype)
    ctx.out.write(")")
  }

  PROC $stringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $split(var_expr, dotnil, args, ctx, Type.aString, Type.aString)
  }

  PROC $varStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $split(var_expr, dotnil, args, ctx, Type.aVarString, Type.aString)
  }

  PROC $byteStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $split(var_expr, dotnil, args, ctx, Type.aByteString, Type.aByteString)
  }

  PROC $varByteStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $split(var_expr, dotnil, args, ctx, Type.aVarByteString, Type.aByteString)
  }

  PROC $stringSize(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%stringSize)
    ctx.out.write("ZstringSize(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varStringSize(Zui.Expression expr, SContext ctx, Type type)
    ctx.out.write("ZvarStringSize(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $byteStringSize(Zui.Expression expr, SContext ctx, Type type)
    ctx.out.write("ZbyteStringSize(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varByteStringSize(Zui.Expression expr, SContext ctx, Type type)
    ctx.out.write("ZvarByteStringSize(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  # Get the hash value of a byteString or string.
  PROC $byteStringHash(Zui.Expression expr, SContext ctx, Type type)
    ctx.out.write("ZbyteStringHash(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  # Get the hash value of a varByteString or varString.
  PROC $varByteStringHash(Zui.Expression expr, SContext ctx, Type type)
    IF ctx.doError()
      ctx.error("hash not yet implemented for varByteString", expr)
    }
    ctx.out.write("ZvarByteStringHash(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $string2byteString(Zui.Expression expr, SContext ctx, Type type)
    genExpr(expr, ctx, type)
  }

  PROC $string2varString(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%string2varString)
    ctx.out.write("Zstring2varString(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $byteString2string(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%byteStringCheckUtf8)
    ctx.out.write("ZbyteStringCheckUtf8(")
    $genArg(expr, ctx, Type.aByteString)
    ctx.out.write(")")
  }

  PROC $byteString2varString(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%byteStringCheckUtf8)
    $setDeclUsed(%string2varString)
    ctx.out.write("Zstring2varString(ZbyteStringCheckUtf8(")
    $genArg(expr, ctx, Type.aByteString)
    ctx.out.write("))")
  }

  PROC $varString2string(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%varString2string)
    ctx.out.write("ZvarString2string(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varString2varByteString(Zui.Expression expr, SContext ctx)
    genExpr(expr, ctx, Type.aVarString)
  }

  PROC $varByteString2string(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%varByteStringCheckUtf8)
    ctx.setDeclUsed(%varString2string)
    ctx.out.write("ZvarString2string(ZvarByteStringCheckUtf8(")
    $genArg(expr, ctx, Type.aVarByteString)
    ctx.out.write("))")
  }

  PROC $varByteString2varString(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%varByteStringCheckUtf8)
    ctx.out.write("ZvarByteStringCheckUtf8(")
    $genArg(expr, ctx, Type.aVarByteString)
    ctx.out.write(")")
  }

  # Turn a string into an array.
  PROC $stringToArray(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%stringToArray)
    ctx.out.write("ZStringToArray(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(")")
  }

  # Turn a byteString into an array.
  PROC $byteStringToArray(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%byteStringToArray)
    ctx.out.write("ZByteStringToArray(")
    $genArg(expr, ctx, Type.aByteString)
    ctx.out.write(")")
  }

  # Generate a switch() and return the type of the expression.
  FUNC $switch(Zui.Expression expr, Zui.CodeBlock block, SContext ctx) Type
    ctx.out.writeIndent(ctx.scope.depth)
    Type.Enum ttype = expr.<ZuiExpressionExt>.resultType?.getTtype()
    IF ttype == Type.Enum.type || ttype == Type.Enum.string
      IF block != NIL
        string name = block.<ZuiCodeBlockExt>.scope.<SwitchScope>.varName
        IF ttype == Type.Enum.type
          ctx.outs.varOut.write(" Tt *")
        ELSE
          ctx.outs.varOut.write(" Tc *")
        }
        ctx.outs.varOut.write(name)
        ctx.outs.varOut.write(";\n")

        ctx.out.write(name)
        ctx.out.write(" = ")
      }
    ELSE
      ctx.out.write("switch (")
    }
    Type switchType = genExpr(expr, ctx)
    IF ttype == Type.Enum.type || ttype == Type.Enum.string
      ctx.out.write(";\n")
    ELSE
      ctx.out.write(")\n")
    }
    RETURN switchType
  }

  FUNC $caseString(Zui.Expression expr, bool isMatch,
                                        bool caseFollows, SContext ctx) string
    Output out = ctx.out
    IF !out.writing
      RETURN ""
    }

    SwitchScope scope = ctx.scope
    Type.Enum ttype = scope.switchType?.getTtype()
    Type destType = scope.switchType
    string close = ""
    IF scope.useIf
      IF scope.wroteCase
        out.write(" || ")
      ELSE
        out.writeIndent(ctx.scope.depth)
        out.write("if (")
        scope.wroteCase = TRUE
        IF scope.didProceed
          out.write(scope.varName)
          out.write(" == (void *)Zproceed || ")
        }
      }
      IF ttype == Type.Enum.string
        IF isMatch
          out.write(DeclStore.getPName("MREModule__CRegex", "Mmatches"))
          out.write("(")
          IF Type.isRegex(expr.<ZuiExpressionExt>.resultType, ctx)
            destType = Type.regexType.getValueType(ctx)
            close = ", \(scope.varName))"
          ELSE
            out.write(DeclStore.getPName("MREModule__CRegex", "MNEW"))
            out.write("(NULL, ")
            close = "), \(scope.varName))"
          }
        ELSE
          ctx.setDeclUsed(Declaration.stringEqual)
          out.write("ZstringEqual(")
          out.write(scope.varName)
          out.write(", ")
          close = ", 1)"
        }
      ELSE
        out.write(scope.varName)
        out.write(" == ")
      }
    ELSE
      out.writeIndent(ctx.scope.depth)
      out.write("case ")
      close = ":\n"
    }

    # First write the output to caseOut, so that we can check for
    # duplicate values and add a type cast when needed.
    Output caseOut = NEW()
    caseOut.writing = TRUE
    genExpr(expr, ctx.copy(caseOut), destType)
    out.append(caseOut)

    out.write(close)
    IF scope.useIf && !caseFollows
      out.write(")\n")
    }
    RETURN caseOut.ToString()
  }

  PROC $caseEnd(Zui.Position pos, SContext ctx)
    # Jump to label at end of switch.
    $jumpToReturn(pos, ctx)
  }

  PROC $writeProceed(Zui.Statement stmt, SContext ctx)
    IF stmt.getType() == Zui.StatementType.eCASE
      # We enter the next block by setting the switch variable equal to the
      # special "proceed" value.
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write(ctx.scope.<SwitchScope>.varName)
      ctx.out.write(" = (void *)Zproceed;\n")
    }
  }

  PROC $default(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth - 1)
    SwitchScope scope = ctx.scope
    Type.Enum ttype = scope.switchType?.getTtype()
    IF !scope.useIf
      ctx.out.write("default:\n")
    }
  }

  PROC $switchEnd(SContext ctx)
  }

  # Return TRUE when memory is managed.
  FUNC $manageMemory() bool
    RETURN ManageMemory.manageMemory(THIS)
  }

  # Return TRUE when every object struct has the "np" field.
  # That is when memory is managed, Finish() is used or DEFER is used.
  FUNC $hasNpField() bool
    RETURN $manageMemory()
        || $isDeclUsed(Declaration.hasFinish)
        || $isDeclUsed(Declaration.defer)
  }

  PROC $writeTtype(string name, Zui.Position pos, SContext ctx)
    string s = typeStructs.get(name, NIL)
    IF s == NIL
      ctx.error("Unsupported type: " .. name, pos)
    ELSE
      ctx.out.write("&" .. s)
    }
  }

  # Return the name of the struct defining type |type|.
  # Similar to getArgumentType().
  # TODO: how about typedef?
  FUNC $getDynType(Type type, Zui.Position pos, SContext ctx) string
    # Argument for item type
    SWITCH type.getTtype()
      # Value types
      CASE Type.Enum.int
      CASE Type.Enum.natval
      CASE Type.Enum.intval
        RETURN "&int__T"
      CASE Type.Enum.int8
        RETURN "&int8__T"
      CASE Type.Enum.int16
        RETURN "&int16__T"
      CASE Type.Enum.int32
        RETURN "&int32__T"
      CASE Type.Enum.nat
        RETURN "&nat__T"
      CASE Type.Enum.byte
        RETURN "&byte__T"
      CASE Type.Enum.nat16
        RETURN "&nat16__T"
      CASE Type.Enum.nat32
        RETURN "&nat32__T"
      CASE Type.Enum.bool
        RETURN "&bool__T"
      CASE Type.Enum.status
        RETURN "&status__T"
      CASE Type.Enum.enumValue
        RETURN "&" .. type.<EnumValueType>.enumType.pName .. "__T"
      CASE Type.Enum.bitsValue
        RETURN "&" .. type.<BitsValueType>.bitsType.pName .. "__T"

      CASE Type.Enum.float
      CASE Type.Enum.floatval
        RETURN "&float__T"
      CASE Type.Enum.float32
        RETURN "&float32__T"
      CASE Type.Enum.float80
        RETURN "&float80__T"
      CASE Type.Enum.float128
        RETURN "&float128__T"

      # Reference types
      CASE Type.Enum.string
      CASE Type.Enum.stringval
        RETURN "&string__T"
      CASE Type.Enum.byteString
        RETURN "&byteString__T"
      CASE Type.Enum.varString
        RETURN "&varString__T"
      CASE Type.Enum.varByteString
        RETURN "&varByteString__T"
      CASE Type.Enum.tuple
        RETURN "(Tt*)&" .. type.getEffType().pName .. "__T"
      CASE Type.Enum.iobject
        IF type.isIobject(ctx)
          RETURN "&iobj__T"
        }
        RETURN "(Tt*)&" .. type.getClassType(ctx).pName .. "__T"
      CASE Type.Enum.object
# TODO: not needed?
#        string name = type.getClassType(ctx).name
#        IF name == "thread"
#          RETURN "&thread__T"
#        }
        RETURN "(Tt*)&" .. type.getClassType(ctx).pName .. "__T"

      CASE Type.Enum.array
      CASE Type.Enum.list
      CASE Type.Enum.dict
        RETURN "&" .. type.getEffType().<ContainerType>.typeUsed(ctx).pName
                                                                      .. "__T"
#        CASE Type.Enum.procRef
#        CASE Type.Enum.funcRef
#          RETURN "TODO"
      CASE Type.Enum.dyn
        RETURN "&dyn__T"
      CASE Type.Enum.type
        RETURN "&type__T"
    }
    IF ctx.doError()
      ctx.error("Unsupported item type for dyn: "
                                           .. type.getTtype().ToString(), pos)
    }
    RETURN -1
  }

  FUNC $conv2dyn(Type type, string name, string arg,
                                        Zui.Position pos, SContext ctx) string
    ctx.out.write(name)
    ctx.out.write("(")
    string close = ", " .. $getDynType(type, pos, ctx)
    IF arg != NIL
      close ..= ", " .. arg
    }
    RETURN close .. ")"
  }

  FUNC $convFromDyn(Type type, string name, string arg,
                                        Zui.Position pos, SContext ctx) string
    ctx.out.write(name)
    ctx.out.write("(")
    string close = ", " .. $getDynType(type, pos, ctx)
    IF arg != NIL
      close ..= ", " .. arg
    }
    RETURN close .. ", " .. $getPosNumber(pos, ctx) .. ")"
  }

  PROC $forBlockStart(ForLoopInfo info, SContext ctx)
    # When looping over an iterator, check that the object is not NIL.
    # Need to get the iterator first.
    bool hasIterator
    FOR i IN 0 UNTIL info.iters.Size()
      ForLoopInfo.Iter iter = info.iters[i]
      IF iter.iteratorType != NIL
        hasIterator = TRUE

        # When calling obj.Iterator() evaluate "obj" and assign it to a temp
        # variable.
        # When not calling obj.Iterator(), evaluate the expression now to be
        # able to check if the result is NIL.
        # Use $Iterator() or $KeyIterator() of the class.
        Type iterType = iter.varDecl.type
        Zui.Expression expr = info.forStmt.getIter(i)
        ClassType class = iterType.getClassType(ctx)
        IF class == NIL
          ctx.error("Missing Iterator class", expr)
          RETURN
        }
        IF class.templateTypes == NIL
          ctx.error("Missing I.Iterator template type", expr)
          RETURN
        }

        ctx.out.writeIndent(ctx.scope.depth)
        IF !iter.varDecl.inMethodScope
          $vartype(iter.iteratorType, TRUE, expr.getPos(), ctx)
        ELSEIF iter.iteratorMethod != NIL
          IF !info.extraBlock
            # Need an extra block to put the declaration in.
            info.extraBlock = TRUE
            ctx.out.write("{\n")
            ctx.out.writeIndent(ctx.scope.depth)
          }
          ctx.out.write("void *")
        }
        ctx.out.write(iter.varDecl.pName)
        IF iter.iteratorMethod != NIL
          ctx.out.write("v")
        }
        ctx.out.write(" = ")
        $genArg(expr, ctx, NIL)
        ctx.out.write(";\n")
      }
    }

    IF hasIterator
      # "FOR x IN obj": do nothing if obj is NIL.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("if (")
      bool didOne
      FOR i IN 0 UNTIL info.iters.Size()
        ForLoopInfo.Iter iter = info.iters[i]
        IF iter.iteratorType != NIL
          IF didOne
            ctx.out.write(" && ")
          }
          didOne = TRUE
          ctx.out.write(iter.varDecl.pName)
          IF iter.iteratorMethod != NIL
            ctx.out.write("v")
          ELSE
            ctx.out.write(".ptr")
          }
          ctx.out.write(" != NULL")
        }
      }
      ctx.out.write(")\n")
    }

    $startBlock(ctx)
  }

  FUNC $forStart(ForLoopInfo info,
                      Type toType, Type untilType, Type stepType, SContext ctx
                ) list<Type>
    Output declOut = NEW()
    declOut.writing = ctx.out.writing
    SContext declCtx = ctx.copy(declOut)
    Output stmtOut = NEW()
    stmtOut.writing = ctx.out.writing
    SContext stmtCtx = ctx.copy(stmtOut)
    Zui.ForStatement stmt = info.forStmt
    list<Type> itemTypes

    FOR i IN 0 UNTIL info.iters.Size()
      ForLoopInfo.Iter iter = info.iters[i]
      Type iterType = iter.varDecl.type
      Zui.Expression expr = stmt.getIter(i)
      Type itemType

      Output vout
      SContext vctx
      IF iter.varDecl.inMethodScope
        vout = stmtOut
        vctx = stmtCtx
      ELSE
        vout = declOut
        vctx = declCtx
      }

      IF iter.iteratorType != NIL
        ClassType class = iterType.getClassType(ctx)

        # Use $Iterator() or $KeyIterator() of the class.
        # Calling obj.Iterator() here.
        IF iter.iteratorMethod != NIL
          # Use $Iterator() or $KeyIterator() of the class.
          IF class == NIL
            # Error given previously
            RETURN [Type.anInt]
          }
          IF class.templateTypes == NIL
            # Error given previously
            RETURN [Type.anInt]
          }

          ctx.out.writeIndent(ctx.scope.depth + 1)
          IF !iter.varDecl.inMethodScope
            $vartype(iter.iteratorType, TRUE, expr.getPos(), ctx)
          }
          ctx.out.write(iter.varDecl.pName)
          ctx.out.write(" = ")
          ctx.out.write(iter.iteratorMethod.pName)
          ctx.out.write("(")
          ctx.out.write(iter.varDecl.pName .. "v")
          ctx.out.write(");\n")
        }

        # I.KeyIterator<int, string> returns int + string..
        IF class.templateTypes.Size() > 1
          IF info.iters.Size() > 1
            ctx.error("Cannot use KeyIterator here", expr)
            RETURN [Type.anInt]
          }
          itemTypes = NEW()
          FOR decl IN class.templateTypes
            itemTypes.add(decl.type)
          }
        ELSE
          # I.Iterator<int> returns int.
          itemType = class.templateTypes[0].type
        }
      ELSE
        Type.Enum ttype = iterType.getTtype()
        SWITCH ttype
          CASE Type.Enum.array
          CASE Type.Enum.list
          CASE Type.Enum.dict
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write(ttype == Type.Enum.array ? "Tfa "
                                  : ttype == Type.Enum.list ? "Tfl " : "Tfd ")
            declOut.write(iter.varDecl.pName)
            declOut.write("i;\n")

            vout.writeIndent(ctx.scope.depth + 1)
            IF !iter.varDecl.inMethodScope
              vout.write(ttype == Type.Enum.array ? "Ta *" :
                                    ttype == Type.Enum.list ? "Tl *" : "Td *")
            }
            vout.write(iter.varDecl.pName .. " = ")
            $genArg(expr, vctx, NIL)
            vout.write(";\n")

            # The array/list/dict itself is also stored in a separate
            # variable, so that it's referenced in the method scope if needed.
            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(ttype == Type.Enum.array ? "i.a = " :
                                ttype == Type.Enum.list ? "i.l = " : "i.d = ")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(";\n")

            # When key/item type is NIL must be an empty array/list/dict, use
            # int.
            ContainerType ct = iterType.getEffType()
            itemType = ct.itemType ?: Type.anInt
            IF info.forStmt.sizeLoopVar() > 1 && info.iters.Size() == 1
              IF ttype == Type.Enum.dict
                itemTypes = [ct.keyType ?: Type.anInt, itemType]
              ELSE
                itemTypes = [Type.anInt, itemType]
              }
              itemType = NIL
            }

          CASE Type.Enum.string
          CASE Type.Enum.stringval
            ctx.setDeclUsed(%forStringStruct)
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write("Tfs i" .. iter.varDecl.pName .. ";\n")

            vout.writeIndent(ctx.scope.depth + 1)
            IF !iter.varDecl.inMethodScope
              vout.write("Tc *")
            }
            vout.write(iter.varDecl.pName .. " = ")
            $genArg(expr, vctx, Type.aString)
            vout.write(";\n")

            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write("ZforStringNew(")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(", &i")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(");\n")

            itemType = Type.anInt

          CASE Type.Enum.byteString
            ctx.setDeclUsed(%forStringStruct)
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write("Tfs i" .. iter.varDecl.pName .. ";\n")

            vout.writeIndent(ctx.scope.depth + 1)
            IF !iter.varDecl.inMethodScope
              vout.write("Tc *")
            }
            vout.write(iter.varDecl.pName .. " = ")
            $genArg(expr, vctx, Type.aByteString)
            vout.write(";\n")

            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write("ZforBytestringNew(")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(", &i")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(");\n")

            itemType = Type.anInt

          CASE Type.Enum.int
          CASE Type.Enum.int8
          CASE Type.Enum.int16
          CASE Type.Enum.int32
          CASE Type.Enum.nat
          CASE Type.Enum.byte
          CASE Type.Enum.nat16
          CASE Type.Enum.nat32
          CASE Type.Enum.natval
          CASE Type.Enum.intval
            IF toType == NIL && untilType == NIL
              ctx.error("Not supported: FOR on "
                                           .. iterType.ttype.ToString(), expr)
              RETURN NIL
            }
            ctx.setDeclUsed(%forRange)
            IF !simpleForLoop(stmt, ctx)
              declOut.writeIndent(ctx.scope.depth + 1)
              declOut.write("Tfr " .. iter.varDecl.pName .. ";\n")

              stmtOut.writeIndent(ctx.scope.depth + 1)
              stmtOut.write("ZforRangeNew(")
              $genArg(expr, stmtCtx, Type.anInt)
              stmtOut.write(", ")
              IF toType != NIL
                $genArg(stmt.getTo(), stmtCtx, Type.anInt)
                stmtOut.write(", 0, ")
              ELSE
                $genArg(stmt.getUntil(), stmtCtx, Type.anInt)
                stmtOut.write(", 1, ")
              }
              IF stmt.hasStep()
                $genArg(stmt.getStep(), stmtCtx, Type.anInt)
              ELSE
                stmtOut.write("1")
              }
              stmtOut.write(", &" .. iter.varDecl.pName)
              stmtOut.write(");\n")
            }
            itemType = Type.anInt

          CASE Type.Enum.enum
          CASE Type.Enum.enumValue
            ctx.setDeclUsed(%forEnum)

            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write("Tfe " .. iter.varDecl.pName .. ";\n")

            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(".count = ")
            EnumType et = iterType.<EnumType>
            IF et.members == NIL
              stmtOut.write(0 .. "")
            ELSE
              stmtOut.write(et.members.Size() .. "")
            }
            stmtOut.write(";\n")

            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(".idx = 0;\n")

            IF iterType ISA EnumType
              itemType = iterType.<EnumType>.getEnumValue()
            ELSE
              itemType = iterType
            }

          CASE Type.Enum.object
          CASE Type.Enum.iobject
            ctx.error("No iterator found for "
                                     .. iterType.getClassType(ctx).name, expr)

          DEFAULT
            ctx.error("Not supported: FOR on "
                                           .. iterType.ttype.ToString(), expr)
        }
      }

      IF itemType != NIL
        IF itemTypes == NIL
          itemTypes = NEW()
        }
        itemTypes.add(itemType)
      }
    }

    ctx.out.append(declOut)
    ctx.out.append(stmtOut)
    RETURN itemTypes
  }

  PROC $forLoop(ForLoopInfo info, list<Declaration> varList, SContext ctx)
    Output out = ctx.out
    IF !out.writing
      RETURN
    }
    Output declOut = NEW(TRUE)
    Output startOut = NEW(TRUE)
    Output contOut = NEW(TRUE)
    Output incOut = NEW(TRUE)
    Zui.ForStatement for = info.forStmt

    FOR idx IN 0 UNTIL info.iters.Size()
      ForLoopInfo.Iter iter = info.iters[idx]
      IF idx > 0
        contOut.write(" && ")
      }

      IF iter.iteratorType != NIL
        # it.hasNext() && (Vi = it.next(), 1)
        SContext contCtx = ctx.copy(contOut)
        $forLoopIteratorWhile(info, varList, idx,
              { name, i => name .. ".a" .. i }, contCtx)
        CONTINUE
      }

      string type = ""
      Declaration.C varDecl = varList[idx]
      string loopVarName = varDecl.pName
      string iterVarName = iter.varDecl.pName

      ENUM LoopType
        noIdx
        simple
        array
        list
        dict
      }
      LoopType loopType

      bool usingKey = varList.Size() > info.iters.Size()

      SWITCH iter.varDecl.type.ttype
        CASE Type.Enum.array
          loopType = LoopType.array
          type = "Array"
          ctx.setDeclUsed(%forArray)

        CASE Type.Enum.list
          loopType = LoopType.list
          type = "List"

          # FOR over a list is used a lot, do some work at compile time to
          # avoid work at runtime.
          ContainerType ct = iter.varDecl.type.getEffType()
          Type itemType = ct.itemType ?: Type.anInt
          Declaration noKey
          Declaration withKey
          IF itemType.isIobject(ctx)
            type ..= "Iobj"
            noKey = %forListIobj
            withKey = %forListIobjKey
          ELSEIF itemType.ttype == Type.Enum.dyn
            type ..= "Dyn"
            noKey = %forListDyn
            withKey = %forListDynKey
          ELSEIF itemType.ttype == Type.Enum.enumValue
            type ..= "Enum"
            noKey = %forListEnum
            withKey = %forListEnumKey
          ELSEIF itemType.isFloatType()
            type ..= "Float"
            noKey = %forListFloat
            withKey = %forListFloatKey
          ELSEIF itemType.isValueType()
            type ..= "Int"
            noKey = %forListInt
            withKey = %forListIntKey
          ELSE
            type ..= "Ptr"
            noKey = %forListPtr
            withKey = %forListPtrKey
          }
          IF usingKey
            type ..= "Key"
            ctx.setDeclUsed(withKey)
          ELSE
            ctx.setDeclUsed(noKey)
          }
          ctx.setDeclUsed(%forList)

        CASE Type.Enum.dict
          loopType = LoopType.dict
          type = "Dict"
          ctx.setDeclUsed(%forDict)

        CASE Type.Enum.string
        CASE Type.Enum.stringval
          type = "String"
          iterVarName = "&i" .. iterVarName

        CASE Type.Enum.byteString
          type = "Bytestring"
          iterVarName = "&i" .. iterVarName

        CASE Type.Enum.enum
        CASE Type.Enum.enumValue
          type = "Enum"
          iterVarName = "&" .. iterVarName

        CASE Type.Enum.int
        CASE Type.Enum.int8
        CASE Type.Enum.int16
        CASE Type.Enum.int32
        CASE Type.Enum.nat
        CASE Type.Enum.byte
        CASE Type.Enum.nat16
        CASE Type.Enum.nat32
        CASE Type.Enum.natval
        CASE Type.Enum.intval
          IF simpleForLoop(for, ctx)
            loopType = LoopType.simple
          ELSE
            type = "Range"
            iterVarName = "&" .. iterVarName
          }
      }

      SWITCH loopType
        CASE LoopType.simple
            IF !startOut.empty()
              startOut.write(", ")
            }
            startOut.write(loopVarName .. " = ")
            SContext startCtx = ctx.copy(startOut)
            genExpr(for.getIter(0), startCtx, Type.anInt)
            bool isContextFree = TRUE
            contOut.write(loopVarName)
            IF !for.hasStep() || ExprEval.evalInt(for.getStep(), ctx,
                                                     TRUE, &isContextFree) > 0
              contOut.write(" <= ")
            ELSE
              contOut.write(" >= ")
            }
            SContext contCtx = ctx.copy(contOut)
            genExpr(for.getTo(), contCtx, Type.anInt)
            IF !incOut.empty()
              incOut.write(", ")
            }
            IF !for.hasStep()
              incOut.write("++" .. loopVarName)
            ELSE
              incOut.write(loopVarName .. " += ")
              SContext incCtx = ctx.copy(contOut)
              genExpr(for.getStep(), incCtx, Type.anInt)
            }

        CASE LoopType.noIdx
          string typeName
          string cast
          IF varDecl.type.isValueType()
            IF varDecl.type.ttype == Type.Enum.enumValue
              typeName = "Enum"
            ELSEIF varDecl.type.isFloatType()
              typeName = "Float"
            ELSE
              typeName = "Int"
            }
            IF varDecl.type.isNatType()
              cast = "(Ti*)"
            ELSE
              cast = ""
            }
          ELSE
            typeName = "Ptr"
            cast = "(Tc **)"
          }
          IF !startOut.empty()
            startOut.write(", ")
          }
          startOut.write("Zfor" .. type .. "Get" .. typeName
                         .. "(" .. iterVarName .. ", "
                         .. cast .. "&" .. loopVarName .. ")")
          contOut.write("Zfor" .. type .. "Cont" .. typeName
                                                 .. "(" .. iterVarName .. ")")
          IF !incOut.empty()
            incOut.write(", ")
          }
          incOut.write("Zfor" .. type .. "Next" .. typeName .. "("
                 .. iterVarName .. ", " .. cast ..  "&" .. loopVarName .. ")")

        CASE LoopType.array
        CASE LoopType.list
        CASE LoopType.dict
          int valIdx = idx
          IF usingKey || loopType != LoopType.list
            # For a list without using the key "keyp" is not used.
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write(iter.varDecl.pName)
            declOut.write("i.keyp = ")
            IF usingKey
              declOut.write("(void*)&")
              declOut.write(loopVarName)
              declOut.write(";\n")
              valIdx = 1
            ELSE
              declOut.write("NULL;\n")
            }
          }

          declOut.writeIndent(ctx.scope.depth + 1)
          declOut.write(iter.varDecl.pName)
          declOut.write("i.valp = (void*)&")
          declOut.write(varList[valIdx].pName)
          declOut.write(";\n")

          IF loopType != LoopType.dict
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write(iter.varDecl.pName)
            declOut.write("i.i = 0;\n")
          }

          IF loopType == LoopType.dict
            IF !startOut.empty()
              startOut.write(", ")
            }
            startOut.write("ZforDictStart(&" .. iter.varDecl.pName .. "i)")
          }
          contOut.write("Zfor" .. type .. "Cont(&"
                                                .. iter.varDecl.pName .. "i)")
          IF loopType == LoopType.dict
            IF !incOut.empty()
              incOut.write(", ")
            }
            incOut.write("ZforDictNext(&" .. iter.varDecl.pName .. "i)")
          }
      }
    }

    out.append(declOut)
    out.writeIndent(ctx.scope.depth + 1)
    out.write("for (")
    out.append(startOut)
    out.write("; ")
    out.append(contOut)
    out.write("; ")
    out.append(incOut)
    out.write(") {\n")
  }

  PROC $forEnd(ForLoopInfo info, Zui.Statement stmt, SContext ctx)
    IF $isDeclUsed(%pthread) && $manageMemory()
                       && $isDeclUsed(Declaration.gcRun) && $doStackFrame(ctx)
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write("if (e->wantGC) ZthreadGC();\n")
    }
    # Write the position of the FOR, that's what happens next.
    ctx.out.write(" ")  # one extra level of indent
    $beforeStatement(stmt, ctx)

    IF info.extraBlock
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("}\n")
    }
  }

  # A BREAK statement that jumps to a FINALLY.
  PROC $writeBreakGotoFinally(Scope s, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("did_goto_finally = " .. scopeBreak)
    IF ctx.scope.scopeType == Scope.Stype.try
      # In the TRY scope, jump to FINALLY directly.
      ctx.out.write("; goto " .. s.<TryScope>.finallyLabelName)
    ELSE
      # Inside a scope in the TRY scope, jump to end of scope first.
      IF ctx.scope.retLabel == NIL
        ctx.scope.retLabel = getUid(ctx.scope.scopeName)
      }
      ctx.out.write("; goto " .. ctx.scope.retLabel)
    }
    $statementLineEnd(ctx.out)
  }

  # A BREAK statement that finishes a loop.
  PROC $writeBreak(Zui.Position pos, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("rt = " .. scopeBreak)
    # The jump to retLabel is not needed, this is always the end of the block.
    ctx.out.write(";\n")
  }

  # A CONTINUE statement that jumps to a FINALLY.
  PROC $writeContinueGotoFinally(Scope s, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("did_goto_finally = " .. scopeContinue)
    IF ctx.scope.scopeType == Scope.Stype.try
      # In the TRY scope, jump to FINALLY directly.
      ctx.out.write("; goto " .. s.<TryScope>.finallyLabelName)
    ELSE
      # Inside a scope in the TRY scope, the jump to retLabel is not needed,
      # this is always the end of the block.
    }
    $statementLineEnd(ctx.out)
  }

  # A CONTINUE statement that finishes a loop.
  PROC $writeContinue(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("rt = " .. scopeContinue)
    # The jump to retLabel is not needed, this is always the end of the block.
    ctx.out.write(";\n")
  }

  # UNITL of a DO block.
  FUNC $until(Zui.Condition cond, SContext ctx) int
    RETURN until(cond, ctx)
  }

  # Write the start of a type cast to |type| and return what needs to be
  # written to close it (usually a ")").
  FUNC $typecast(Type type, SContext ctx) string
    RETURN $ptrTypecast(type, FALSE, ctx)
  }

  FUNC $ptrTypecast(Type type, bool ptr, SContext ctx) string
    string tail = ptr ? " **)" : " *)"
    Type rtype = type
    IF rtype.ttype == Type.Enum.byRef
      rtype = rtype.<ReferenceType>.reference
      tail = ptr ? " ***)" : " **)"
    }
    IF (rtype.ttype == Type.Enum.object || rtype.isXobject(ctx))
           && rtype.getClassType(ctx) != NIL
      rtype = rtype.getClassType(ctx)
    }
    IF rtype.ttype == Type.Enum.class
      ctx.out.write("((" .. rtype.pName .. tail)
      RETURN ")"
    }
    IF rtype.isIobject(ctx)
      ctx.out.write("((Tr" .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.array
      ctx.out.write("((Ta" .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.list
      ctx.out.write("((Tl" .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.string
       || rtype.ttype == Type.Enum.byteString
       || rtype.ttype == Type.Enum.stringval
      ctx.out.write("((Tc" .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.varString
       || rtype.ttype == Type.Enum.varByteString
      ctx.setDeclUsed(%varByteStringType)
      ctx.out.write("((Ty" .. tail)
      RETURN ")"
    }
    RETURN ""
  }

  PROC $throw(Zui.Statement stmt, bool hasNextStmt, Type type, SContext ctx)
    Output out = ctx.out
    IF !out.writing
      RETURN
    }

    # Need to evaluate the expression before writeScopeEnd().
    IF !ctx.scope.hasEvar
      ctx.scope.hasEvar = TRUE
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      ctx.outs.varOut.write(exceptionPname())
      ctx.outs.varOut.write(" *ex;\n")
    }
    out.writeIndent(ctx.scope.depth)
    out.write("ex = ")
    bool throwString = type != NIL && (type.ttype == Type.Enum.string
                                         || type.ttype == Type.Enum.stringval)

    Type exprType
    IF throwString
      out.write("ZstringEx(")
      out.write($getPosNumber(stmt.getPos(), ctx))
      out.write(", ")
      exprType = type
    ELSE
      exprType = type.getClassType(ctx).rootClass().getValueType(ctx)
    }
    Generate.genExprDoConv(stmt.getExpr(), ctx, exprType)
    IF throwString
      out.write(")")
    }
    out.write(";\n")

    # Other scopes may jump here.
    IF ctx.scope.retLabel != NIL
      ctx.out.write(ctx.scope.retLabel)
      ctx.out.write(":\n")
    }

    # When jumped here from a RETURN don't throw the exception.
    int indent = ctx.scope.depth
    IF ctx.scope.needRetFlag
      out.writeIndent(ctx.scope.depth)
      out.write("if (!rt) {\n")
      ++indent
    }

    out.writeIndent(indent)
    out.write("ZthrowIobject(ex);\n")

    IF ctx.scope.needRetFlag
      out.writeIndent(ctx.scope.depth)
      out.write("}\n")

      # Leaving the scope.  Not needed when throwing an exception,
      # ZthrowObject() will do the dereferencing.
      $writeScopeEnd(FALSE, FALSE, NIL, stmt.getPos(), ctx)
    }

    # A THROW at the end of a function won't be followed by a RETURN, but we
    # need a "return" to avoid a compiler warning.
    IF !hasNextStmt && ctx.scope ISA MethodScope
      IF ctx.scope.needRetFlag
        $writeBeforeReturn(stmt.getPos(), ctx)
      }
      IF ctx.scope.returnType != NIL
        IF ctx.scope.needRetFlag
          out.writeIndent(ctx.scope.depth)
          out.write("return r;\n")
        ELSE
          $writeNilReturn(ctx, out)
        }
      }
    }
  }

  # Return the code to write to get the environment pointer.
  # When not using threads there is only one: Zenv;
  # When using threads call a function to get the per-thread environment.
  FUNC $getEnvCode() string
    IF $isDeclUsed(%pthread)
      RETURN "ZgetEnv()"
    }
    RETURN "(&Zenv)"
  }

  PROC $try_block(Zui.Statement stmt, SContext ctx)
    Output out = ctx.out
    out.writeIndent(ctx.scope.depth)
    out.write("volatile int caught = 0;\n")
    out.writeIndent(ctx.scope.depth)
    out.write("Tn *te = " .. $getEnvCode() .. ";\n")
    out.writeIndent(ctx.scope.depth)
    out.write("int try_index = te->tryCtxUsed;\n")
    out.writeIndent(ctx.scope.depth)
    out.write("volatile int did_jump = 0;\n")

    $beforeStatement(stmt.getPos(), TRUE, ctx)
    out.writeIndent(ctx.scope.depth)
    out.write("ZtryDeeper(te, ")
    IF $doStackFrame(ctx)
      out.write("&sf")
    ELSE
      out.write($topFrameName())
    }
    out.write(");\n")

    Zui.TryStatement tryStmt = stmt.getTry()
    TryScope tryScope = tryStmt.<ZuiTryStatementExt>.scope
    IF tryStmt.hasFinally() && (tryScope.foundReturn
                             || tryScope.foundBreak || tryScope.foundContinue)
      out.writeIndent(ctx.scope.depth)
      out.write("int did_goto_finally = 0;\n")
    }
    out.writeIndent(ctx.scope.depth)
    out.write("if (setjmp(te->tryCtx[try_index].jmpBuf) != 0) {\n")
    out.writeIndent(ctx.scope.depth + 1)
    out.write("++did_jump;\n")
    IF $doStackFrame(ctx)
      out.writeIndent(ctx.scope.depth + 1)
      out.write($topFrameName())
      out.write(" = &sf;\n")
    }
    out.writeIndent(ctx.scope.depth)
    out.write("}\n")
    out.writeIndent(ctx.scope.depth)
    out.write("if (did_jump == 0) /* TRY */\n")
  }

  PROC $try_block_end(Zui.Statement stmt, SContext ctx)
    IF !stmt.getTry().hasFinally()
      # no FINALLY, don't catch exceptions with this TRY
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("te->tryCtxUsed = try_index;\n")
    }
  }

  # Generate what comes before a list of CATCH parts.
  PROC $try_catch_start(SContext ctx)
  }

  PROC $try_catch(Zui.Catch catch, bool first,
                                            list<Type> typeList, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("if (did_jump == 1 && !caught && (")
    bool didOne
    FOR type IN typeList
      IF didOne
        ctx.out.write(" || ")
      }
      $writeIsa(NIL, FALSE, type, catch.getPos(), ctx)
      didOne = TRUE
    }
    ctx.out.write(")) { /* CATCH */\n")
  }

  # Generate what comes after a list of CATCH parts.
  PROC $try_catch_end(SContext ctx)
  }

  # Generate after a TRY without a CATCH.
  PROC $try_no_catch(SContext ctx)
  }

  PROC $topException(Declaration.C destDecl, Zui.Position pos,
                                              SContext ctx, SContext blockCtx)
    ctx.out.write("te->thrown[--te->thrownUsed]")
    IF destDecl.type.ttype == Type.Enum.iobject
                                    || destDecl.type.ttype == Type.Enum.object
    ELSE
      ctx.error("Unexpected symbol type: " .. destDecl.ToString(), pos)
    }
  }

  PROC $discardTopException(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth + 1)
    ctx.out.write("--te->thrownUsed;\n")
  }

  PROC $try_else(Zui.Statement stmt, SContext ctx)
    IF !stmt.getTry().hasFinally()
      # There is FINALLY, no longer let an exception be caught by this TRY.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("te->tryCtxUsed = try_index;\n")
    }
    # Exceptions thrown here are like in a CATCH block.
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("did_jump = 1; caught = 1; /* ELSE */\n")
  }

  PROC $try_finally(Zui.Statement stmt, SContext ctx)
    Zui.TryStatement tryStmt = stmt.getTry()
    TryScope tryScope = tryStmt.<ZuiTryStatementExt>.scope
    IF tryScope.foundReturn || tryScope.foundBreak || tryScope.foundContinue
      ctx.out.write(tryScope.finallyLabelName .. ":\n")
    }

    # No longer let an exception be caught by this TRY
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("te->tryCtxUsed = try_index; /* FINALLY */\n")
  }

  PROC $try_end(Zui.Statement stmt, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    # Rethrow when an exception brought us back here and it wasn't caught or
    # when a catch of finally block threw an exception.
    ctx.out.write("if ((did_jump == 1 && !caught) || did_jump > 1) Zrethrow();\n")

    Zui.TryStatement tryStmt = stmt.getTry()
    TryScope tryScope = tryStmt.<ZuiTryStatementExt>.scope

    # This is only needed if there is a FINALLY.
    IF tryStmt.hasFinally()
           && (tryScope.foundReturn
            || tryScope.foundBreak
            || tryScope.foundContinue)
      # handle a RETURN before the FINALLY
      # handle a BREAK before the FINALLY
      # handle a CONTINUE before the FINALLY
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("if (did_goto_finally != 0) {\n")
      ++ctx.scope.depth
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("rt = did_goto_finally;\n")
      ctx.out.writeIndent(ctx.scope.depth)
      $writeJumpToLabel(ctx)
      ctx.out.write("\n")
      --ctx.scope.depth
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("}\n")
    }
  }

  PROC $ifnilExpr(SContext ctx)
    ctx.out.write("if (")
    IF ctx.scope.isClassScope() && ctx.scope.getThisName() != NIL
      ctx.out.write(ctx.scope.getThisName())
    ELSE
      ctx.out.write("Athis")
    }
    ctx.out.write(" == NULL)\n")
  }

  # What comes after the IFNIL statement.
  PROC $belowIfnil(SContext ctx)
  }

  # Return TRUE if the garbage collector may run.
  FUNC $mayCallDoGC() bool
    RETURN $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
  }

  # Return the code to write at the start of a function to add a backtrace
  # frame.
  FUNC $stackDeeper(string indent, string frof) string
    IO.StringWriter w = NEW()
    IF $isDeclUsed(%pthread)
      w.write(indent)
      w.write("Tn *e = ZgetEnv();\n")
    }
    w.write(indent)
    w.write("Zsf sf={")
    IF $mayCallDoGC() || ManageMemory.isExitclean()
      w.write("0x40000000,")
    ELSE
      w.write("0,")
    }
    IF $isDeclUsed(%pthread)
      w.write("e->topFrame")
    ELSE
      w.write("topFrame")
    }
    string foPart
    IF $hasNpField()
      w.write(",")
      w.write(frof)
    }
    w.write("};\n")
    RETURN w.ToString()
  }

  # Return the code to init the stack frame at the start of a function.
  FUNC $initStackFrame(string indent) string
    IO.StringWriter w = NEW()

    w.write(indent)
    IF $isDeclUsed(%pthread)
      w.write("e->topFrame = &sf;\n")
      IF $mayCallDoGC()
        w.write(indent)
        w.write("if (e->wantGC) ZthreadGC();\n")
      }
    ELSE
      w.write("topFrame = &sf;\n")
    }

    RETURN w.ToString()
  }

  PROC $setStackPos(Zui.Position pos, bool pauseGC, SContext ctx)
    IF ctx.out.writing && !ctx.scope.noBacktrace && !Config.noBacktrace
                                                       && !ctx.scope.primitive
      ctx.out.writeIndent(ctx.scope.depth + 1)
      $writeSetStackPos(pos, pauseGC, ctx)
      ctx.out.write(";\n")
    }
  }

  # Like $setStackPos but as a single statement, no indent or ';'.
  # When |pauseGC| is TRUE something is about to happen where GC is not safe.
  # Return TRUE when something was written.
  FUNC $writeSetStackPos(Z.Pos pos, bool pauseGC, SContext ctx) bool
    int idx = CodeTable.addEntry(ctx.scope.fullName(), pos)
    IF pauseGC && $manageMemory()
      idx += pauseGCOffset
    }
    ctx.out.write("sf.pos=" .. idx)
    RETURN TRUE
  }

  FUNC $writeSetStackPos(Zui.Position pos, bool pauseGC, SContext ctx) bool
    int idx = CodeTable.addEntry(ctx.scope.fullName(), ctx.zcPos(pos))
    IF pauseGC && $manageMemory()
      idx += pauseGCOffset
    }
    ctx.out.write("sf.pos=" .. idx)
    RETURN TRUE
  }

  # Get a position number and return it as a string, to be used as a function
  # argument.
  FUNC $getPosNumber(Z.Pos pos, SContext ctx) string
    RETURN CodeTable.addEntry(ctx.scope.fullName(), pos)
  }

  # Get a position number and return it as a string, to be used as a function
  # argument.
  FUNC $getPosNumber(Zui.Position pos, SContext ctx) string
    RETURN CodeTable.addEntry(ctx.scope.fullName(), ctx.zcPos(pos))
  }

  FUNC $needPauseGC(Zui.Statement stmt) bool
    ZuiStatementExt stmtExt = stmt
    RETURN stmtExt.props.methodCall || stmtExt.props.allocMem
                                                          || stmt.getBlockgc()
  }

  PROC $beforeStatement(Zui.Statement stmt, SContext ctx)
    $beforeStatement(stmt.getPos(), $needPauseGC(stmt), ctx)
  }

  PROC $beforeStatement(Zui.Position pos, Zui.Statement stmt, SContext ctx)
    $beforeStatement(pos, $needPauseGC(stmt), ctx)
  }

  PROC $beforeStatement(Zui.Position pos, bool pauseGC, SContext ctx)
    IF ctx.out.writing && !ctx.scope.noBacktrace && !Config.noBacktrace
                                                       && !ctx.scope.primitive
      ctx.out.writeIndent(ctx.scope.depth)
      $writeSetStackPos(pos, pauseGC, ctx)
      ctx.out.write(";\n")
      ctx.scope.wantBacktrace = TRUE
    }
  }

  PROC $beforeCallStatement(Zui.Position pos, SContext ctx)
    $beforeStatement(pos, TRUE, ctx)
  }

  PROC $afterStatement(Zui.Statement stmt, SContext ctx)
    IF stmt.getBlockgc() && $isDeclUsed(%pthread)
                          && $manageMemory() && $isDeclUsed(Declaration.gcRun)
      # Disabled the GC, may need to check the wantGC flag now.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("if (e->wantGC) ZthreadGC();\n")
    }
  }

  PROC $afterCall(SContext ctx)
    IF ctx.out.writing && !ctx.scope.noBacktrace && !Config.noBacktrace
      ctx.out.write(")")
    }
  }

  # Write the operator to get a reference: "&" for C.
  PROC $writeRef(string varname, SContext ctx)
    ctx.out.write("&(")
    ctx.out.write(varname)
    ctx.out.write(")")
  }

  # Write a variable increment or decrement as a statement.
  FUNC $writeIncDec(Zui.Statement stmt, SContext ctx) Declaration
    Output out = ctx.out
    IF stmt.getType() == Zui.StatementType.eINC
      out.write("++(")
    ELSE
      out.write("--(")
    }
    Declaration decl = Generate.generateLVarname(stmt.getExpr(), TRUE,
                                                              ctx, Type.anInt)
    out.write(")")
    RETURN decl
  }

  # Write a call statement.
  PROC $callStatement(Type retType, Output callOut, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.append(callOut)
    $statementLineEnd(ctx.out)
  }

  PROC $returnBefore(bool proc, bool multi, Zui.Position pos, SContext ctx)
    IF !proc
      ctx.out.writeIndent(ctx.scope.depth)
      IF multi
        ctx.out.write("r.a0 = ")
      ELSE
        ctx.out.write("r = ")
      }
    }
  }

  PROC $returnAfter(Type returnType, bool writeScopeEnd,
                                               Zui.Position pos, SContext ctx)
    Scope s = ctx.scope.tryScope(FALSE, FALSE)
    IF s != NIL && s.<TryScope>.hasFinally
      # We are inside a TRY that has a FINALLY, jump there.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("did_goto_finally = " .. scopeReturn)
      ctx.out.write("; goto " .. s.<TryScope>.finallyLabelName .. ";\n")
    ELSE
      # Write code to return from a method.
      IF writeScopeEnd
        $writeScopeEnd(TRUE, TRUE, NIL, pos, ctx)
      }
      IF returnType != NIL && ctx.scope.flags.insideFinish
                                         && $isDeclUsed(Declaration.hasFinish)
        # When returning OK set the flag that Finish() is no longer executable.
        ctx.out.writeIndent(ctx.scope.depth)
        ctx.out.write("if (r) ")
        ctx.out.write(cThisName)
        ctx.out.write("->fok |= FOK_OK;\n")
      }
      $writeBeforeReturn(pos, ctx)
      ctx.out.writeIndent(ctx.scope.depth)
      IF returnType == NIL
        ctx.out.write("return;\n")
      ELSE
        ctx.out.write("return r;\n")
      }
    }
  }

  # RETURN halfway a MethodScope: jump to the return at the end.
  PROC $jumpToReturn(Zui.Position pos, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("goto ")
    IF ctx.scope.retLabel == NIL
      ctx.scope.retLabel = getUid(ctx.scope.scopeName)
    }
    ctx.out.write(ctx.scope.retLabel)
    $statementLineEnd(ctx.out)
  }

  # Whether a RETURN with more than one value is done in one line.
  FUNC $compactMultiReturn() bool
    RETURN FALSE
  }

  PROC $returnAfterMulti(SContext ctx)
  }

  # Write declaration for catch in try block.
  FUNC $declareInBlock() bool
    RETURN FALSE
  }

  # Extra argument for RETURN.
  # expr.undefined will be set.
  PROC $extraReturn(Zui.Expression expr, int idx, SContext ctx, Type destType)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("r.a" .. idx .. " = ")
    Generate.genTopExprDoConv(expr, ctx, destType)
    ctx.out.write(";\n")
  }

  # RETURN in an inner scope: set "rt" flag and jump to the end of the outer
  # scope.
  PROC $jumpToOuterScope(Zui.Position pos, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("rt = 1;\n")
    ctx.out.writeIndent(ctx.scope.depth)
    $writeJumpToLabel(ctx)
    ctx.out.write("\n")
  }

  # Write code to exit, before evaluating the argument.
  PROC $exitBefore(Zui.Statement stmt, SContext ctx)
    ctx.out.write("Zexit(")
    IF $isDeclUsed(Declaration.try)
      # The position is only needed for throwing an exception.
      ctx.out.write(newPosString(stmt.getPos(), ctx))
    ELSE
      ctx.out.write("NULL")
    }
    ctx.out.write(", ")
  }

  # Write code to exit, after evaluating the argument.
  PROC $exitAfter(bool lastStatement, SContext ctx)
    ctx.out.write(");\n")
    IF lastStatement && ctx.scope.returnType != NIL
      # Avoid a compiler warning for a missing return value.
      $writeNilReturn(ctx, ctx.out)
    }
  }

  PROC $writeBacktrace(Zui.MethodCall call, SContext ctx)
    $setDeclUsed(WriteListC.listAdd)
    ctx.scope.wantBacktrace = TRUE
    ctx.out.write("(")
    bool didStackPos = $writeSetStackPos(call.getPos(), TRUE, ctx)
    IF didStackPos
      ctx.out.write(", ")
    }
    ctx.out.write("MZ__backtrace(")
    IF call.sizeArgument() == 0
      ctx.out.write("0")
    ELSE
      Generate.genExpr(call.getArgument(0), ctx, Type.anInt)
    }
    ctx.out.write(", ")
    IF call.sizeArgument() < 2
      ctx.out.write("-1")
    ELSE
      Generate.genExpr(call.getArgument(1), ctx, Type.anInt)
    }
    ctx.out.write("))")
  }

  # Write code to create a Pos with the position of the caller.
  PROC $writeCallerPos(SContext ctx)
    ctx.out.write("MZ__callerPos()")
  }

  # Write a comment about declaring |decl| in |scopeName|.
  PROC $declComment(string scopeName, Declaration decl, Output out) @private
    IF decl.pName[0] != 'V' && decl.pName[0] != 't'
                                               && !decl.pName.startsWith("Zf")
      out.write(" /* " .. scopeName .. "." .. decl.name .. " */")
    }
  }

  # Return TRUE when a module needs to be generated.
  FUNC $doGenerateModule(SContext ctx) bool
    RETURN ctx.scope.usedAsZimbu()
  }

  # Return TRUE when functions are written to bodyOut.
  FUNC $funcInBody() bool
    RETURN FALSE
  }

  # Use int for bool, status, and others in for loop.
  FUNC $useIntInForLoop() bool
    RETURN TRUE
  }

  # Return TRUE when interfaces are writtenl
  FUNC $writeInterface() bool
    RETURN FALSE
  }

  FUNC $prefixClassToNew() bool
    RETURN FALSE
  }

  PROC $moduleType(ModuleType mt, SContext ctx)
    string pName
    # TODO: don't always generate
    # IF enumType.usedEnumName != NIL && $isDeclUsed(enumType.usedEnumName)
      pName = $writeStaticString(mt.name, ctx)
    # }
    Output out = ctx.outs.declOut
    out.write("Tt " .. mt.name .. "__T = {4, ")
    IF pName != NIL
      out.write("((Tc*)&" .. pName .. ")")
    ELSE
      out.write("0")
    }
    out.write(", 0};\n")
  }

  # Set dependencies of used items.  This is called before marking used items
  # in Main().
  PROC $addDependencies()
    # Add dependencies for all the CodeWriters.
    CodeWriter.addDependencies(codeWriters, THIS)

    $setDeclDependency(Declaration.dict, %string_h)
    $setDeclDependency(Declaration.try, %setjmp_h)
    Declaration.itemToString.addDependsOn(%garray)
    Declaration.itemToString.addDependsOn(%iobjType)

    WriteArrayC.addDependencies(THIS)
    WriteDictC.addDependencies(THIS)
    WriteListC.addDependencies(THIS)
  }

  # Set used flags for dependencies of used items.  This is called after
  # marking items used for Main().
  PROC $markUsed()
    # Used in Fmain().
    $setDeclUsed(Declaration.throwCstringInit)

    # used in Zdeadly()
    $setDeclUsed(Declaration.throwDeadly)

    # used in Za()
    $setDeclUsed(Declaration.throwOutOfMemory)

    # Items that are always used.
    # TODO: Only use when needed.
    $setDeclUsed(DeclStore.getDecl("MZModule", "CPos"))

    IF Arguments.testMode
      # When testing TEST.runTest() will be used by code generated in
      # $writeTestMethods()
      $setDeclUsed(DeclStore.getDecl("MTESTModule", "FrunTest"))
      $setDeclUsed(DeclStore.getDecl("MTESTModule", "Freport"))
    }

    # Disable memory management when it does not work with threads.
    ManageMemory.checkForThreads(THIS)

    IF ManageMemory.isExitclean()
      $setDeclUsed(Declaration.gcRun)
      $setDeclUsed(Declaration.throwInternal)
    }

    IF $isDeclUsed(%pthread)
      IF ManageMemory.manageLinked()
        # TODO: only when actually managing memory
        $setDeclUsed(WriteListC.listGetPtr)
      ELSE
        # TODO: not always?
        $setDeclUsed(%zfree)
      }
      $setDeclUsed(WriteListC.listFind)
      $setDeclUsed(WriteListC.listRemovePtrItem)
    }

    IF ManageMemory.manageMemory(THIS)
      # TODO: only when actually managing memory
      $setDeclUsed(DeclStore.getDecl("MTIMEModule", "Fcurrent"))
    }

    IF Config.profalloc
      $setDeclUsed(DeclStore.getDecl("MZModule", "FprofAllocDump"))
    }

    WriteArrayC.markUsed(THIS)
    WriteListC.markUsed(THIS)
  }

  # Generate global items.
  PROC $writeGlobals(SContext ctx)
    # Generate the "NIL" string: ZNilString.
    $writeStaticString("NIL", ctx)

    # Generate callback declarations.
    CallbackType.generateCallbacks(ctx)

    # Generate tuple declarations.
    TupleType.generateTuples(ctx)
  }

  # Write C code from |outputs| into outFile.
  PROC $writeFile(UsedFile usedFile, SContext ctx,
                                        Output.Group outputs, IO.File outFile)
    $writeIncludes(outFile)

    outFile.write("/*\n * TYPEDEFS\n */\n")
    $writeTypedefs(outFile)
    outputs.typeOut.writeToFile(outFile)

    outFile.write("/*\n * STRUCTS\n */\n")
    $writeDecl(ctx, outFile)
    outputs.structOut.writeToFile(outFile)

    outFile.write("/*\n * DECLARE FUNCTIONS AND GLOBALS\n */\n")
    outputs.declOut.writeToFile(outFile)
    outFile.write("\n")

    $writeStaticTable(outFile, ctx)

    outFile.write("int ZglobInit(int round);\n")
    $writeBodies(outFile)

    outFile.write("/*\n * FUNCTION BODIES\n */\n")
    outputs.bodyOut.writeToFile(outFile)

    $writeGlobInit(usedFile, ctx, outputs, outFile)

    IF Arguments.testMode
      $writeTestMethods(outputs)
    }

    outFile.write("/*\n * MAIN\n */\n")
    outputs.mainOut.writeToFile(outFile)
  }

  # Write the required "#include" lines to |fd|.
  PROC $writeIncludes(IO.File fd)
    IF $isDeclUsed(%string_h)
      fd.write("#include <string.h>\n")
    }
    fd.write("#include <errno.h>\n")
    # always needed for malloc() and calloc()
    fd.write("#include <stdlib.h>\n")

    # Also needed for getpid().
    IF $isDeclUsed(%unistd) || ManageMemory.isExitclean()
      fd.write("#include <unistd.h>\n")
    }
    IF $isDeclUsed(%sys_types)
      fd.write("#include <sys/types.h>\n")
    }
    IF $isDeclUsed(%dirent)
      fd.write("#include <dirent.h>\n")
    }
    IF $isDeclUsed(%limits)
      fd.write("#include <limits.h>\n")
    }
    # always needed for _O_BINARY
    fd.write("#include <fcntl.h>\n")
    IF $isDeclUsed(%sys_stat)
      fd.write("#include <sys/stat.h>\n")
    }
    IF $isDeclUsed(%pthread)
      Config.addThreadLib()  # adds -lpthread to the build command
      fd.write("#include <pthread.h>\n")
    }
    IF $isDeclUsed(%math)
      Config.addMathLib()    # adds -lm to the build command
      fd.write("#include <math.h>\n")
    }
    IF $isDeclUsed(%pcre) || pcreUsed
      Config.addPcreLib()    # adds pcrelib.o to the build command
      # Use our own pcre.h file, not all systems have it.
      fd.write("#include \"\(IO.fullPath(Config.thirdpartyPath))/pcre/pcre.h\"\n")
    }
    IF $isDeclUsed(%ctype_h)
      fd.write("#include <ctype.h>\n")
    }
    fd.write("#include <stdio.h>\n")   # always needed for NULL
    fd.write("#include <signal.h>\n")  # always needed for SIGSEGV
    fd.write("#include <stddef.h>\n")  # always needed for offsetof()

    IF $catchSignals() || $gcSignal()
      fd.write(''"#if defined(__MINGW32__) || defined(_MSC_VER)
# define GC_SIG SIGABRT
# include <excpt.h>
#else
# define GC_SIG SIGUSR2
#endif
"'')
    }

    IF $isDeclUsed(%setjmp_h)
      fd.write("#include <setjmp.h>\n")  # needed for jmp_buf
    }
    IF $isDeclUsed(%sys_time)
      fd.write("#include <sys/time.h>\n")
    }
    IF $isDeclUsed(%termios)
      fd.write("#include <termios.h>\n")
    }
    IF $isDeclUsed(%time_h)
      fd.write("#include <time.h>\n")
    }
    IF $isDeclUsed(%errno)
      fd.write("#include <errno.h>\n")
    }
    IF $isDeclUsed(%sys_wait)
      fd.write("#ifndef __MINGW32__\n")
      fd.write("# define HAVE_FORK\n")  # for SYS.Process
      fd.write("# include <sys/wait.h>\n")
      fd.write("#endif\n")
    }
    IF $isDeclUsed(%windows_h)
      fd.write("#ifdef __MINGW32__\n")
      fd.write("# include <windows.h>\n")
      fd.write("# undef THIS\n")
      fd.write("# undef small\n")
      fd.write("#endif\n")
    }

    IF $isDeclUsed(%socket)
      Config.addSocketLib()  # may add -l argument to the build command

      # On WIN32 (MingW) use winsock.  And remove name space pollution.
      # setsockopt() declaration is not according to POSIX.
      # Define missing socklen_t.
      fd.write(''"
#ifdef WIN32
# include <winsock2.h>
# include <ws2tcpip.h>
# undef THIS
# undef small
  typedef int socklen_t;
# if defined _WIN32 || defined __WIN32__
#  define setsockopt(a,b,c,d,e) setsockopt(a,b,c,(const void*)(d),e)
# endif
# define sckt_read(a, b, c) recv(a, b, c, 0)
# define sckt_write(a, b, c) send(a, b, c, 0)
# define sckt_close(a) closesocket(a)
#else
# define sckt_read(a, b, c) read(a, b, c)
# define sckt_write(a, b, c) write(a, b, c)
# define sckt_close(a) close(a)
# include <sys/socket.h>
# include <netinet/in.h>
# include <arpa/inet.h>
#endif
"'')
    }
    IF $isDeclUsed(%hostname)
      fd.write(''"
#include <netdb.h>
"'')
    }

    # Included through IMPORT.CHEADER.
    TopScope topScope = CTX.get(TopScope.Type())
    FOR cheader IN topScope.cheaders
      fd.write("#include " .. cheader .. "\n")
    }

    fd.write("\n")
  }

  # Write all needed typedefs to |fd|.
  PROC $writeTypedefs(IO.File fd)
    # MingW has a different format for "long long".  When producing portable
    # code include an #ifdef, so that it works on most systems.
    IF Config.portableFlag.get() && Config.int64name == "long long"
      fd.write(''"
#ifdef __MINGW32__
# define ZINT_FORMAT "%I64d"
# define ZNAT_FORMAT "%I64u"
# define ZINT_XFORMAT "%I64x"
#else
# define ZINT_FORMAT "%lld"
# define ZNAT_FORMAT "%llu"
# define ZINT_XFORMAT "%llx"
#endif
"'')
    ELSE
      fd.write("#define ZINT_FORMAT \"" .. Config.printIntFormat .. "\"\n")
      fd.write("#define ZNAT_FORMAT \"" .. Config.printNatFormat .. "\"\n")
      fd.write("#define ZINT_XFORMAT \"" .. Config.scanfHexFormat .. "\"\n")
    }
    fd.write("#define ZFLOAT_FORMAT \"%g\"\n")
    fd.write("typedef " .. Config.int64name .. " Ti; /* int */\n")
    fd.write("typedef " .. Config.int16name .. " Ti16; /* int16 */\n")
    fd.write("typedef " .. Config.int32name .. " Ti32; /* int32 */\n")
    fd.write("typedef " .. Config.nat64name .. " Tu; /* nat */\n")
    fd.write("typedef unsigned char Tc; /* byte */\n")
    fd.write("typedef " .. Config.nat16name .. " Tu16; /* nat16 */\n")
    fd.write("typedef " .. Config.nat32name .. " Tu32; /* nat32 */\n")
    fd.write("typedef " .. Config.floatName .. " Tf; /* float */\n")
    fd.write("typedef " .. Config.float32name .. " Tf32; /* float32 */\n")
    fd.write("typedef " .. Config.intPtrName .. " Tip; /* int for pointer */\n")
    fd.write("typedef " .. Config.int64name .. " Tbb; /* big BITS */\n")
    fd.write(''"
typedef int Tbs; /* small BITS */
typedef int Tb; /* bool */
typedef int Ts; /* status */
typedef int Te; /* enum */
typedef struct Tj__S Tj; /* xobject ref */
typedef struct Zref__S Tr; /* iobject ref */
typedef struct Zobj__S To; /* object description */
typedef union {
 Ti ival;
 Tf fval;
 void *ptr;
} Tz; /* dyn value */
"'')
    IF $isDeclUsed(Type.aDyn)
      fd.write("typedef struct Zdyn__S Tx; /* dyn */\n")
    }
    fd.write("typedef struct Ztype__S Tt; /* type */\n")
    fd.write("typedef struct Ztypeo__S Tto; /* type with To pointer */\n")
    IF $hasNpField()
      # Header used for objects when using GC.
      # Also used for objects with a Finish method.
      fd.write("typedef struct Zoh__S Zoh; /* allocated memory header */\n")
      fd.write("struct Zoh__S {\n")
      fd.write(linkedDecl)
      fd.write("};\n")
    }
    IF $hasNpField()
      fd.write("#define ZOH_OFF sizeof(Zoh)\n")

      # Marker for items in static memory, not allocated.
      # GC may free items in it, not the item itself.
      fd.write("Zoh Zstatic;\n")

      # Marker for items on the stack, not allocated.
      # GC may free items in it, not the item itself.
      fd.write("Zoh Znoalloc;\n")

      # Marker for last item in the "firstUsed" list.
      fd.write("Zoh Zlast;\n")
      IF $isDeclUsed(Declaration.hasFinish)
        fd.write("#define ZOHF_LAST (Zohf*)&Zlast\n")
      }

      # Zop: object pointer with type.
      fd.write(''"typedef struct {
 void *var;
 Tt   *type;
} Zop;
"'')

      IF $isDeclUsed(Declaration.gcRun)
        # Zgcb: block with objects to be marked.
        # It is fixed size to make allocation more efficient, should just fit
        # in a 8 Kbyte page.
        fd.write(''"#define GC_BLOCK_SIZE 511
typedef struct Zgcb__S Zgcb;
struct Zgcb__S {
 Zop items[GC_BLOCK_SIZE];
 Zgcb *next;
 int used;
};
"'')

        # Zgcs: GC status
        # Zgcs.todo:  list of blocks with objects to be marked
        # Zgcs.empty: list of empty blocks, to be recycled
        fd.write(''"typedef struct {
 Zgcb *todo;
 Zgcb *empty;
} Zgcs;
"'')
      }
    ELSE
      fd.write("#define ZOH_OFF 0\n")
    }

    # Zohf: same as Zoh but with the "fok" flag for objects with Finish().
    # And a "to" field to know what object type it is.
    # Also used without GC, when there is a Finish method.
    IF $isDeclUsed(Declaration.hasFinish)
      fd.write("typedef struct Zohf__S Zohf;\n")
      fd.write("struct Zohf__S {\n")
      IF $hasNpField()
        fd.write(linkedDecl)
      }
      fd.write(memberTableDecl)
      fd.write(finishDecl)
      fd.write("};\n")
      fd.write("#define FOK_OK 1\n")
      fd.write("#define FOK_NOX 2\n")
    }

    FOR writer IN codeWriters
      IF writer.typedef != NIL && writer.isUsed(THIS)
        fd.print(writer.typedef)
      }
    }

    # Array type
    WriteArrayC.writeTypedefs(THIS, fd)

    # List type
    WriteListC.writeTypedefs(THIS, fd)

    # Dict type
    WriteDictC.writeTypedefs(THIS, fd)

    fd.write("\n")
  }

  PROC $writeGlobInit(UsedFile usedFile, SContext ctx,
                                        Output.Group outputs, IO.File outFile)
    outFile.write("/*\n * INIT GLOBALS\n */\n")
    outFile.write("int ZglobInit(int round) {\n")
    outFile.write(" int done = 1;\n")

    MethodScope ms = usedFile.zimbuFile.initScope
    IF ms != NIL && ms.tempVars != NIL
      FOR decl IN ms.tempVars
        outFile.write(" ")
        outFile.write($vartypeString(decl.type, TRUE, decl.zuiPos, ctx))
        outFile.write(decl.pName)
        outFile.write(";\n")
      }
    }

    IF !Config.noBacktrace || $manageMemory()
      outFile.write($stackDeeper(" ", "NULL"))
    }
    IF !Config.noBacktrace || $manageMemory()
      outFile.write($initStackFrame(" "))
    }

    IF !outputs.earlyInitOut.empty()
      IF outputs.earlyInitLead != NIL
        outFile.write(outputs.earlyInitLead)
      }
      outputs.earlyInitOut.writeToFile(outFile)
      IF outputs.earlyInitLead != NIL
        outFile.write(" }\n")
      }
    }

    IF !outputs.initOut.empty()
      IF outputs.initLead != NIL
        outFile.write(outputs.initLead)
      }
      outputs.initOut.writeToFile(outFile)
      IF outputs.initLead != NIL
        outFile.write(" }\n")
      }
    }

    IF !Config.noBacktrace || $manageMemory()
      outFile.write(" ")
      outFile.write($stackBack())
    }
    outFile.write(" return done;\n")
    outFile.write("}\n\n")
  }

  # Write struct and function declarations to |fd|.
  # Some function bodies that don't require other types are defined as well.
  PROC $writeDecl(SContext ctx, IO.File fd)
    # Efficient way to define EOF
    fd.write("/* IO.eof */\n")
    fd.write("#define " .. DeclStore.getPName("MIOModule", "Veof") .. " EOF\n")
    fd.write("\n")

    # For the list of code locations.
    fd.write(''"
typedef struct {
 int line;
 int col;
} Tcpos;
typedef struct {
 Ti offset;
 Tc *fileName;
 Tc *methodName;
 Tcpos *table;
} Tcode;
"'')

      # TODO: Za() is nearly always used, but not always
      # emergencyAlloc is used when throwing an out-of-memory exception.
      # Without that it is not possible to allocate the memory for the
      # exception.
      fd.write(''"
void *Za(size_t size);
void *ZaNm(size_t size);
void *ZaNmi(size_t size);
void *Zran(void *op, size_t osize, size_t nsize);
void *ZranNm(void *op, size_t osize, size_t nsize);
void ZthrowOutOfMemory(Ti size);
char *emergencyAlloc = NULL;
size_t emergencyAllocUsed = 0;
void ZthrowDeadly(int nr);
Tc *ZnewString(Tc *p, Ti len);
"'')

    # varByteString implementation:
    # Ty.flags
    # ZbyteStringT_tiny        bytes are in tiny[], up to 3 or 7 bytes and NUL
    # ZbyteStringT_string      const Tc *, ends in NUL
    # ZbyteStringT_piece       Tp; use memory of Tp.data and further
    # ZbyteStringT_pieceval    Tv; data points to byteString or Tp
    # ZbyteStringT_cord        Tcd, use flags in Tcd (doesn't work yet!)
    #
    # ZbyteString_cow          copy on write (not implemented yet)
    #
    # ZbyteStringP_default     optimal for normal use
    # ZbyteStringP_nocord      don't use Tcd
    # ZbyteStringP_minmem      minimize memory use
    # ZbyteStringP_minalloc    minimize number of reallocations
    #
    # Ty.byteSize   actual byte length, excluding extra NUL
    # Ty.charSize   actual utf-8 char count, -1 when not computed
    # Ty.growsize   extra space when growing size
    # Ty.flags      lower 3 bits type, 1 bit COW, upper 3 bits policy
    #
    # Tp.space      length of allocated data in bytes, excluding Tp
    #                   and extra NUL
    # Tp.offset     0 when at the start
    #
    # Tv.space   as Tp.space
    # Tv.offset  as Tp.offset
    # Tv.data    points to immutable data
    #
    # Tcd.next        next Tcd, NULL for the last one
    # Tcd.byteSize    actual byte length of this part, after offset
    # Tcd.charSize    actual number of chars, -1 when not computed
    # Tcd.type        ZbyteStringT_*  (including ZbyteStringT_cord!) and ZbyteString_cow
    # Tcd.space       for ZbyteStringT_piece and ZbyteStringT_pieceval
    # Tcd.offset      0 when at the start
    # Tcd.data        as Ty.data, when ZbyteStringT_piece part of the data
    # Tcd.tiny        as Ty.tiny

    IF $isDeclUsed(Type.aDyn)
      # dyn is a flat type, it's not allocated.  Whether it was set is
      # indicated by "type" not being NULL.
      fd.write(''"
struct Zdyn__S {
 Tt *type;
 Tz u;
};
Tx txZero = {NULL};
"'')
    }

    FOR writer IN codeWriters
      IF writer.isUsed(THIS)
        IF writer.declString != NIL
          fd.print(writer.declString)
        }
        IF writer.produceDecl != NIL
          writer.produceDecl(THIS, fd)
        }
      }
    }

    # Tj__S: head of every object.
    # np points to next allocated object
    # mt points to the member table of this object.  mt[0] is the type.
    #
    # Zref__S: An object reference of an interface type.
    # |ptr| points to the actual object.
    # |table| points to the interface member table that belongs to the
    # actual object.
    # |type| is the index of the class of the actual object in the list of
    # possible classes, used for virtual function arguments.
    fd.write(''"
struct Tj__S {"'')
    IF $hasNpField()
      fd.write(''"
 Zoh *np;"'')
    }
    fd.write(''"
 Tc **mt;
};
struct Zref__S {
 void *ptr;
 Tc **table;
 int  type;
};"'')

    # Assigning NIL to an iobject uses trZero.  Use -1 for the type, so that
    # ISA always fails.
    fd.write(''"
Tr trZero = {NULL,NULL,-1};"'')

    # An object description entry.
    # |off|   is an offset inside the object struct.
    # |type|  is the object type at that offset.
    # For the first entry of an array:
    # |off|   is the number of entries.
    # |type|  is unused.
    fd.write(''"
struct Zobj__S {
 int off;
 Tt *type;
};
"'')

    # TODO: only produce if type is used.
    # Note: these are never allocated.
    # |nr|       identifies the type
    # |name|     is used for enum, module, etc.
    # |ToString| may point to a function that converts to a string
    # |names|    list of members, types are in |to|.
    # |Equal|    may point to an Equal() function
    # |Compare|  may point to a Compare() function
    # |to|       types of members, length is |to[0]|.
    fd.write(''"
struct Ztype__S {
 int nr;
 Tc *name;
 void *ToString;
};
struct Ztypeo__S {
 int nr;
 Tc *name;
 void *ToString;"'')
    IF $ttoHasMemberNames()
      fd.write(''"
 char **names;"'')
    }
    IF $ttoHasAssign()
      fd.write(''"
 void (*Assign)(void*, void*);"'')
    }
    IF $ttoHasMethods()
      fd.write(''"
 void *Size;
 void *Finish;
 void *Equal;
 void *Compare;"'')
    }
    fd.write(''"
 To *to;
};
"'')

    $writeToDecls(fd, FALSE)

    $writeMultipleDecls(ctx, fd)

    # Class-like types for allocated variables.
    IF Type.allocTypes != NIL
      FOR t IN Type.allocTypes
        fd.write("typedef struct ")
        fd.write(t.pName)
        fd.write("__S ")
        fd.write(t.pName)
        fd.write("; /* ")
        fd.write(t.name)
        fd.write(" */\n")

        fd.write("struct ")
        fd.write(t.pName)
        fd.write("__S {\n")
        fd.write($getStructHead())
        fd.write(" ")
        fd.write($vartypeString(t.allocDecl.type, TRUE, NIL, NIL))
        fd.write("Vm;\n")
        fd.write("};\n")

        fd.write("To To")
        fd.write(t.pName)
        fd.write("[] = {\n")
        IF t.allocDecl.type.isManaged()
          fd.write(" {1, 0},\n")
          fd.write(" {ZOH_OFF, &")
          fd.write(t.allocDecl.type.getTypeName(ctx))
          fd.write("__T},\n")
        ELSE
          fd.write(" {0, 0},\n")
        }
        fd.write("};\n")

        # Must write to declOut, otherwise static string isn't defined yet.
        string tcName = $writeStaticString(t.name, ctx)
        Output dout = ctx.outs.declOut
        WriteIMT.writeClassType(t, tcName, "To" .. t.pName, dout, ctx)
      }
    }

    # Type names for containers.
    FOR decl IN ContainerType.usedTypes
      IF $isDeclUsed(decl)
        string tcName = $writeStaticString(decl.name, ctx)

        # Must write to declOut, otherwise static string isn't defined yet.
        Output dout = ctx.outs.declOut
        dout.write("Tt " .. decl.pName .. "__T = {")
        SWITCH decl.type.ttype
          CASE Type.Enum.array
            dout.write("300")
          CASE Type.Enum.list
            dout.write("301")
          CASE Type.Enum.dict
            dout.write("302")
        }
        dout.write(", (Tc*)&" .. tcName .. ", 0};\n")
      }
    }

    # Array type
    WriteArrayC.writeDecl(THIS, fd)

    # List type
    WriteListC.writeDecl(THIS, fd)

    # Dict type
    WriteDictC.writeDecl(THIS, fd)

    # Write structs for libraries.
    FOR p IN declWriters
      p(THIS, fd)
    }
  }

  # Return TRUE if Tto includes Assign().
  FUNC $ttoHasAssign() bool
    RETURN $isDeclUsed(Declaration.noAllocAssign)
  }

  # Return TRUE if Tto includes Equal(), Compare() and other methods.
  FUNC $ttoHasMethods() bool
    RETURN $isDeclUsed(Type.aDyn)
        || $isDeclUsed(Declaration.itemEqual)
        || $isDeclUsed(Declaration.hasFinish)
  }

  # Return TRUE if Tto includes the list of member names.
  FUNC $ttoHasMemberNames() bool
    RETURN $isDeclUsed(Declaration.itemToString)
  }

  list<Declaration> $staticVars
  list<Declaration> $noallocVars

  # Write the To entries for built-in types.
  # This code uses TYPE_NUMBERS, keep in sync!
  PROC $writeToDecls(IO.File fd, bool init)

    IF init
      fd.write("Tt bool__T = {21, 0, 0};\n")
      fd.write("Tt byte__T = {11, 0, 0};\n")
      fd.write("Tt byteString__T = {201, 0, 0};\n")
      fd.write("Tt float128__T = {83, 0, 0};\n")
      fd.write("Tt float32__T = {81, 0, 0};\n")
      fd.write("Tt float80__T = {82, 0, 0};\n")
      fd.write("Tt float__T = {80, 0, 0};\n")
      fd.write("Tt int16__T = {2, 0, 0};\n")
      fd.write("Tt int32__T = {3, 0, 0};\n")
      fd.write("Tt int8__T = {1, 0, 0};\n")
      fd.write("Tt int__T = {0, 0, 0};\n")
      fd.write("Tt nat16__T = {12, 0, 0};\n")
      fd.write("Tt nat32__T = {13, 0, 0};\n")
      fd.write("Tt nat__T = {10, 0, 0};\n")
      fd.write("Tt status__T = {22, 0, 0};\n")
      fd.write("Tt string__T = {200, 0, 0};\n")
      fd.write("Tt type__T = {101, 0, 0};\n")
    ELSE
      fd.write("extern Tt bool__T;\n")
      fd.write("extern Tt byte__T;\n")
      fd.write("extern Tt byteString__T;\n")
      fd.write("extern Tt float128__T;\n")
      fd.write("extern Tt float32__T;\n")
      fd.write("extern Tt float80__T;\n")
      fd.write("extern Tt float__T;\n")
      fd.write("extern Tt int16__T;\n")
      fd.write("extern Tt int32__T;\n")
      fd.write("extern Tt int8__T;\n")
      fd.write("extern Tt int__T;\n")
      fd.write("extern Tt nat16__T;\n")
      fd.write("extern Tt nat32__T;\n")
      fd.write("extern Tt nat__T;\n")
      fd.write("extern Tt status__T;\n")
      fd.write("extern Tt string__T;\n")
      fd.write("extern Tt type__T;\n")
    }
    IF $isDeclUsed(%pthread)
      # thread__T is used for "threads", not for Thread objects
      fd.write(init ? "Tt thread__T = {250, 0, 0};\n"
                                                   : "extern Tt thread__T;\n")
    }
    IF $isDeclUsed(Declaration.array)
      fd.write(init ? "Tt array__T = {300, 0, 0};\n" : "extern Tt array__T;\n")
    }
    IF $isDeclUsed(Declaration.list)
      fd.write(init ? "Tt list__T = {301, 0, 0};\n" : "extern Tt list__T;\n")
      IF $isDeclUsed(Declaration.defer)
        # defer__T means the same as list__T, it is used for "deferList", so
        # that it can be found on the stack frame.
        fd.write(init ? "Tt defer__T = {301, 0, 0};\n"
                                                    : "extern Tt defer__T;\n")
      }
    }
    IF $isDeclUsed(Declaration.dict)
      fd.write(init ? "Tt dict__T = {302, 0, 0};\n" : "extern Tt dict__T;\n")
    }
    IF $isDeclUsed(Declaration.varString)
                                     || $isDeclUsed(Declaration.varByteString)
      fd.write(init ? "Tt varString__T = {310, 0, 0};\n"
                                                : "extern Tt varString__T;\n")
      fd.write(init ? "Tt varByteString__T = {311, 0, 0};\n"
                                            : "extern Tt varByteString__T;\n")
    }
    IF $isDeclUsed(Declaration.funcRef) || $isDeclUsed(Declaration.defer)
      fd.write(init ? "Tt cb__T  = {330, 0, 0};\n" : "extern Tt cb__T;\n")
    }
    IF $isDeclUsed(Type.aDyn)
      fd.write(init ? "Tt dyn__T  = {360, 0, 0};\n" : "extern Tt dyn__T;\n")
    }
    fd.write(init ? "Tt iobj__T = {391, 0, 0};\n" : "extern Tt iobj__T;\n")
    fd.write(init ? "Tt xobj__T = {392, 0, 0};\n" : "extern Tt xobj__T;\n")
  }

  PROC $writeMultipleDecls(SContext ctx, IO.File fd)
    FOR t IN MultipleType.allTypes
      IF $isDeclUsed(t)
        fd.write("typedef struct {\n")
        FOR i IN 0 UNTIL t.types.Size()
         fd.write(" ")
         fd.write($vartypeString(t.types[i].type, TRUE, NIL, ctx))
         fd.write(" a" .. i)
         fd.write(";\n")
        }
        fd.write("} ")
        fd.write(t.pName)
        fd.write(";\n")
      }
    }
  }

  # Write the table with static variables.  This is used by the garbage
  # collector to find used memory items.
  PROC $writeStaticTable(IO.File fd, SContext ctx)
    IF $manageMemory()
      fd.write(''"
Zop ZglobalVars[] = {"'')
      $writeOneStaticTable($staticVars, fd, ctx)
      IF $noallocVars != NIL
        fd.write(''"
Zop ZnoallocVars[] = {"'')
        $writeOneStaticTable($noallocVars, fd, ctx)
      }
    }

    $writeToDecls(fd, TRUE)
  }

  PROC $writeOneStaticTable(list<Declaration> vars, IO.File fd, SContext ctx)
    FOR decl IN vars
      fd.write("\n{&")
      fd.write(decl.pName)
      fd.write(",(Tt*)&")
      fd.write(decl.type.getTypeName(ctx))
      fd.write("__T},")
    }
    fd.write("\n{0,0},")
    fd.write("\n};\n\n")
  }

  PROC $writeBodies(IO.File fd)
    # The per-thread environment, containing:
    # - The stack frame pointer, used for backtraces
    # - The jump buffers used for TRY/CATCH
    # - The thrown exceptions
    # Making "Zsf.pos" volatile avoids that the optimizer will simply drop
    # all assignments, it doesn't know about exceptions.
    fd.write(''"
typedef struct Zfo__S {
 int off;
 Tt  *type;
} Zfo;
typedef struct Zsf__S {
 volatile int pos;
 struct Zsf__S *prev;"'')
    IF $hasNpField()
      fd.write(''"
 Zfo *frof;"'')
     }
     fd.write(''"
} Zsf;
#define POS_MASK 0x3fffffff"'')
    IF $isDeclUsed(Declaration.try)
      fd.write(''"
typedef struct StryCtx__S {
 jmp_buf jmpBuf;
 Zsf *sf;
} Ttc;"'')
    }
    fd.write(''"
typedef struct Senv__S {"'')
    IF $isDeclUsed(Declaration.try)
      fd.write(''"
 Ttc  *tryCtx;
 int  tryCtxSize;
 int  tryCtxUsed;
 "'' .. exceptionPname() .. ''" **thrown;
 int  thrownSize;
 int  thrownUsed;"'')
    }
    IF $isDeclUsed(%pthread)
      fd.write(''"
 pthread_t tid;
 int finished;
 int found;
 int timedOut;
 int inZa;
 int ZaEntered;
 Zsf *startFrames;
 Zsf *topFrame;"'')
      IF $manageMemory()
        # List with allocated memory items.
        # This is not one long list to avoid having to find the end of the
        # list, or keeping track of the end.
        fd.write(''"
 Zoh *firstUsed;
 pthread_mutex_t stateMutex;
 pthread_cond_t stateCond;
 int wantGC;
 int inGC;
#define GC_STOPPED 1
#define GC_MARK_DONE 2
 int state;"'')
        IF $isDeclUsed(Declaration.gcRun)
          fd.write(''"
 Zgcs gcStatus;"'')
        }
      }
      IF $isDeclUsed(Declaration.hasFinish)
        # List with allocated objects with a Finish() method.
        # Last item in the list points to &Zlast.
        fd.write(''"
 Zohf *firstUsedF;"'')
      }
    }
    IF $isDeclUsed(Declaration.usesCtx)
      fd.write(''"
 Tce *ctxArr;
 int ctxUsed;
 int ctxLen;"'')
    }
    fd.write(''"
 int tosNr;
} Tn; /* per-thread environemnt */
"'')

    IF $manageMemory()
      IF $isDeclUsed(%pthread)
        # List of lists of allocated memory items. These are taken over from
        # threads when GC.run() is invoked or when a thread ends.
        # usedListF is the same for objects with a Finish() method.
        # This is not one long list to avoid having to find the end of the
        # list, or keeping track of it.
        # Protected by usedListMutex.
        fd.write(''"
typedef struct Zohp__S Zohp;
struct Zohp__S {
 Zohp *next;
 Zoh  *firstUsed;
};
Zohp *usedList = NULL;
pthread_mutex_t usedListMutex;
"'')
      ELSE
        # List of allocated memory items.
        # GC status.
        fd.write(''"
Zoh *firstUsed = &Zlast;"'')
        IF $isDeclUsed(Declaration.gcRun)
          fd.write(''"
Zgcs gcStatus;"'')
        }
      }
    }

    IF $isDeclUsed(Declaration.hasFinish)
      IF $isDeclUsed(%pthread)
        # List of lists of allocated memory items with a Finish() method.
        # Note: must be identical to Zohp (except for the types) so that
        # ZgcFreeList() works for both.
        fd.write(''"
typedef struct Zohpf__S Zohpf;
struct Zohpf__S {
 Zohpf *next;
 Zohf  *firstUsedF;
};
Zohpf *usedListF = NULL;"'')
      ELSE
        # List of allocated memory items with a Finish() method.
        fd.write(''"
Zohf *firstUsedF = ZOHF_LAST;"'')
      }
      fd.write(''"
Zohf *toFinish = ZOHF_LAST;"'')
    }

    IF $isDeclUsed(%pthread)
      IF $manageMemory()
        fd.write(''"
pthread_mutex_t gcRunMutex;
int gcMarkPhase = 0;
int gcSTW = 0;
pthread_mutex_t gcMarkPhaseMutex;
pthread_cond_t gcMarkPhaseCond;
"'')
      }

      fd.write(''"
pthread_mutex_t threadsMutex;
Tl *threads;
"'')
      # When the thread dies ZenvFree() is called to clean up.
      # Set inGC to avoid ZthreadGC() doing its work, it may cause a deadlock
      # when ZenvFree() is interruped by a signal.
      # Hand over the list of allocated memory to the global list.
      fd.write(''"
static pthread_key_t ZenvKey;
void ZenvFree(void *ptr) {
 Tn *e = (Tn *)ptr;
 if (e->startFrames) free(e->startFrames);"'')
      IF $manageMemory()
        fd.write(''"
 e->inGC = 1;
 pthread_mutex_lock(&usedListMutex);
 if (e->firstUsed != &Zlast) {
  Zohp *entry = ZaNmi(sizeof(Zohp));
  entry->next = usedList;
  usedList = entry;
  entry->firstUsed = e->firstUsed;
 }"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 if (e->firstUsedF != ZOHF_LAST) {
  Zohpf *entry = ZaNmi(sizeof(Zohpf));
  entry->next = usedListF;
  usedListF = entry;
  entry->firstUsedF = e->firstUsedF;
 }"'')
        }
        IF $isDeclUsed(Declaration.try)
          fd.write(''"
 if (e->tryCtx) {
  free(e->tryCtx);
 }"'')
        }
        fd.write(''"
 pthread_mutex_unlock(&usedListMutex);"'')
      }
      fd.write(''"
 pthread_mutex_lock(&threadsMutex);
 ZListRemovePtrItem(threads, ZListFind(threads, (Tz)(void*)e));
 pthread_mutex_unlock(&threadsMutex);
 free(ptr);
}"'')

      fd.write(''"
Tn *ZgetEnv() {
 Tn *e = pthread_getspecific(ZenvKey);
 if (e == NULL) {
  e = ZaNmi(sizeof(Tn));
  e->tid = pthread_self();"'')
      IF $manageMemory()
        fd.write(''"
  e->firstUsed = &Zlast;"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
  e->firstUsedF = (Zohf*)&Zlast;"'')
        }
      }
      IF $isDeclUsed(%pthread) && $manageMemory()
        fd.write(''"
  pthread_mutex_init(&e->stateMutex, NULL);
  pthread_cond_init(&e->stateCond, NULL);"'')
      }
      fd.write(''"
  pthread_setspecific(ZenvKey, e);
 }
 return e;
}
void ZenvInit() {
 (void)pthread_key_create(&ZenvKey, ZenvFree);
 pthread_setspecific(ZenvKey, NULL);"'')
      IF $manageMemory()
        fd.write(''"
 pthread_mutex_init(&gcRunMutex, NULL);
 pthread_mutex_init(&usedListMutex, NULL);
 pthread_mutex_init(&gcMarkPhaseMutex, NULL);
 pthread_cond_init(&gcMarkPhaseCond, NULL);"'')
      }
      fd.write(''"
 pthread_mutex_init(&threadsMutex, NULL);
 threads = ZnewList(&thread__T, 0);
 ZLa(threads, -1, (Tz)(void*)ZgetEnv());
}
"'')
    ELSE
      fd.write(''"
Zsf *topFrame = NULL;
int inZa = 0;
int ZaEntered = 0;

Tn Zenv = {"'')
      string comma = ""
      IF $isDeclUsed(Declaration.try)
        fd.write(comma)
        fd.write("NULL, 0, 0, NULL, 0, 0")
        comma = ", "
      }
      IF $isDeclUsed(%pthread)
        fd.write(comma)
        fd.write("NULL, NULL")
        comma = ", "
      }
      fd.write(comma)
      fd.write("0};\n")  # tosNr
    }

    IF $manageMemory()
      fd.write(''"
void ZthreadGC();"'')
    }
    IF $isDeclUsed(Declaration.hasFinish)
      fd.write(''"
void ZgcFinishAll(int rsn);"'')
    }
    IF $isDeclUsed(Declaration.gcRun)
      fd.write(''"
void ZgcRun();"'')
    }

    fd.write(''"
void beforeExit() {"'')
    Declaration exit = DeclStore.getDecl("MZModule", "Vexiting")
    IF $isDeclUsed(exit)
      fd.write("\n ")
      fd.write(exit.pName)
      fd.write(" = 1;")
    }

    IF $isDeclUsed(%pthread)
      # Kill all the other threads. This is required for when one thread
      # throws an exception and exits, we don't want other threads to keep
      # running and eventually hang.
      fd.write(''"
 {
  int i;
  Tn *e = ZgetEnv();
  for (i = 0; i < threads->itemCount; ++i) {
   Tn *ie = ZListGetPtr(threads, i);
   if (ie != e && !ie->finished) {
    pthread_cancel(ie->tid);
    ie->finished = 1;
   }
  }
 }"'')
    }

    IF $isDeclUsed(Declaration.hasFinish)
      fd.write(''"
 ZgcFinishAll(1);"'')
    }
    IF ManageMemory.isExitclean()
      IF $isDeclUsed(Declaration.hasFinish) && $noallocVars != NIL
        fd.write(''"
 ZgcFinishAll(5);"'')
      }
      fd.write(''"
 ZgcRun();"'')
      IF $manageMemory()
        # Makes valgrind find all unused memory.
        IF $isDeclUsed(%pthread)
          fd.write(''"
 {
  Zohp *p;
  for (p = usedList; p; p = p->next) p->firstUsed = &Zlast;
 }"'')
        ELSE
          fd.write(''"
 firstUsed = &Zlast;"'')
        }
      }
      IF $isDeclUsed(Declaration.hasFinish) && $manageMemory()
        # Makes valgrind find all unused memory.
        IF $isDeclUsed(%pthread)
          fd.write(''"
 {
  Zohpf *p;
  for (p = usedListF; p; p = p->next) p->firstUsedF = ZOHF_LAST;
 }"'')
        ELSE
          fd.write(''"
 firstUsedF = ZOHF_LAST;"'')
        }
      }
    }

    IF Config.profalloc
      fd.write("\n \(DeclStore.getPName("MZModule", "FprofAllocDump"))();")
    }

    fd.write(''"
}
"'')

    # These are are also used in lib/GCModule.
    IF $isDeclUsed(Declaration.gcRun)
      fd.write(''"
Ti ZgcUseCount = 0;
Ti ZgcStwTime = 0;
Ti ZgcMarkTime = 0;
Ti ZgcFinishTime = 0;
Ti ZgcFreeTime = 0;
Ti ZgcFreeCount = 0;
"'')
    }

    # Zstr: allocate string from plain C string
    fd.write(''"

Tc *Zstr(char *s) {
 return ZnewString((Tc*)s, strlen(s));
}
"'')

    # Function to set a breakpoint to find missing UNSAFE flags.
    IF ManageMemory.isExitclean()
      fd.write(''"
void ZreportUnsafe() {
 static int rec = 0;
 if (rec == 0) {
  rec = 1;
  ZthrowInternal(Zstr("Allocating memory without UNSAFE set!"));
  rec = 0;
 }
}
"'')
    }

    IF Config.profalloc
      # An array to store memory allocation statistics.
      fd.write(''"
typedef struct {
 int pos;
 int count;
} fromCount_T;
typedef struct {
 Ti          count;
 Ti          size;
 fromCount_T *from;
 int         fromLen;
} profallocEntry_T;
static profallocEntry_T profallocTable["'')
      fd.write(CodeTable.lastOffset)
      fd.write(''"];
Ti totalAllocSize = 0;
Ti totalAllocCount = 0;
int inAllocDump = 0;
void ZprofallocCount(size_t size) {
 int pos;
 profallocEntry_T *entry;"'')
      IF $isDeclUsed(WriteC.pthread)
        fd.write(''"
 Zsf *tf = ZgetEnv()->topFrame;"'')
      ELSE
        fd.write(''"
 Zsf *tf = topFrame;"'')
      }
      fd.write(''"
 if (inAllocDump) return;
 totalAllocSize += size;
 ++totalAllocCount;
 while (1) {
  if (tf == NULL) return;
  pos = tf->pos & POS_MASK;
  if (pos) {
   entry = profallocTable + pos;
   ++entry->count;
   entry->size += size;
   if (tf->prev) {
    int prevPos = tf->prev->pos & POS_MASK;
    if (prevPos) {
     if (entry->fromLen == 0) {
      entry->from = calloc(5, sizeof(fromCount_T));
      entry->fromLen = 5;
      entry->from[0].pos = prevPos;
      entry->from[0].count = 1;
     } else {
      int i;
      fromCount_T *fp = entry->from;
      for (i = 0; i < entry->fromLen; ++i, ++fp) {
       if (fp->pos == prevPos) {
        ++fp->count;
        break;
       } else if (fp->pos == 0) {
        fp->pos = prevPos;
        fp->count = 1;
        break;
       }
      }
      if (i == entry->fromLen) {
       fp = calloc(entry->fromLen + 10, sizeof(fromCount_T));
       memmove(fp, entry->from, entry->fromLen * sizeof(fromCount_T));
       free(entry->from);
       entry->from = fp;
       fp += entry->fromLen;
       fp->pos = prevPos;
       fp->count = 1;
       entry->fromLen += 10;
      }
     }
    }
   }
  }
  tf = tf->prev;
 }
}
"'')
    }

    # Za() and Zran() are always used.
    # When running out of memory throw an exception. When allocating while
    # throwing the exception use the emergencyAlloc.
    # TODO: When managing memory reset "ZaEntered" after handling the
    # exception.
    $writeAllocFunc("Za", FALSE, FALSE, "firstUsed", fd)
    $writeAllocFunc("Zamt", FALSE, TRUE, "firstUsed", fd)

    IF $isDeclUsed(Declaration.hasFinish)
      $writeAllocFunc("ZaF", TRUE, FALSE, "firstUsedF", fd)
    }

    # Version of Za() and Zran() for callers that are not aware of a header.
    fd.write(''"
/* allocate memory with offset */
#define ZaOff(size) (Za((size) + ZOH_OFF) + ZOH_OFF)
#define ZranOff(ptr, osize, nsize) (Zran((ptr) ? (void*)(ptr) - ZOH_OFF : NULL, (osize) + ZOH_OFF, (nsize) + ZOH_OFF) + ZOH_OFF)
"'')

    # Version of Za() for manually freed memory.
    $writeAllocFunc("ZaNm", FALSE, FALSE, NIL, fd)

    # Like ZaNm, but no ZgetEnv() or ZthreadGC() call.  Can't use e->inZa,
    # e->ZaEntered or $checkUnsafeFunc(), it requires ZgetEnv().
    fd.write(''"
void *ZaNmi(size_t size) {
 void *p = NULL;"'')
    IF $isDeclUsed(%pthread)
      fd.write(''"
 p = calloc(1, size);
 if (p == NULL) {
  {"'')
    ELSE
      fd.write(''"
 if (!inZa) {
  inZa = 1;
  p = calloc(1, size);
  inZa = 0;
 }
 if (p == NULL) {
  if (inZa || ZaEntered) {"'')
    }
    fd.write(''"
   if ("'' .. emergencyAllocSize .. ''" - emergencyAllocUsed >= size) {
    p = emergencyAlloc + emergencyAllocUsed;
    emergencyAllocUsed += size;
    return p;
   }
   fprintf(stderr, "Out of memory ZaNmi(%ld)\n", (long)size);
   fflush(stderr);
   exit(1);
  }"'')
    IF !$isDeclUsed(%pthread)
      fd.write(''"
  ++ZaEntered;"'')
    }
    fd.write(''"
  ZthrowOutOfMemory(size);
 }"'')
    IF !$isDeclUsed(%pthread)
      fd.write(''"
 ZaEntered = 0;"'')
    }
    fd.write(''"
 return p;
}
"'')

    fd.write(''"
/* reallocate memory */
void *Zran(void *op, size_t osize, size_t nsize) {
 void *p = NULL;"'')
      IF $isDeclUsed(%pthread)
      fd.write(''"
 Tn *e = ZgetEnv();"'')
      }
    $checkUnsafeFunc(fd)
    IF !$manageMemory()
      IF $isDeclUsed(%pthread)
        fd.write(''"
 if (!e->inZa && !e->ZaEntered) {
  e->inZa = 1;
  p = realloc(op, nsize);
  e->inZa = 0;
  if (p == NULL) {
    ++e->ZaEntered;
    ZthrowOutOfMemory(nsize);
  }
  e->ZaEntered = 0;"'')
      ELSE
        fd.write(''"
 if (!inZa && !ZaEntered) {
  inZa = 1;
  p = realloc(op, nsize);
  inZa = 0;
  if (p == NULL) {
    ++ZaEntered;
    ZthrowOutOfMemory(nsize);
  }
  ZaEntered = 0;"'')
      }
  fd.write(''"
  if (nsize > osize) memset(p + osize, 0, nsize - osize);
  return p;
 }"'')
    }
    fd.write(''"
 p = Za(nsize);
 if (op)
  memmove(p + ZOH_OFF, op + ZOH_OFF, nsize > osize ? osize - ZOH_OFF : nsize - ZOH_OFF);
 if (nsize > osize) memset(p + osize, 0, nsize - osize);
 return p;
}
"'')

    # Like Zran() but for manually freed memory.
    # MT-GC: This is an unsafe call, because the allocated memory will not be
    # referenced while returning.
    fd.write(''"
void *ZranNm(void *op, size_t osize, size_t nsize) {
 void *p = NULL;"'')
    IF $isDeclUsed(%pthread)
      fd.write(''"
 Tn *e = ZgetEnv();"'')
    }
    $checkUnsafeFunc(fd)
    IF $isDeclUsed(%pthread)
      fd.write(''"
 if (!e->inZa && !e->ZaEntered) {
  e->inZa = 1;
  p = realloc(op, nsize);
  e->inZa = 0;
  if (p == NULL) {
   ++e->ZaEntered;"'')
    ELSE
      fd.write(''"
 if (!inZa && !ZaEntered) {
  inZa = 1;
  p = realloc(op, nsize);
  inZa = 0;
  if (p == NULL) {
   ++ZaEntered;"'')
    }
    fd.write(''"
   ZthrowOutOfMemory(nsize);
  }
  if (nsize > osize) memset(p + osize, 0, nsize - osize);
  return p;
 }
 p = ZaNm(nsize);
 if (op) memmove(p, op, nsize > osize ? osize : nsize);
 if (nsize > osize) memset(p + osize, 0, nsize - osize);
 return p;
}
"'')

    IF $isDeclUsed(%zfree)
      # Free memory and mark it no longer used.
      # MT-GC: The caller will have |p| referenced, thus this is not an unsafe
      # call.  The free() itself is unsafe.
      fd.write(''"
void Zfree(void *p) {"'')
      $writeDeclForUnsafe(fd, TRUE)
      $writeBeforeUnsafe(fd)
      fd.write(''"
 if (p) free(p);"'')
      $writeAfterUnsafe(fd)
      fd.write(''"
}
"'')
    }

    IF $isDeclUsed(Declaration.hasFinish)
      # Call Finish() with it didn't return OK before.
      # Catch exceptions thrown by Finish(). If caught set "fok".
      string ewrite = DeclStore.getPName("MEModule", "FwriteToStderr")
      fd.write(''"
void ZtryDeeper(Tn *e, Zsf *sf);
"'')
      fd.write(''"
void ZcallFinish(Zohf *p, Te rsn) {
 if ((p->fok & FOK_OK) == 0 && (rsn != 1 || (p->fok & FOK_NOX) == 0)) {
  Tn *e = "'' .. $getEnvCode() .. ''";
  int try_index = e->tryCtxUsed;
  Zsf *tf = "'' .. $topFrameName() .. ''";
  ZtryDeeper(e, "'' .. $topFrameName() .. ''");
  if (setjmp(e->tryCtx[try_index].jmpBuf) == 0) {
   p->ff(p, rsn);
  } else {
   "'' .. $topFrameName() .. ''" = tf;
   "'' .. ewrite .. ''"(e->thrown[--e->thrownUsed]);
   p->fok |= FOK_OK;
  }
  e->tryCtxUsed = try_index;
 }
}"'')

      IF ($isDeclUsed(%finishIobj) || $isDeclUsed(%noAllocNilIobj)
                                                        || $noallocVars != NIL)
        fd.write(''"
void ZFinishIobj(Tr *tr, Te rsn) {
 if (tr->ptr != NULL) {
  if (((Tto*)tr->table[0])->Finish != NULL)
   ZcallFinish(tr->ptr, rsn);
   tr->ptr = NULL;
 }
}
void ZFinishXobj(void *p, Te rsn) {
 if (p != NULL && ((Tj *)p)->np != NULL) {
  if (((Tto*)((Tj *)p)->mt[0])->Finish != NULL)
   ZcallFinish(p, rsn);
 }
}"'')
      }
    }

    IF $isDeclUsed(Declaration.hasFinish)
      # Call the Finish() methods in toFinish.  Skip it when "fok" is
      # already set (by calling another Finish method).
      # Put the objects back into usedListF.
      fd.write(''"
void ZgcCallFinish(Te rsn) {
 Zohf *p = toFinish;
 Zohf *np;
 toFinish = ZOHF_LAST;
 while (p != ZOHF_LAST) {
  np = (Zohf*)((Tip)(p->np) & ~3);
  ZcallFinish(p, rsn);"'')
      IF $isDeclUsed(%pthread)
        fd.write(''"
  if (usedListF == NULL) {
   usedListF = ZaNmi(sizeof(Zohpf));
   usedListF->firstUsedF = ZOHF_LAST;
  }
  p->np = (Zoh*)usedListF->firstUsedF;
  usedListF->firstUsedF = p;"'')
      ELSE
        fd.write(''"
  p->np = (Zoh*)firstUsedF;
  firstUsedF = p;"'')
      }
      fd.write(''"
  p = np;
 }
}
"'')
    }

    IF $isDeclUsed(Declaration.hasFinish)
      # Called when exiting: Move all objects from usedListF to toFinish
      # and invoke all Finish methods.
      fd.write(''"
void ZgcFinishAll(int rsn) {"'')
      IF $isDeclUsed(%pthread)
        fd.write(''"
 Zohpf *up;
 Zohpf *np;
 for (up = usedListF; up; up = np) {
  if (toFinish == ZOHF_LAST) {
   toFinish = up->firstUsedF;
  } else {
   Zohf *p = toFinish;
   while ((Zohf*)((Tip)p->np & ~3) != ZOHF_LAST) p = (Zohf*)((Tip)p->np & ~3);
   p->np = (Zoh*)up->firstUsedF;
  }
  np = up->next;
  free(up);
 }
 usedListF = NULL;"'')
      ELSE
        fd.write(''"
 if (firstUsedF != ZOHF_LAST) {
  if (toFinish == ZOHF_LAST) {
   toFinish = firstUsedF;
  } else {
   Zohf *p = toFinish;
   while ((Zohf*)((Tip)p->np & ~3) != ZOHF_LAST) p = (Zohf*)((Tip)p->np & ~3);
   p->np = (Zoh*)firstUsedF;
  }
  firstUsedF = ZOHF_LAST;
 }"'')
      }
      fd.write(''"
 ZgcCallFinish(rsn);"'')
      IF $noallocVars != NIL
        # Do this in reverse order, so that it's the same as in Javascript.
        fd.write(''"
 {
  int i = 0;
  while (ZnoallocVars[i].var != NULL) ++i;
  while (--i >= 0) {
   void *p = ZnoallocVars[i].var;
   Tt *type = ZnoallocVars[i].type;
   if (type->nr == 391) ZFinishIobj(p, rsn);
   else if (type->nr == 392) ZFinishXobj(p, rsn);
   else if (type->nr == 390 && ((Tto*)type)->Finish != NULL && ((Zohf*)p)->ff != NULL) ZcallFinish(p, rsn);
  }
 }"'')
      }
      fd.write(''"
}
"'')
    }

    IF $manageMemory() && $isDeclUsed(Declaration.gcRun)
      fd.write(''"
int newMark = 1;

void ZgcGetBlock(Zgcs *gcs) {
 Zgcb *b = malloc(sizeof(Zgcb));
 if (b == NULL) {
  fputs("Out of memory (ZgcGetBlock)\n", stderr);
  fflush(stderr);
  exit(1);
 }
 b->next = gcs->todo;
 gcs->todo = b;
}

#define ADD_ITEM(ap, ato) { \
  if ((ap) != NULL) { \
   void *xp = ap; \
   Tt *xto = ato; \
   while (xto == &iobj__T) { \
    if (((Tr*)xp)->ptr == NULL) { xp = NULL; break; } \
    xto = (Tt*)(((Tr*)xp)->table[0]); \
    xp = ((Tr*)xp)->ptr; \
   } \"'')
          # dyn: get object it refers to.  Can't be an iobject.
          IF $isDeclUsed(Type.aDyn)
            fd.write(''"
   while (xto == &dyn__T) { \
    xto = ((Tx*)xp)->type; \
    if (xto == NULL || xto->nr < 200) { xp = NULL; break; } \
    xp = ((Tx*)xp)->u.ptr; \
    if (xp == NULL) break; \
   } \"'')
          }
          fd.write(''"
   if (xp) { \
    Zoh *anp = ((Zoh *)xp)->np; \
    if (((Tip)anp & 3) != newMark && anp != NULL) { \
     if (xto != NULL && xto->nr >= 300) { \
      if (used == GC_BLOCK_SIZE) { \
       if (b) b->used = GC_BLOCK_SIZE; \
       ZgcGetBlock(gcs); \
       b = gcs->todo; \
       used = 0; \
      } \
      b->items[used].var = (xp); \
      b->items[used].type = (xto); \
      ++used; \
     } \
     ((Zoh *)xp)->np = (Zoh *)(((Tip)anp & ~3) | newMark); \
  }}}}

/* Mark used memory on stack frames and try context for one thread.
 * When "doGlobal" is non-zero also mark global items. */
void ZgcMarkItems(Tn *e, int doGlobal, void *pArg, Tt *toArg) {
 Zgcs *gcs = &"'')
          IF $isDeclUsed(%pthread)
            fd.write("e->")
          }
          fd.write(''"gcStatus;
 Zgcb *b = NULL;
 int used = GC_BLOCK_SIZE;
 int from_b = 0;

 Zsf *frame = "'')
          IF $isDeclUsed(%pthread)
            fd.write("e->")
          }
          fd.write(''"topFrame;
 Zfo *fo = frame == NULL ? NULL : frame->frof;
 int ti = 0;
 int gi = 0;
 int ni = 0;
 int ci = 0;
 void *p = NULL;
 Tt *to;"'')
          # what == 0: mark items on the stack frames
          #            OR: use pArg/toArg and nothing else
          # what == 1: mark items in the try context
          # what == 2: mark items in the exception list
          # what == 3: mark the list of threads
          # what == 4: mark allocated global items
          # what == 5: mark not allocated global items
          # what == 6: mark items in CTX
          fd.write(''"
 int what = 0;
 while (what <= 6) {
  switch (what) {
   case 0:
    if (pArg) {
     what = 99;
     p = pArg;
     to = toArg;
     break;
    }
    if (frame == NULL) ++what;
    else {
     if (!fo) {
      frame = frame->prev;
      if (frame) fo = frame->frof;
     } else {
      if (fo->type == &iobj__T) {
       p = (char *)frame - (fo->off & ~1);
       if (((Tr*)p)->ptr == NULL) p = NULL;
       else to = &iobj__T;"'')
          IF $isDeclUsed(Type.aDyn)
            fd.write(''"
      } else if (fo->type == &dyn__T) {
       p = (char *)frame - fo->off;
       to = &dyn__T;"'')
          }
          fd.write(''"
      } else if (fo->off & 1) {
       p = (char *)frame - (fo->off - 1);
       if (((Zoh*)p)->np == NULL) p = NULL;
       else to = fo->type;
      } else {
       p = *(char **)((char *)frame - fo->off);
       if (p) to = fo->type;
      }
      ++fo;
      if (!fo->off) {
       frame = frame->prev;
       if (frame) fo = frame->frof;
      }
     }
    }
    break;"'')
          IF $isDeclUsed(Declaration.try)
            fd.write(''"
   case 1:
    p = e->tryCtx;
    to = NULL;
    ++what;
    break;
   case 2:
    if (ti >= e->thrownUsed) ++what;
    else {
     p = e->thrown[ti];
     to = (Tt*)((Tj*)p)->mt[0];
     ++ti;
    }
    break;"'')
          ELSE
            fd.write(''"
   case 1: /* no TRY */
    what += 2;
    break;"'')
          }
          fd.write(''"
   case 3:
    if (!doGlobal) what = 99;
    else {"'')
          IF $isDeclUsed(%pthread)
            # The list of thread info is always used. The items themselves are
            # ignored, their type is thread__T.
            fd.write(''"
     p = threads;
     to = &list__T;"'')
          }
          fd.write(''"
     ++what;
    }
    break;
   case 4:
    if (!ZglobalVars[gi].var) {
     ++what;
    } else {
     to = ZglobalVars[gi].type;
     if (to == &iobj__T"'')
          IF $isDeclUsed(Type.aDyn)
            fd.write(" || to == &dyn__T")
          }
          fd.write(''")
      p = ZglobalVars[gi].var;
     else
      p = *((char**)(ZglobalVars[gi].var));
     ++gi;
    }
    break;
   case 5:"'')
          IF $noallocVars == NIL
            fd.write(''"
    ++what;"'')
          ELSE
            fd.write(''"
    if (!ZnoallocVars[ni].var) {
     ++what;
    } else {
     p = (char*)ZnoallocVars[ni].var;
     to = ZnoallocVars[ni].type;
     ++ni;
    }"'')
          }
          fd.write(''"
    break;
   case 6:"'')
          IF !$isDeclUsed(Declaration.usesCtx)
            fd.write(''"
    ++what;"'')
          ELSE
            fd.write(''"
    if (ci == e->ctxUsed) {
     ++what;
    } else {
     p = (char*)&e->ctxArr[ci].obj;
     to = &dyn__T;
     ++ci;
    }"'')
          }
          fd.write(''"
    break;
  }
  from_b = 0;

  while (p) {
   void *ip = NULL;
   Zoh *np;
   if (!from_b) {
    while (to == &iobj__T) {
     if (((Tr*)p)->ptr == NULL) goto p_is_null;
     to = (Tt*)(((Tr*)p)->table[0]);
     p = ((Tr*)p)->ptr;
    }"'')
          # dyn: get object it refers to.  Can't be an iobject.
          IF $isDeclUsed(Type.aDyn)
            fd.write(''"
    while (to == &dyn__T) {
     to = ((Tx*)p)->type;
     if (to == NULL || to->nr < 200) goto p_is_null;
     p = ((Tx*)p)->u.ptr;
     if (p == NULL) goto p_is_null;
    }"'')
          }
          fd.write(''"
   }
   np = ((Zoh *)p)->np;
   if ((from_b || ((Tip)np & 3) != newMark) && np != NULL) {
    if (!from_b) ((Zoh *)p)->np = (Zoh *)(((Tip)np & ~3) | newMark);

    if (to != NULL && to->nr >= 300) {
     if (0) ;
     "'')

         # Array: values
         IF $isDeclUsed(Declaration.array)
           fd.write(''" else if (to == &array__T) {
      Ta *head = (Ta*)p;
      if (head->ptr && head->ptr != head + 1) {
       ip = head->ptr - ZOH_OFF;
       to = NULL;
       if (head->itemType && head->itemType->nr >= 200) {
        Ti i;
        Ti d;
        i = head->size[0];
        for (d = 1; d < head->dim; ++d) i *= head->size[d];
        while (--i >= 0) {
         void *p;
         if (head->itemType == &iobj__T)
          p = (Tr*)head->ptr + i;"'')
          IF $isDeclUsed(Type.aDyn)
            fd.write(''"
         else if (head->itemType == &dyn__T)
          p = (Tx*)head->ptr + i;"'')
          }
          fd.write(''"
         else
          p = ((char **)(head->ptr))[i];
         ADD_ITEM(p, head->itemType)
        }
       }
      }
     }"'')
         }

         # List: values
         IF $isDeclUsed(Declaration.list)
           fd.write(" else if (to == &list__T")
           IF $isDeclUsed(Declaration.defer)
             fd.write(" || to == &defer__T")
           }
           fd.write(''") {
      Tl *head = (Tl*)p;
      if (head->itemType && head->itemType->nr >= 200) {
       if (head->items) {
        Ti n;
        Ti tot = head->empty + head->itemCount;"'')
           IF $isDeclUsed(%pthread)
             fd.write(''"
        if (head->itemType != &thread__T)"'')
           }
           fd.write(''"
         for (n = head->empty; n < tot; ++n) {
          void *p;
          if (head->itemType == &iobj__T)
           p = (Tr*)head->items + n;"'')
           IF $isDeclUsed(Type.aDyn)
             fd.write(''"
          else if (head->itemType == &dyn__T)
           p = (Tx*)head->items + n;"'')
           }
           fd.write(''"
          else
           p = head->items[n];
          ADD_ITEM(p, head->itemType)
         }
       }
      }
      if (head->items && head->items != (void**)(head + 1)) {
       ip = (void*)head->items - ZOH_OFF;
       to = NULL;
      }
     }"'')
         }

         # Dict: keys and values
         IF $isDeclUsed(Declaration.dict)
           fd.write(''" else if (to == &dict__T) {
      Td *head = (Td*)p;
      int dokey = (head->keyType && head->keyType->nr >= 200);
      int doitem = (head->itemType && head->itemType->nr >= 200);
      if (head->array != head->smallArray && head->array) {
       ip = (void*)head->array - ZOH_OFF;
       to = NULL;
      }
      if (dokey || doitem) {
       int todo;
       CDictItem *item;
       todo = (int)head->used;
       for (item = head->array; todo > 0; ++item) {
        if (item->flags & CDI_FLAG_USED) {
         void *pp;
         Tt *pto;
         if (dokey) {
          if (head->keyType == &iobj__T) {
           pp = &item->iokey;
           pto = &iobj__T;"'')
           IF $isDeclUsed(Type.aDyn)
             fd.write(''"
          } else if (head->keyType == &dyn__T) {
           pp = &item->dynkey;
           pto = &dyn__T;"'')
           }
           fd.write(''"
          } else {
           pp = item->key.ptr;
           pto = head->keyType;
          }
          ADD_ITEM(pp, pto)
         }
         if (doitem) {
          if (head->itemType == &iobj__T) {
           pp = &item->ioitem;
           pto = &iobj__T;"'')
           IF $isDeclUsed(Type.aDyn)
             fd.write(''"
          } else if (head->itemType == &dyn__T) {
           pp = &item->dynitem;
           pto = &dyn__T;"'')
           }
           fd.write(''"
          } else {
           pp = item->item.ptr;
           pto = head->itemType;
          }
          ADD_ITEM(pp, pto)
         }
         --todo;
        }
       }
      }
     }"'')
         }

         # varByteString has members
         IF $isDeclUsed(Declaration.varString)
                                     || $isDeclUsed(Declaration.varByteString)
           fd.write(''" else if (to == &varString__T || to == &varByteString__T) {
      Ty *r = (Ty*)p;
      if (r->data) {
       ip = r->data;
       to = NULL;
      }
      /* TODO: more? */
     }"'')
         }

         IF $isDeclUsed(Declaration.funcRef)
           # Callback.
           fd.write(''" else if (to == &cb__T) {
      int i;
      Tcbx *r = (Tcbx*)p;
      if (r->toCount >= 0) {
       ip = r->cb;
       to = &cb__T;
       for (i = 0; i < r->toCount; ++i) {
        void *pp = *(char**)((char*)r + r->to[i].off);
        ADD_ITEM(pp, r->to[i].type)
       }
      }
     }"'')
         }

         # Normal object: use list of members.
         # When it's an xobject the type is in "mt[0]".
         fd.write(''" else {
      int i;
      To *tto;
      if (to == &xobj__T) to = (Tt*)((Tj*)p)->mt[0];
      tto = ((Tto*)to)->to;
      for (i = 1; i <= tto->off; ++i)"'')
         IF $isDeclUsed(Declaration.itemToString)
           fd.write(''"
       if (tto[i].type->nr >= 200)"'')
         }
         fd.write(''" {
        void *pp;
        if (tto[i].type == &iobj__T"'')
         IF $isDeclUsed(Type.aDyn)
           fd.write(" || tto[i].type == &dyn__T")
         }
         fd.write(''")
         pp = (char*)p + tto[i].off;
        else
         pp = *(char**)((char*)p + tto[i].off);
        ADD_ITEM(pp, tto[i].type)
       }
     }
    }
   }
"'')
          # When "ip" is not NULL: Marking this one item with type "to".
          # Otherwise: get an item to mark from "b" or "b->next".
          fd.write(''"
p_is_null:
   if (ip) {
    p = ip;
    from_b = 0;
   } else if (b && used > 0) {
    --used;
    p = b->items[used].var;
    to = b->items[used].type;
    from_b = 1;
   } else if (b) {
    gcs->todo = b->next;
    b->next = gcs->empty;
    gcs->empty = b;
    b = gcs->todo;
    if (b) {
     used = b->used - 1;
     p = b->items[used].var;
     to = b->items[used].type;
     from_b = 1;
    } else {
     used = GC_BLOCK_SIZE;
     p = NULL;
    }
   } else p = NULL;
  }
 }

 while (gcs->empty) {
  b = gcs->empty->next;
  free(gcs->empty);
  gcs->empty = b;
 }
}
#undef ADD_ITEM"'')

          IF $isDeclUsed(Declaration.hasFinish)
            # Move unmarked items from "p" to "toFinish" if they have an
            # executable Finish() method.
            fd.write(''"
Zohf *ZgcCheckFinish(Zohf *firstUsedF) {
 Zohf *prev = NULL;
 Zohf *p = firstUsedF;
 Zohf *newFirstUsedF = firstUsedF;
 Zoh *np;
 Zohf *rp;
 while (p != ZOHF_LAST) {
  np = p->np;
  rp = (Zohf*)((Tip)np & ~3);
  if (((Tip)np & 3) != newMark && (((Zohf *)p)->fok & FOK_OK) == 0) {
   if (prev) prev->np = (Zoh*)(((Tip)prev->np & 3) | (Tip)rp);
   else newFirstUsedF = rp;
   p->np = (Zoh*)toFinish;
   toFinish = p;
  } else {
   prev = p;
  }
  p = rp;
 }
 return newFirstUsedF;
}
"'')
            # Mark items in toFinish as used, except the item itself.
            fd.write(''"
void ZgcFinishMark(Tn *e) {
 Zohf *p = toFinish;
 while (p != ZOHF_LAST) {
  To *to = p->to;
  int i;
  for (i = 1; i <= to->off; ++i)"'')
            IF $isDeclUsed(Declaration.itemToString)
              fd.write(''"
   if (to[i].type->nr >= 200)"'')
            }
            fd.write(''"
   {
    void *pp = *(char**)((char*)p + to[i].off);
    ZgcMarkItems(e, 0, pp, to[i].type);
   }
  p = (Zohf*)((Tip)(p->np) & ~3);
 }
}
"'')
            # Find an unmarked item in toFinish.  If there is one, move all
            # the marked items back to usedListF/firstUsedF.
            fd.write(''"
void ZgcFinishMoveBack() {
 Zohf *p = toFinish;
 while (p != ZOHF_LAST) {
  if (((Tip)p->np & 3) != newMark) break;
  p = (Zohf*)((Tip)(p->np) & ~3);
 }
 if (p != ZOHF_LAST) {
  Zohf *np;
  Zohf *prev = NULL;
  p = toFinish;
  while (p != ZOHF_LAST) {
   np = (Zohf*)((Tip)(p->np) & ~3);
   if (((Tip)p->np & 3) == newMark) {"'')
             IF $isDeclUsed(%pthread)
               fd.write(''"
    if (usedListF == NULL) {
     usedListF = ZaNmi(sizeof(Zohpf));
     usedListF->firstUsedF = ZOHF_LAST;
    }
    p->np = (Zoh*)((Tip)usedListF->firstUsedF | newMark);
    usedListF->firstUsedF = p;"'')
             ELSE
               fd.write(''"
    p->np = (Zoh*)((Tip)firstUsedF | newMark);
    firstUsedF = p;"'')
             }
             fd.write(''"
    if (prev) {
     prev->np = (Zoh*)((Tip)np | ((Tip)(prev->np) & 3));
    } else {
     toFinish = np;
    }
   } else {
    prev = p;
   }
   p = np;
  }
 }
}
"'')
            # Call ZgcCheckFinishList() for all entries in usedListF.
            # Then mark all entries in toFinish.
            # Then move some entries back from toFinish to usedListF.
            IF $isDeclUsed(%pthread)
              fd.write(''"
void ZgcCheckFinishList(Tn *e) {
 Zohpf *prevUsed = NULL;
 Zohpf *p;
 Zohpf *np;
 for (p = usedListF; p; p = np) {
  p->firstUsedF = ZgcCheckFinish(p->firstUsedF);
  np = p->next;
  if (p->firstUsedF == ZOHF_LAST) {
   if (prevUsed == NULL) {
    usedListF = p->next;
   } else {
    prevUsed->next = p->next;
   }
   free(p);
  } else {
   prevUsed = p;
  }
 }
}
"'')
            }
          }

          fd.write(''"
/* free unmarked memory */
Zoh *ZgcFree(Zoh *firstUsed) {
 Zoh *prev = NULL;
 Zoh *p = firstUsed;
 Zoh *newFirstUsed = firstUsed;
 Zoh *np;
 while (p != &Zlast) {
  np = p->np;
  if (((Tip)np & 3) != newMark) {
   np = (Zoh*)((Tip)np & ~3);
   newFirstUsed = np;
   ++ZgcFreeCount;
   free(p);
   p = np;
  } else {
   prev = p;
   p = (Zoh*)((Tip)np & ~3);
   break;
  }
 }
 while (p != &Zlast) {
  np = p->np;
  if (((Tip)np & 3) != newMark) {
   np = (Zoh*)((Tip)np & ~3);
   prev->np = np;
   ++ZgcFreeCount;
   free(p);
   p = np;
  } else {
   prev = p;
   p = (Zoh*)((Tip)np & ~3);
  }
 }
 return newFirstUsed;
}
"'')

      string current = DeclStore.getPName("MTIMEModule", "Fcurrent")
      IF $isDeclUsed(%pthread)
        fd.write(''"
void ZgcFreeList(Zohp **listp) {
 Zohp *prevUsed = NULL;
 Zohp *p;
 Zohp *np;
 Zohp *first;
 pthread_mutex_lock(&usedListMutex);
 first = *listp;
 *listp = NULL;
 pthread_mutex_unlock(&usedListMutex);
 for (p = first; p; p = np) {
  p->firstUsed = ZgcFree(p->firstUsed);
  np = p->next;
  if (p->firstUsed == &Zlast) {
   if (prevUsed == NULL) {
    first = p->next;
   } else {
    prevUsed->next = p->next;
   }
   free(p);
  } else {
   prevUsed = p;
  }
 }
 pthread_mutex_lock(&usedListMutex);
 if (*listp == NULL) {
  *listp = first;
 } else {
  for (p = *listp; p->next; p = p->next)
   ;
  p->next = first;
 }
 pthread_mutex_unlock(&usedListMutex);
}
"'')
        # The following is tricky, because of the mutexes:
        # - Lock threadsMutex while going through the "threads" list, but
        #   unlock it when waiting.
        # - Threads may exit while waiting. Use pthread_kill() to check if a
        #   thread still exists. Ignore threads with "finished" set.
        # - Threads may be created while waiting.
        #
        # The inGC flags is used to avoid doing this recursively.  Avoids
        # trying to run the GC on exit when the GC caused an exception.
        fd.write(''"
void ZgcLinkedRun() {
 Tn *e = ZgetEnv();
 int i;
 struct timeval tv;
 struct timespec ts;
 Zsf sf={0x40000000,e->topFrame"'' .. ($hasNpField() ? ",NULL" : "") .. ''"};

 if (e->inGC) return;
 e->inGC = 1;"'')
        fd.write(''"
 e->topFrame = &sf;
"'')
        # 1: Wait for any other GC run to finish.
        fd.write(''"
 pthread_mutex_lock(&gcRunMutex);
"'')
        # 2: Signal threads, get them to GC_STOPPED state: "stop-the-world"
        # start.
        # Note that MingW does not support pthread_kill() with a non-zero
        # signal.
        fd.write(''"
 pthread_mutex_lock(&threadsMutex);
 gcSTW = 1;
 for (i = 0; i < threads->itemCount; ++i) {
  Tn *ie = ZListGetPtr(threads, i);
  if (ie != e && !ie->finished) {
   if (pthread_kill(ie->tid, GC_SIG) == ESRCH) {
    // thread must have died
    ie->finished = 1;
   }
   ie->timedOut = 0;
  }
 }
 pthread_mutex_unlock(&threadsMutex);
"'')
        # 3: Wait for all threads to be in GC_STOPPED state.
        #    After a 10 msec timeout send the signal again to force it calling
        #    ZthreadGC().
        fd.write(''"
 gettimeofday(&tv, NULL);
 ts.tv_sec = tv.tv_sec;
 ts.tv_nsec = tv.tv_usec * 1000 + 10000000; /* 10 msec later */
 if (ts.tv_nsec >= 1000000000L) {
  ts.tv_nsec -= 1000000000L;
  ++ts.tv_sec;
 }
 pthread_mutex_lock(&threadsMutex);
 for (i = 0; i < threads->itemCount; ++i) {
  Tn *ie = ZListGetPtr(threads, i);
  if (ie != e && !ie->finished) {
   pthread_mutex_lock(&ie->stateMutex);
   if (ie->state != GC_STOPPED) {
    if (pthread_kill(ie->tid, 0) == ESRCH) {
     ie->finished = 1;
    } else {
     pthread_mutex_unlock(&threadsMutex);
     i = -1; // start over, "threads" may change
     if (!ie->timedOut) {
      if (pthread_cond_timedwait(&ie->stateCond, &ie->stateMutex, &ts) == ETIMEDOUT) {
       ie->timedOut = 1;
       if (pthread_kill(ie->tid, GC_SIG) == ESRCH) {
        // thread must have died
        ie->finished = 1;
       }
      }
     } else {
      pthread_cond_wait(&ie->stateCond, &ie->stateMutex);
     }
     pthread_mutex_lock(&threadsMutex);
    }
   }
   pthread_mutex_unlock(&ie->stateMutex);
  }
 }
 pthread_mutex_unlock(&threadsMutex);
"'')
        # 4: Start mark phase.
        fd.write(''"
 ZgcMarkTime = "'' .. current .. ''"();
 ZgcStwTime = "'' .. current .. ''"();
 newMark = newMark == 1 ? 2 : 1;
 pthread_mutex_lock(&gcMarkPhaseMutex);
 gcMarkPhase = 1;
 pthread_cond_broadcast(&gcMarkPhaseCond);
 pthread_mutex_unlock(&gcMarkPhaseMutex);
"'')
        # 5: Mark used items in globals and in this thread.
        fd.write(''"
 ZgcMarkItems(e, 1, NULL, NULL);
"'')
        # 6: Wait for all threads to be in GC_MARK_DONE state.
        fd.write(''"
 pthread_mutex_lock(&threadsMutex);
 for (i = 0; i < threads->itemCount; ++i) {
  Tn *ie = ZListGetPtr(threads, i);
  if (ie != e && !ie->finished) {
   pthread_mutex_lock(&ie->stateMutex);
   while (ie->state == GC_STOPPED) pthread_cond_wait(&ie->stateCond, &ie->stateMutex);
   pthread_mutex_unlock(&ie->stateMutex);
  }
 }
 ZgcMarkTime = "'' .. current .. ''"() - ZgcMarkTime;
"'')
        # 7: Move list of used items from all threads to usedList and
        # usedListF.
        fd.write(''"
 for (i = 0; i < threads->itemCount; ++i) {
  Tn *ie = ZListGetPtr(threads, i);
  if (ie->firstUsed != &Zlast) {
   Zohp *entry = ZaNmi(sizeof(Zohp));
   entry->next = usedList;
   usedList = entry;
   entry->firstUsed = ie->firstUsed;
   ie->firstUsed = &Zlast;
  }"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
  if (ie->firstUsedF != ZOHF_LAST) {
   Zohpf *entry = ZaNmi(sizeof(Zohp));
   entry->next = usedListF;
   usedListF = entry;
   entry->firstUsedF = ie->firstUsedF;
   ie->firstUsedF = ZOHF_LAST;
  }"'')
        }
        fd.write(''"
 }
 pthread_mutex_unlock(&threadsMutex);
"'')

        IF $isDeclUsed(Declaration.hasFinish)
          # 8: Find Finish methods that need to be called.
          fd.write(''"
 ZgcCheckFinishList(e);
 ZgcFinishMark(e);
 ZgcFinishMoveBack();
"'')
        }

        # 9: End mark phase, tell all threads to continue: "stop-the-world"
        # ends.
        fd.write(''"
 pthread_mutex_lock(&gcMarkPhaseMutex);
 gcMarkPhase = 0;
 gcSTW = 0;
 pthread_cond_broadcast(&gcMarkPhaseCond);
 pthread_mutex_unlock(&gcMarkPhaseMutex);
 ZgcStwTime = "'' .. current .. ''"() - ZgcStwTime;
"'')
        # 10: Free unused items from "usedList" and "usedListF".
        fd.write(''"
 ZgcFreeCount = 0;
 ZgcFreeTime = "'' .. current .. ''"();
 ZgcFreeList(&usedList);"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 ZgcFreeList((Zohp**)&usedListF);"'')
        }
        fd.write(''"
 ZgcFreeTime = "'' .. current .. ''"() - ZgcFreeTime;
 ZgcUseCount -= ZgcFreeCount;"'')

        IF $isDeclUsed(Declaration.hasFinish)
          # 11: Invoke Finish methods.
          fd.write(''"
 ZgcFinishTime = "'' .. current .. ''"();
 ZgcCallFinish(0);
 ZgcFinishTime = "'' .. current .. ''"() - ZgcFinishTime;"'')
        }

        # 12: Done.
        fd.write(''"
 e->topFrame = sf.prev;
 pthread_mutex_unlock(&gcRunMutex);
 e->inGC = 0;
}
"'')

      ELSE
        # When not using threads.
        fd.write(''"
void ZgcLinkedRun() {
 ZgcMarkTime = "'' .. current .. ''"();
 newMark = newMark == 1 ? 2 : 1;
 ZgcMarkItems(&Zenv, 1, NULL, NULL);"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 firstUsedF = ZgcCheckFinish(firstUsedF);
 ZgcFinishMark(&Zenv);
 ZgcFinishMoveBack();"'')
        }
        fd.write(''"
 ZgcMarkTime = "'' .. current .. ''"() - ZgcMarkTime;
"'')
        # Free unused items from "firstUsed" and "firstUsedF".
        fd.write(''"
 ZgcFreeCount = 0;
 ZgcFreeTime = "'' .. current .. ''"();
 firstUsed = ZgcFree(firstUsed);"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 firstUsedF = (Zohf*)ZgcFree((Zoh*)firstUsedF);"'')
        }
        fd.write(''"
 ZgcFreeTime = "'' .. current .. ''"() - ZgcFreeTime;
 ZgcUseCount -= ZgcFreeCount;
 ZgcStwTime = ZgcMarkTime + ZgcFreeTime;"'')
        IF $isDeclUsed(Declaration.hasFinish)
          # Invoke Finish methods.
          fd.write(''"
 ZgcFinishTime = "'' .. current .. ''"();
 ZgcCallFinish(0);
 ZgcFinishTime = "'' .. current .. ''"() - ZgcFinishTime;"'')
        }
        fd.write(''"
}
"'')
      }
    }

    # Create a new string or byteString for "len" bytes and return it.
    # Store the length in varint encoding and point "*pp" to just after it.
    fd.write(''"
Tc *ZnewStringInit(Ti len, Tc **pp) {
 Ti rlen = len;
 int i;
 int n = ZOH_OFF;
 Tc buf[20];
 Tc *res;
 buf[0] = (rlen & 127);
 rlen >>= 7;
 for (i = 1; rlen > 0; ++i)
 {
  buf[i] = (rlen & 127) + 128;
  rlen >>= 7;
 }
 res = Za(ZOH_OFF + len + i + 1);
 while (i > 0) res[n++] = buf[--i];
 *pp = res + n;
 return res;
}
"'')

    # Create a new string or byteString and copy p[len] into it.
    # Always needed, used for argv[0].
    fd.write(''"
Tc *ZnewString(Tc *p, Ti len) {
 Tc *pp;
 Tc *res = ZnewStringInit(len, &pp);
 memmove(pp, p, len);
 return res;
}
"'')

    # Make a list of file names and methods, so that we need to specify each
    # one only once.
    FOR fname IN CodeTable.files.keys().sort()
      fd.write("Tc " .. CodeTable.files[fname]
                                      .. "[]=\"" .. fname.escape() .. "\";\n")
    }
    FOR text IN CodeTable.methods.keys().sort()
      FOR method IN CodeTable.methods[text]
        fd.write("Tc " .. method.id .. "[]=\"" .. text.escape() .. "\";\n")
        FOR offset IN method.entries.keys().sort()
          fd.write("Tcpos ZcTbl" .. offset)
          fd.write("[]={\n")
          int off
          FOR pos IN method.entries[offset]
            IF pos == NIL
              fd.write("{NULL," .. method.id .. ",0,0},\n")
            ELSE
              IF off == 0
                fd.write("{" .. pos.lnum)
                off = pos.lnum
              ELSE
                fd.write("{" .. pos.lnum - off)
              }
              fd.write("," .. pos.col)
              fd.write("},\n")
            }
          }
          fd.write("};\n")
        }
      }
    }

    fd.write("Tcode ZcodeTable[]={\n")
    FOR offset IN CodeTable.usedOffsets.keys().sort()
      CodeTable.Method method = CodeTable.usedOffsets[offset]
      fd.write("{" .. offset)
      fd.write(",")
      fd.write(method.fileId)
      fd.write(",")
      fd.write(method.id)
      fd.write(",ZcTbl" .. offset)
      fd.write("},\n")
    }
    fd.write("};\n")

    fd.write(''"
#ifdef SIGSEGV
void Zdeadly(int nr) {
 ZthrowDeadly(nr);
}
#endif
"'')

    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      # Upon receiving the GC_SIG signal ZwantGC is called. At a safe point
      # ZthreadGC() will be called.  When a second signal arrives, call
      # ZthreadGC() right away (assume the code is in a busy loop).
      #
      # The safe point is when the stack frame position does not have the
      # "UNSAFE" bit set: 0x40000000. This bit is set just before calling an
      # unsafe function.  The called function will then check the wantGC flag
      # after it resets the "UNSAFE" bit. This is when it is sure its stack
      # frame and all arguments are referenced.
      #
      # The UNSAFE bit in "pos" must be set before entering unsafe code,
      # otherwise a deadlock may result.  E.g.:
      # 1. thread is inside malloc(), holding lock to global memory pool
      # 2. signal arrives, starts GC
      # 3. GC methods allocate memory, call malloc(), obtaining global memory
      #    pool lock results in deadlock.
      # To set the UNSAFE bit call $writeBeforeUnsafe() and call
      # $writeAfterUnsafe() afterwards.
      #
      # MT-GC: stands for Multi Threaded Garbage Collection
      #
      # Unsafe code and functions is where executing the GC may cause used
      # memory to be freed and/or a deadlock may occur.  This is when:
      # - Allocating of freeing memory (malloc() and free()), these may use
      #   locks and must not be interrupted with any other code that allocates
      #   or frees memory.
      # - Where pointers are not referenced. This can be the function
      #   arguments and the function return value.
      # User functions are always assumed to be unsafe.
      # For internal functions a comment with "MT-GC" is added.
      # When --exitclean is specified many of the unsafe functions will throw
      # an exception if called without the UNSAFE bit set.
      fd.write(''"
void ZwantGC(int nr) {
 Tn *e = ZgetEnv();
 if (e->wantGC || e->finished || e->topFrame == NULL || (e->topFrame->pos & 0x40000000) == 0) ZthreadGC();
 else e->wantGC = 1;
}
void ZthreadGC() {
 Tn *e = ZgetEnv();
 if (e->inGC) return;
 e->inGC = 1;
 e->wantGC = 0;

 // Let GC thread know we are waiting.
 pthread_mutex_lock(&e->stateMutex);
 e->state = GC_STOPPED;
 pthread_cond_broadcast(&e->stateCond);
 pthread_mutex_unlock(&e->stateMutex);

 // Wait for mark phase to start.
 pthread_mutex_lock(&gcMarkPhaseMutex);
 while (!gcMarkPhase) pthread_cond_wait(&gcMarkPhaseCond, &gcMarkPhaseMutex);
 pthread_mutex_unlock(&gcMarkPhaseMutex);

 // Mark items on the stack.
 ZgcMarkItems(e, 0, NULL, NULL);

 // Let GC thread know we are done.
 pthread_mutex_lock(&e->stateMutex);
 e->state = GC_MARK_DONE;
 pthread_cond_broadcast(&e->stateCond);
 pthread_mutex_unlock(&e->stateMutex);

 // Wait for end of mark phase.
 pthread_mutex_lock(&gcMarkPhaseMutex);
 while (gcMarkPhase) pthread_cond_wait(&gcMarkPhaseCond, &gcMarkPhaseMutex);
 pthread_mutex_unlock(&gcMarkPhaseMutex);

 e->inGC = 0;
}
"'')
    ELSE
      # Dummy function for when GC.run() is not used.  Needed because
      # lib/THREADModule.zu uses it without an #ifdef.
      fd.write(''"
void ZthreadGC() {
}"'')
    }

    # This is always generated, it's used in IO.write()
    # Return size in bytes of |s| and set |dp| to first value byte.
    fd.write(''"
Ti ZstringSizePtr(Tc *s, Tc **dp) {
 Tc *p;
 Ti len;
 p = s + ZOH_OFF;
 if ((*p & 0x80) == 0) {  /* be quick for short string */
  *dp = p + 1;
  return *p;
 }
 len = *p & 0x7f;
 ++p;
 while ((*p & 0x80) != 0) {
  len = (len << 7) + (*p & 0x7f);
  ++p;
 }
 *dp = p + 1;
 return (len << 7) + *p;
}
"'')

    # Write code fragments that were marked as used.
    FOR writer IN codeWriters
      IF writer.produce != NIL && writer.isUsed(THIS)
        writer.produce(THIS, fd)
      }
    }

    # Array type
    WriteArrayC.writeBody(THIS, fd)

    # List type
    WriteListC.writeBody(THIS, fd)

    # Dict type
    WriteDictC.writeBody(THIS, fd)

    IF $isDeclUsed(Declaration.typeToString)
      # This code uses TYPE_NUMBERS, keep in sync!
      # TODO: class name, container item/key and typedef items.
      fd.write(''"
Tc *Ztype2string(Tt *type) {
 char *s;
 if (type == NULL) s = "[unknown]";
 else switch (type->nr) {
  case 0: s = "int"; break;
  case 1: s = "int8"; break;
  case 2: s = "int16"; break;
  case 3: s = "int32"; break;
  case 10: s = "nat"; break;
  case 11: s = "byte"; break;
  case 12: s = "nat16"; break;
  case 13: s = "nat32"; break;

  case 21: s = "bool"; break;
  case 22: s = "status"; break;
  case 23: return ZcS(Zstr("enum "), type->name);
  case 24: return ZcS(Zstr("module "), type->name);
  case 25: return ZcS(Zstr("bits "), type->name);

  case 80: s = "float"; break;
  case 81: s = "float32"; break;
  case 82: s = "float80"; break;
  case 83: s = "float128"; break;

  case 101: s = "type"; break;

  case 200: s = "string"; break;
  case 201: s = "byteString"; break;

  case 300: return type->name;
  case 301: return type->name;
  case 302: return type->name;

  case 310: s = "varString"; break;
  case 311: s = "varByteString"; break;

  case 320: return type->name;

  case 330: s = "proc/func"; break;

  case 360: s = "dyn"; break;

  case 390: return ZcS(Zstr("object of "), type->name);
  case 391: s = "iobject"; break;
  case 392: s = "xobject"; break;

  default: s = "[unknown]";
 }
 return Zstr(s);
}
"'')
    }

    IF $isDeclUsed(Declaration.typeNameFunc)
      # TODO: class name, container item/key and typedef items.
      fd.write(''"
Tc *ZtypeName(Tt *type) {
 if (type == NULL) return Zstr("NIL");
 return type->name;
}
"'')
    }

    # Write bodies for libraries.
    FOR p IN bodyWriters
      p(THIS, fd)
    }
  }

  # When compiling with --exitclean verify that an unsafe function is called
  # with the UNSAFE bit set.  If not then cause a SIGSEGV.
  PROC $checkUnsafeFunc(IO.File fd)
    IF ManageMemory.isExitclean() && $manageMemory()
      IF $isDeclUsed(%pthread)
        fd.write(''"
 if (ZgetEnv()->topFrame != NULL && (ZgetEnv()->topFrame->pos & 0x40000000) == 0)"'')
      ELSE
        fd.write(''"
 if (topFrame != NULL && (topFrame->pos & 0x40000000) == 0)"'')
      }
      fd.write(''"
  ZreportUnsafe();"'')
    }
  }

  # Function to write a memory allocation function |name|.
  # |linkName| is the list where the allocated block should be linked in.
  # When NIL it is not put in any list.
  # MT-GC: This is an unsafe call, because the allocated memory will not be
  # referenced while returning.
  PROC $writeAllocFunc(string name, bool hasFinish, bool hasMt,
                                                  string linkName, IO.File fd)
    fd.write(''"
/* allocate memory */
void *"'')
    fd.write(name)
    fd.write("(size_t size")
    IF hasFinish
      fd.write(", To *to, Ts (*ff)(void *, Te), int nox, Tc **mt")
    ELSEIF hasMt
      fd.write(", Tc **mt")
    }
    fd.write(''") {
 void *p = NULL;"'')
    IF $isDeclUsed(%pthread)
      fd.write(''"
 Tn *e = "'' .. $getEnvCode() .. ''";"'')
    }
    $checkUnsafeFunc(fd)
    # There could be a crash inside calloc(), in which case we get back here
    # when throwing the exception and run into a deadlock.  Better use the
    # emergency alloc then.
    IF $isDeclUsed(%pthread)
      fd.write(''"
 if (!e->inZa) {
  e->inZa = 1;
  p = calloc(1, size);
  e->inZa = 0;
 }
 if (p == NULL) {
  if (e->inZa || e->ZaEntered) {"'')
    ELSE
      fd.write(''"
 if (!inZa) {
  inZa = 1;
  p = calloc(1, size);
  inZa = 0;
 }
 if (p == NULL) {
  if (inZa || ZaEntered) {"'')
    }
    fd.write(''"
   if ("'' .. emergencyAllocSize .. ''" - emergencyAllocUsed >= size) {
    p = emergencyAlloc + emergencyAllocUsed;
    emergencyAllocUsed += size;
    goto end;
   }
   fprintf(stderr, "Out of memory "'' .. name .. ''"(%ld)\n", (long)size);
   fflush(stderr);
   exit(1);
  }"'')
    IF $isDeclUsed(%pthread)
      fd.write(''"
  ++e->ZaEntered;
  ZthrowOutOfMemory(size);
 }
 e->ZaEntered = 0;"'')
    ELSE
      fd.write(''"
  ++ZaEntered;
  ZthrowOutOfMemory(size);
 }
 ZaEntered = 0;"'')
    }
    IF linkName != NIL && (hasFinish ? $hasNpField() : $manageMemory())
      fd.write(''"
 ((Zoh *)p)->np = (Zoh*)"'')
      IF $isDeclUsed(%pthread)
        fd.write("e->")
      }
      fd.write(linkName)
      fd.write(''";
 "'')
      IF $isDeclUsed(%pthread)
        fd.write("e->")
      }
      fd.write(linkName)
      fd.write(''" = p;"'')
      IF $manageMemory() && $isDeclUsed(Declaration.gcRun)
        fd.write(''"
 ++ZgcUseCount;"'')
      }
    }
    IF Config.profalloc
      fd.write(''"
 ZprofallocCount(size);"'')
    }
    fd.write(''"
end:"'')
    IF hasFinish
      fd.write(''"
 ((Zohf *)p)->mt = mt;
 ((Zohf *)p)->to = to;
 ((Zohf *)p)->ff = ff;
 if (nox) ((Zohf *)p)->fok = FOK_NOX;"'')
    ELSEIF hasMt
      fd.write(''"
 ((Tj *)p)->mt = mt;"'')
    }
    fd.write(''"
 return p;
}
"'')
  }


  # Write declaration used by $writeBeforeUnsafe().
  PROC $writeDeclForUnsafe(IO.File fd, bool envToo)
    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      IF (envToo)
        fd.write(''"
 Tn *e = ZgetEnv();"'')
      }
      fd.write(''"
 int sp;"'')
    }
  }

  # Write code before doing an operation that can't be interrupted by
  # the garbage collector in a signal handler.
  PROC $writeBeforeUnsafe(IO.File fd)
    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      fd.write(''"
 if (e->topFrame != NULL) {
  sp = e->topFrame->pos;
  e->topFrame->pos = 0x40000000;
 }"'')
    }
  }

  # Write code after doing an operation that writeBeforeUnsafe() was called
  # for.
  PROC $writeAfterUnsafe(IO.File fd)
    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      fd.write(''"
 if (e->topFrame != NULL) {
  e->topFrame->pos = sp;
  if (e->wantGC && (e->topFrame->pos & 0x40000000) == 0) ZthreadGC();
 }"'')
    }
  }

  # Write the preperation of the stack frame for a built-in function.
  PROC $stackFrameLead(string foName, IO.File fd)
    string foPart
    IF $hasNpField()
      foPart = "," .. foName
    ELSE
      foPart = ""
    }
    fd.write(''"
 Zsf sf={0x40000000,"'' .. $topFrameName() .. foPart .. ''"};
 static int sfF = 0;
 if (!sfF) {
  sfF = 1;"'')
  }

  # Write the preperation of the stack frame for a built-in function.
  PROC $stackFrameFoot(IO.File fd)
    fd.write(''"
 }
 "'' .. $topFrameName() .. ''" = &sf;"'')
  }

  # Write the restore of the stack frame for a built-in function.
  PROC $stackFrameEnd(IO.File fd)
    fd.write("\n ")
    fd.write($topFrameName())
    fd.write(" = sf.prev;")
  }

  FUNC $topFrameName() string
    IF $isDeclUsed(%pthread)
      RETURN "e->topFrame"
    }
    RETURN "topFrame"
  }

  # Write calling test methods to mainOut
  PROC $writeTestMethods(Output.Group outputs)
    IF $testMethods.size() == 0
      LOG.error("No test methods found")
    }

    SContext ctx = NEW(NIL, THIS, outputs)
    $mainHead(NIL, ctx)
    ctx.out.write(" int r = 1;\n")
    ctx.out.write(" int t;\n")

    string runTest = DeclStore.getPName("MTESTModule", "FrunTest")
    string report = DeclStore.getPName("MTESTModule", "Freport")
    FOR ftm IN $testMethods
      string setUp = ftm.setUp == NIL ? "NULL" : "(Tc*)\(ftm.setUp.pName)"
      string tearDown = ftm.tearDown == NIL ? "NULL" : "(Tc*)\(ftm.tearDown.pName)"
      FOR tup IN ftm.testMethodsList
        ctx.out.write(" t = \(runTest)((Tc*)&\(ftm.filePname), (Tc*)&\(tup[1]), (Tcb*)\(tup[0].pName), \(setUp), \(tearDown));\n")
        ctx.out.write(" r = r && t;\n")
      }
    }

    ctx.out.write(" \(report)(r);\n")
    ctx.out.write(" return !r;\n")
    $mainEnd(ctx)
  }


  SHARED

    # Offset to the position index to indicate a function call will follow.
    int pauseGCOffset = 0x4000'0000  # 0x40000000

    string linkedDecl = " Zoh *np;\n"
    string memberTableDecl = " Tc **mt;\n"
    string finishDecl = " int fok;\n To* to;\n Ts (*ff)(void *, Te);\n"

    # Enough space for a stack trace of 30 entries (hopefully).
    int emergencyAllocSize = 16384

    list<CodeWriter> codeWriters

    PROC initCodeWriters()
      # Initialize |codeWriters| with all the code fragments we can write.
      # This keeps all the dependencies, typedefs and structure declarations
      # in one place.
      # Order matters: functions which are written without a declaration need
      # to be written before they are used.

      codeWriters.add(NEW(Declaration.gcRun,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZgcRun() {"'')
        IF gen.manageMemory()
          fd.write(''"
 ZgcLinkedRun();"'')
        }
        fd.write(''"
}
"'')
        }))

      codeWriters.add(NEW(Declaration.throwString,
        PROC (WriteC gen, IO.File fd)
          string throwExcept = DeclStore.getPName("MEModule", "FcreateException")
          fd.write(''"
void *ZstringEx(Ti pos, Tc *text) {
 return "'' .. throwExcept .. ''"(pos, text);
}
"'')
        }).setDependencies([["MEModule", "FcreateException"]]))

      codeWriters.add(NEW(Declaration.throwCstringNil,
                                                 PROC (WriteC gen, IO.File fd)
        string throwNil = DeclStore.getPName("MEModule", "FthrowNil")
        fd.write(''"
void ZthrowCstringNil(char *text) {
 "'' .. throwNil .. ''"(NULL, Zstr(text));
}
"'')
      }).setDependencies([["MEModule", "FthrowNil"]])
        .setDecl("void ZthrowCstringNil(char *text);"))

      codeWriters.add(NEW(Declaration.throwThisNil,
                                                 PROC (WriteC gen, IO.File fd)
        string throwNil = DeclStore.getPName("MEModule", "FthrowNil")
        fd.write(''"
void ZthrowThisNil() {
 "'' .. throwNil .. ''"(NULL, Zstr("THIS is NIL"));
}
"'')
      }).setDependencies([["MEModule", "FthrowNil"]]))

      codeWriters.add(NEW(Declaration.throwCstringInit,
                                                 PROC (WriteC gen, IO.File fd)
        string throwInit = DeclStore.getPName("MEModule", "FthrowInit")
        fd.write(''"
void ZthrowCstringInit(char *text) {
 "'' .. throwInit .. ''"(Zstr(text));
}
"'')
      }).setDependencies([["MEModule", "FthrowInit"]]))

      codeWriters.add(NEW(Declaration.throwOutOfMemory,
                                                 PROC (WriteC gen, IO.File fd)
        string throwOutOfMem =
                       DeclStore.getPName("MEModule", "FthrowOutOfMemorySize")
        fd.write(''"
void ZthrowOutOfMemory(Ti size) {
 "'' .. throwOutOfMem .. ''"(size);
}
"'')
      }).setDependencies([["MEModule", "FthrowOutOfMemorySize"]]))

      codeWriters.add(NEW(Declaration.throwOutOfRange,
                                                 PROC (WriteC gen, IO.File fd)
        string throwOutOfRange =
                            DeclStore.getPName("MEModule", "FthrowOutOfRange")
        fd.write(''"
void ZthrowCstringOutOfRange(Ti i, char *text) {
 "'' .. throwOutOfRange .. ''"(i, Zstr(text));
}
"'')
      }).setDependencies([["MEModule", "FthrowOutOfRange"]]))

      codeWriters.add(NEW(Declaration.throwCstringBadValue,
        PROC (WriteC gen, IO.File fd)
          string throwBadValue = DeclStore.getPName("MEModule", "FthrowBadValue")
          fd.write(''"
void ZthrowCstringBadValue(char *msg) {
 "'' .. throwBadValue .. ''"(Zstr(msg));
}
"'')
        }).setDependencies([["MEModule", "FthrowBadValue"]])
          .setDecl("void ZthrowCstringBadValue(char *msg);"))

      codeWriters.add(NEW(Declaration.throwDeadly,
        PROC (WriteC gen, IO.File fd)
          string throwDeadly = DeclStore.getPName("MEModule", "FthrowDeadly")
          fd.write(''"
void ZthrowDeadly(int nr) {
 "'' .. throwDeadly .. ''"((Ti)nr);
}
"'')
        }).setDependencies([["MEModule", "FthrowDeadly"]]))

      codeWriters.add(NEW(Declaration.throwThread,
        PROC (WriteC gen, IO.File fd)
          string eThrowThread = DeclStore.getPName("MEModule", "FthrowThread")
          fd.write(''"
void ZthrowThread(Tc *text) {
 "'' .. eThrowThread .. ''"(NULL, text);
}
"'')
        }).setDependencies([["MEModule", "FthrowThread"]]))

      codeWriters.add(NEW(Declaration.throwDyn,
        PROC (WriteC gen, IO.File fd)
          string eThrowDyn = DeclStore.getPName("MEModule", "FthrowDyn")
          fd.write(''"
void ZthrowDyn(Tc *text) {
 "'' .. eThrowDyn .. ''"(text);
}
"'')
        }).setDependencies([["MEModule", "FthrowDyn"]])
        .setDecl("void ZthrowDyn(Tc *text);"))

      codeWriters.add(NEW(Declaration.throwInternal,
        PROC (WriteC gen, IO.File fd)
          string eThrowInternal = DeclStore.getPName("MEModule", "FthrowInternal")
          fd.write(''"
void ZthrowInternal(Tc *text) {
 "'' .. eThrowInternal .. ''"(NULL, text);
}
"'')
        }).setDependencies([["MEModule", "FthrowInternal"]])
        .setDecl("void ZthrowInternal(Tc *t);"))

      codeWriters.add(NEW(%cstring,
        PROC (WriteC gen, IO.File fd)
          # Return the C string for a Zimbu string.
          fd.write(''"
Tc *ZcString(Tc *s) {
 Tc *p;
 if (s == NULL) return NULL;
 ZstringSizePtr(s, &p);
 return p;
}
"'')
        }))

      codeWriters.add(NEW(%byteStringPtr,
        PROC (WriteC gen, IO.File fd)
          # Get the "Tc *" pointer to the start of the data from a Ty.
          fd.write(''"
Tc *ZvarByteStringPtr(Ty *b) {
 switch (b->flags & ZbyteStringT_mask) {
  case ZbyteStringT_tiny:
   return b->tiny;
  case ZbyteStringT_string:
   {
    Tc *p;
    ZstringSizePtr(b->data, &p);
    return p;
   }
  case ZbyteStringT_piece:
   return (Tc*)b->data + sizeof(Tp) + ((Tp *)(b->data))->offset;
  case ZbyteStringT_pieceval:
   {
    Tv *pv = (Tv *)b->data;
    return(Tc*)pv->data + pv->offset;
   }
 }
 fprintf(stderr, "Not implemented: ZvarByteStringPtr()\n");
 return NULL;
}
"'')
        }).setDependencies([%varByteStringType, %piecevalType, %pieceType]))

      codeWriters.add(NEW(%typeInRange,
        PROC (WriteC gen, IO.File fd)
          # Inclusive: low and high are valid type indexes.
          fd.write(''"
int ZTypeInRange(int type, int low, int high, char *imp) {
 return type >= low && type <= high && (imp == NULL || imp[type] == 0);
}
"'')
        }))

      codeWriters.add(NEW(%typepInRange,
        PROC (WriteC gen, IO.File fd)
          # Inclusive: low and high are valid type indexes.
          fd.write(''"
int ZTypepInRange(void *p, int low, int high, char *imp) {
 int type;
 if (p == NULL) return 0;
 type = (Tip)((Tj*)p)->mt[1];
 return type >= low && type <= high && (imp == NULL || imp[type] == 0);
}
"'')
        }))

      codeWriters.add(NEW(%xobjIsa,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZxobjIsa(void *p, int i) {
 return p != NULL && (Tip)((Tj*)p)->mt[1] == i;
}
"'')
        }))

      codeWriters.add(NEW(%xobjIsaTab,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZxobjIsaTab(void *p, char *tab) {
 return p != NULL && tab[(Tip)((Tj*)p)->mt[1]];
}
"'')
        }))

      codeWriters.add(NEW(%objIsa,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZobjIsa(void *p, void *t) {
 return p != NIL && ((Tj*)p)->mt[0] == (Tc*)t;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.asString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZintAsString(Ti n) {
 if (n < 0 || n > 0x10fffff)
  ZthrowCstringBadValue("asString(): Character must be in range 0 - 0x10ffff");
 if (n <= 0x7f) {
  Tc *p = Za(ZOH_OFF + 3);
  p[ZOH_OFF] = 1;
  p[ZOH_OFF + 1] = n;
  p[ZOH_OFF + 2] = 0;
  return p;
 }
 if (n <= 0x7ff) {
  Tc *p = Za(ZOH_OFF + 4);
  p[ZOH_OFF] = 2;
  p[ZOH_OFF + 1] = 0xc0 + ((unsigned)n >> 6);
  p[ZOH_OFF + 2] = 0x80 + (n & 0x3f);
  p[ZOH_OFF + 3] = 0;
  return p;
 }
 if (n <= 0xffff) {
  Tc *p = Za(ZOH_OFF + 5);
  p[ZOH_OFF] = 3;
  p[ZOH_OFF + 1] = 0xe0 + ((unsigned)n >> 12);
  p[ZOH_OFF + 2] = 0x80 + (((unsigned)n >> 6) & 0x3f);
  p[ZOH_OFF + 3] = 0x80 + (n & 0x3f);
  p[ZOH_OFF + 4] = 0;
  return p;
 }
 Tc *p = Za(ZOH_OFF + 6);
 p[ZOH_OFF] = 4;
 p[ZOH_OFF + 1] = 0xf0 + ((unsigned)n >> 18);
 p[ZOH_OFF + 2] = 0x80 + (((unsigned)n >> 12) & 0x3f);
 p[ZOH_OFF + 3] = 0x80 + (((unsigned)n >> 6) & 0x3f);
 p[ZOH_OFF + 4] = 0x80 + (n & 0xef);
 p[ZOH_OFF + 5] = 0;
 return p;
}
"'')
        }).setDependencies([Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(%toCharBuf,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int Zchar2stringBuf(Ti n, Tc *buf) {
 if (n < 0 || n > 0x10fffff)
  ZthrowCstringBadValue("asString(): Character must be in range 0 - 0x10ffff");
 if (n <= 0x7f) {
  buf[0] = n;
  buf[1] = 0;
  return 1;
 }
 if (n <= 0x7ff) {
  buf[0] = 0xc0 + ((unsigned)n >> 6);
  buf[1] = 0x80 + (n & 0x3f);
  buf[2] = 0;
  return 2;
 }
 if (n <= 0xffff) {
  buf[0] = 0xe0 + ((unsigned)n >> 12);
  buf[1] = 0x80 + (((unsigned)n >> 6) & 0x3f);
  buf[2] = 0x80 + (n & 0x3f);
  buf[3] = 0;
  return 3;
 }
 buf[0] = 0xf0 + ((unsigned)n >> 18);
 buf[1] = 0x80 + (((unsigned)n >> 12) & 0x3f);
 buf[2] = 0x80 + (((unsigned)n >> 6) & 0x3f);
 buf[3] = 0x80 + (n & 0xef);
 buf[4] = 0;
 return 4;
}
"'')
        }).setDependencies([Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(%intAsByteString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZintAsByteString(Ti n) {
 Tc *p = Za(ZOH_OFF + 3);
 p[ZOH_OFF] = 1;
 p[ZOH_OFF + 1] = n;
 p[ZOH_OFF + 2] = 0;
 return p;
}
"'')
        }))

      codeWriters.add(NEW(%byteStringCheckUtf8,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZbyteStringCheckUtf8(Tc *p) {
 /* TODO */
 return p;
}
"'')
        }))

      codeWriters.add(NEW(WriteCommon.fixSign,
        PROC (WriteC gen, IO.File fd)
          # Used for converting intN to int.  "mask" has all bits set, except
          # the lower ones that contain a positive value.  For int5 it is ~15.
          # When the topmost valid bit in "n" is set the value is negative and
          # needs to have all "mask" bits set.
          # TODO: support for 32 and 64 bit separately for efficiency
          fd.write(''"
Ti ZFixSign(Ti n, Ti mask) {
 if (n & mask)
  return n | mask;
 return n;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.stringConcat,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
/* concat string */
Tc *ZcS(Tc *l, Tc *ri) {
 Tc *l_p;
 Ti l_len;
 Tc *r_p;
 Ti r_len;
 Ti len;
 Tc *pp;
 Tc *r;
 if (l == NULL) {l_len = 3; l_p = (Tc*)"NIL";}
 else l_len = ZstringSizePtr(l, &l_p);
 if (ri == NULL) {r_len = 3; r_p = (Tc*)"NIL";}
 else r_len = ZstringSizePtr(ri, &r_p);
 len = l_len + r_len;
 r = ZnewStringInit(len, &pp);
 memmove(pp, l_p, l_len);
 memmove(pp + l_len, r_p, r_len);
 return r;
}
"'')
        }).setDependencies([%string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%concat3,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
/* concat string */
Tc *ZcS3(Tc *s1, Tc *s2, Tc *s3) {
 Tc *p1;
 Ti len1;
 Tc *p2;
 Ti len2;
 Tc *p3;
 Ti len3;
 Ti len;
 Tc *pp;
 Tc *r;
 if (s1 == NULL) {len1 = 3; p1 = (Tc*)"NIL";}
 else len1 = ZstringSizePtr(s1, &p1);
 if (s2 == NULL) {len2 = 3; p2 = (Tc*)"NIL";}
 else len2 = ZstringSizePtr(s2, &p2);
 if (s3 == NULL) {len3 = 3; p3 = (Tc*)"NIL";}
 else len3 = ZstringSizePtr(s3, &p3);
 len = len1 + len2 + len3;
 r = ZnewStringInit(len, &pp);
 memmove(pp, p1, len1);
 memmove(pp + len1, p2, len2);
 memmove(pp + len1 + len2, p3, len3);
 return r;
}
"'')
        }).setDependencies([%string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%concat5,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
/* concat string */
Tc *ZcS5(Tc *s1, Tc *s2, Tc *s3, Tc *s4, Tc *s5) {
 Tc *p1;
 Ti len1;
 Tc *p2;
 Ti len2;
 Tc *p3;
 Ti len3;
 Tc *p4;
 Ti len4;
 Tc *p5;
 Ti len5;
 Ti len;
 Tc *pp;
 Tc *r;
 if (s1 == NULL) {len1 = 3; p1 = (Tc*)"NIL";}
 else len1 = ZstringSizePtr(s1, &p1);
 if (s2 == NULL) {len2 = 3; p2 = (Tc*)"NIL";}
 else len2 = ZstringSizePtr(s2, &p2);
 if (s3 == NULL) {len3 = 3; p3 = (Tc*)"NIL";}
 else len3 = ZstringSizePtr(s3, &p3);
 if (s4 == NULL) {len4 = 3; p4 = (Tc*)"NIL";}
 else len4 = ZstringSizePtr(s4, &p4);
 if (s5 == (Tc*)1) len5 = 0;
 else if (s5 == NULL) {len5 = 3; p5 = (Tc*)"NIL";}
 else len5 = ZstringSizePtr(s5, &p5);
 len = len1 + len2 + len3 + len4 + len5;
 r = ZnewStringInit(len, &pp);
 memmove(pp, p1, len1);
 memmove(pp + len1, p2, len2);
 memmove(pp + len1 + len2, p3, len3);
 memmove(pp + len1 + len2 + len3, p4, len4);
 if (s5 != (Tc*)1) memmove(pp + len1 + len2 + len3 + len4, p5, len5);
 return r;
}
"'')
        }).setDependencies([%string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%concat8,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
/* concat string */
Tc *ZcS8(Tc *s1, Tc *s2, Tc *s3, Tc *s4, Tc *s5, Tc *s6, Tc *s7, Tc *s8) {
 Tc *p[8];
 Ti len[8];
 Ti totlen = 0;
 Tc *pp;
 Tc *r;
 int i;
 if (s1 == NULL) {len[0] = 3; p[0] = (Tc*)"NIL";}
 else len[0] = ZstringSizePtr(s1, &p[0]);
 if (s2 == NULL) {len[1] = 3; p[1] = (Tc*)"NIL";}
 else len[1] = ZstringSizePtr(s2, &p[1]);
 if (s3 == NULL) {len[2] = 3; p[2] = (Tc*)"NIL";}
 else len[2] = ZstringSizePtr(s3, &p[2]);
 if (s4 == NULL) {len[3] = 3; p[3] = (Tc*)"NIL";}
 else len[3] = ZstringSizePtr(s4, &p[3]);
 if (s5 == NULL) {len[4] = 3; p[4] = (Tc*)"NIL";}
 else len[4] = ZstringSizePtr(s5, &p[4]);
 if (s6 == NULL) {len[5] = 3; p[5] = (Tc*)"NIL";}
 else len[5] = ZstringSizePtr(s6, &p[5]);
 if (s7 == (Tc*)1) len[6] = 0;
 else if (s7 == NULL) {len[6] = 3; p[6] = (Tc*)"NIL";}
 else len[6] = ZstringSizePtr(s7, &p[6]);
 if (s8 == (Tc*)1) len[7] = 0;
 else if (s8 == NULL) {len[7] = 3; p[7] = (Tc*)"NIL";}
 else len[7] = ZstringSizePtr(s8, &p[7]);
 for (i = 0; i < 8; ++i) totlen += len[i];
 r = ZnewStringInit(totlen, &pp);
 totlen = 0;
 for (i = 0; i < 8; ++i) {
  memmove(pp + totlen, p[i], len[i]);
  totlen += len[i];
 }
 return r;
}
"'')
        }).setDependencies([%string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%concat12,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
/* concat string */
Tc *ZcS12(Tc *s1, Tc *s2, Tc *s3, Tc *s4, Tc *s5, Tc *s6, Tc *s7, Tc *s8, Tc *s9, Tc *s10, Tc *s11, Tc *s12) {
 Tc *p[12];
 Ti len[12];
 Ti totlen = 0;
 Tc *pp;
 Tc *r;
 int i;
 if (s1 == NULL) {len[0] = 3; p[0] = (Tc*)"NIL";}
 else len[0] = ZstringSizePtr(s1, &p[0]);
 if (s2 == NULL) {len[1] = 3; p[1] = (Tc*)"NIL";}
 else len[1] = ZstringSizePtr(s2, &p[1]);
 if (s3 == NULL) {len[2] = 3; p[2] = (Tc*)"NIL";}
 else len[2] = ZstringSizePtr(s3, &p[2]);
 if (s4 == NULL) {len[3] = 3; p[3] = (Tc*)"NIL";}
 else len[3] = ZstringSizePtr(s4, &p[3]);
 if (s5 == NULL) {len[4] = 3; p[4] = (Tc*)"NIL";}
 else len[4] = ZstringSizePtr(s5, &p[4]);
 if (s6 == NULL) {len[5] = 3; p[5] = (Tc*)"NIL";}
 else len[5] = ZstringSizePtr(s6, &p[5]);
 if (s7 == NULL) {len[6] = 3; p[6] = (Tc*)"NIL";}
 else len[6] = ZstringSizePtr(s7, &p[6]);
 if (s8 == NULL) {len[7] = 3; p[7] = (Tc*)"NIL";}
 else len[7] = ZstringSizePtr(s8, &p[7]);
 if (s9 == NULL) {len[8] = 3; p[8] = (Tc*)"NIL";}
 else len[8] = ZstringSizePtr(s9, &p[8]);
 if (s10 == (Tc*)1) len[9] = 0;
 else if (s10 == NULL) {len[9] = 3; p[9] = (Tc*)"NIL";}
 else len[9] = ZstringSizePtr(s10, &p[9]);
 if (s11 == (Tc*)1) len[10] = 0;
 else if (s11 == NULL) {len[10] = 3; p[10] = (Tc*)"NIL";}
 else len[10] = ZstringSizePtr(s11, &p[10]);
 if (s12 == (Tc*)1) len[11] = 0;
 else if (s12 == NULL) {len[11] = 3; p[11] = (Tc*)"NIL";}
 else len[11] = ZstringSizePtr(s12, &p[11]);
 for (i = 0; i < 12; ++i) totlen += len[i];
 r = ZnewStringInit(totlen, &pp);
 totlen = 0;
 for (i = 0; i < 12; ++i) {
  memmove(pp + totlen, p[i], len[i]);
  totlen += len[i];
 }
 return r;
}
"'')
        }).setDependencies([%string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%allocObjectRef,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tr Zao(void *ptr, Tc **table, Ti type) {
 Tr tr;
 tr.ptr = ptr;
 tr.table = table;
 tr.type = type;
 return tr;
}
"'')
        }))

      codeWriters.add(NEW(%noAllocObjectRef,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
/* fill not-allocated object reference */
Tr *Znao(Tr *p, void *ptr, Tc **table, Ti type) {
 p->ptr = ptr;
 p->table = table;
 p->type = type;
 return p;
}
"'')
        }))

      codeWriters.add(NEW(%noAllocAssign,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
/* fill not-allocated object reference */
void Znaa(void *d, void *s) {
 ((Tto*)(((Tj *)s)->mt[0]))->Assign(d, s);
}
"'')
        }))

      codeWriters.add(NEW(%iobject2noalloc,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
/* fill not-allocated object reference */
Tr *Znaio(Tr *p, void *ptr) {
 p->ptr = ((Tr*)ptr)->ptr;
 p->table = ((Tr*)ptr)->table;
 p->type = ((Tr*)ptr)->type;
 return p;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.convertDynToIobject,
        PROC (WriteC gen, IO.File fd)
          string throwType = DeclStore.getPName("MEModule", "FthrowWrongTypeEx")
          fd.write(''"
Tr ZaoDyn(Tx src, Tc ***table, size_t len, Tt *type, Ti pos) {
 int i;
 for (i = 0; i < len; ++i) {
  if (table[i] && (Tt*)table[i][0] == src.type) {
   Tr tr;
   tr.ptr = src.u.ptr;
   tr.table = (Tc **)table[i];
   tr.type = i;
   return tr;
  }
 }
 "'' .. throwType .. ''"(pos, type, src.type);
 return trZero;
}
"'')
        }).setDependencies([["MEModule", "FthrowWrongTypeEx"]]))

      codeWriters.add(NEW(%deref,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void *Zderef(Tr *obj) {
 if (obj == NULL) return NULL;
 return obj->ptr;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.objectMember,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void *ZoM(Tr tr, Ti index) {
 return tr.ptr + (size_t)tr.table[index];
}
void *ZoX(void *p, Ti index) {
 return p + (size_t)((Tj *)p)->mt[index];
}
"'')
        }))

      codeWriters.add(NEW(Declaration.objectMemberDotnil,
        PROC (WriteC gen, IO.File fd)
          # Like ZoM() but return a pointer to NULL when "p" is NULL.
          fd.write(''"
/* object reference ?.member */
void *ZoMd(Tr tr, Ti index) {
 static Ti nil = 0;
 if (tr.ptr == NULL) return &nil;
 return tr.ptr + (size_t)tr.table[index];
}
void *ZoXd(void *p, Ti index) {
 static Ti nil = 0;
 if (p == NULL) return &nil;
 return p + (size_t)((Tj *)p)->mt[index];
}
"'')
        }))

      codeWriters.add(NEW(Declaration.convert2dyn,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tx ZVtoDyn(Ti src, Tt *type) {
 Tx p;
 p.u.ival = src;
 p.type = type;
 return p;
}
Tx ZFtoDyn(Tf src, Tt *type) {
 Tx p;
 p.u.fval = src;
 p.type = type;
 return p;
}
Tx ZPtoDyn(void *src, Tt *type) {
 Tx p;
 if (type == &iobj__T) {
  p.u.ptr = ((Tr*)src)->ptr;
  p.type = (Tt*)((Tr*)src)->table[0];
 } else {
  p.u.ptr = src;
  p.type = type;
 }
 return p;
}
Tx ZXobjtoDyn(void *src, Tt *type) {
 Tx p;
 p.u.ptr = src;
 p.type = (Tt*)((Tj *)src)->mt[0];
 return p;
}
Tx ZIobjtoDyn(Tr src, Tt *type) {
 Tx p;
 p.u.ptr = src.ptr;
 p.type = (Tt*)src.table[0];
 return p;
}
"'')
        }).setDependencies([Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.convertFromDyn,
        PROC (WriteC gen, IO.File fd)
          string throwType = DeclStore.getPName("MEModule", "FthrowWrongTypeEx")
          fd.write(''"
Ti ZDynToV(Tx src, Tt *type, Ti pos) {
 if (src.type != type
   && !(src.type == &byte__T && (type == &nat16__T || type == &nat32__T || type == &nat__T || type == &int16__T || type == &int32__T || type == &int__T))
   && !(src.type == &nat16__T && (type == &nat32__T || type == &nat__T || type == &int32__T || type == &int__T))
   && !(src.type == &nat32__T && (type == &nat__T || type == &int__T))
   && !(src.type == &int8__T && (type == &int16__T || type == &int32__T || type == &int__T))
   && !(src.type == &int16__T && (type == &int32__T || type == &int__T))
   && !(src.type == &int32__T && type == &int__T)) "'' .. throwType .. ''"(pos, type, src.type);
 return src.u.ival;
}
Tf ZDynToF(Tx src, Tt *type, Ti pos) {
 if (src.type != type) "'' .. throwType .. ''"(pos, type, src.type);
 return src.u.fval;
}
void *ZDynToP(Tx src, Tt *type, Ti pos) {
 if (src.u.ptr != NULL && src.type != type) "'' .. throwType .. ''"(pos, type, src.type);
 return src.u.ptr;
}
"'')
        }).setDependencies([Declaration.throwCstringNil])
          .setDependencies([["MEModule", "FthrowWrongTypeEx"]]))

      codeWriters.add(NEW(Declaration.convertZoref,
        PROC (WriteC gen, IO.File fd)
          string throwNil = DeclStore.getPName("MEModule", "FthrowNil")
          string throwType = DeclStore.getPName("MEModule", "FthrowWrongType")
          # Inclusive: type and maxType are valid type indexes.
          fd.write(''"
Tr ZconvertZioref(Tr orig, Tc ***table, int type, int maxType, Ti pos) {
 Tr p;
 if (orig.ptr == NULL) p.ptr = NULL;
 else {
  if (orig.type < type || orig.type > maxType) "'' .. throwType .. ''"(pos);
  p.ptr = orig.ptr;
  p.type = orig.type - type;
  p.table = table[p.type];
 }
 return p;
}
Tr ZconvertZiopref(void *orig, Tc ***table, int type, int maxType, Ti pos) {
 Tr p;
 p.ptr = orig;
 if (orig) {
  p.type = -type;
  p.table = table[p.type];
 }
 return p;
}
void *Ziobj2xobj(Tr orig, int type, int maxType, Ti pos) {
 if (orig.ptr == NULL) return NULL;
 if (orig.type < type || orig.type > maxType) "'' .. throwType .. ''"(pos);
 return orig.ptr;
}
"'')
        }).setDependencies([["MEModule", "FthrowWrongType"]]))

      codeWriters.add(NEW(Declaration.iobject2object,
        PROC (WriteC gen, IO.File fd)
          string throwType = DeclStore.getPName("MEModule", "FthrowWrongType")
          fd.write(''"
void *Zio(int type, Ti pos, Tr *p) {
 void *r;
 if (p == NULL || p->ptr == NULL) r = NULL;
 else {
  if (p->type != type) "'' .. throwType .. ''"(pos);
  r = p->ptr;
 }
 return r;
}
"'')
        fd.write(''"
void *Znio(int type, Ti pos, Tr tr) {
 void *r;
 if (tr.ptr == NULL) r = NULL;
 else {
  if (tr.type != type) "'' .. throwType .. ''"(pos);
  r = tr.ptr;
 }
 return r;
}
void *Znip(void *type, Ti pos, void *p) {
 if (p && ((Tj*)p)->mt[0] != type) "'' .. throwType .. ''"(pos);
 return p;
}
"'')
        }).setDependencies([["MEModule", "FthrowWrongType"],
                            ["MZModule__CPos", "MNEW__1"]]))

      codeWriters.add(NEW(Declaration.exit,
        PROC (WriteC gen, IO.File fd)
          string zcPosName = DeclStore.getPName("MZModule", "CPos")
          IF gen.isDeclUsed(Declaration.try)
            # When inside try/catch there may be a finally, so jump there.
            string throwExit = DeclStore.getPName("MEModule", "FthrowExit")
            fd.write(''"
void Zexit("'' .. zcPosName .. ''" *pos, Ti val) {
 "'' .. throwExit .. ''"(pos, val);
}
"'')
          ELSE
            # Simple: call exit().
            fd.write(''"
void Zexit("'' .. zcPosName .. ''" *pos, Ti val) {
 beforeExit();
 exit((int)val);
}
"'')
          }
        }).addCondDepends(Declaration.try, ["MEModule", "FthrowExit"]))

      codeWriters.add(NEW(%iobjType,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tt *ZiobjType(Tr *p) {
 if (p == NULL) ZthrowCstringNil("using Type() on NIL");
 return (Tt *)(p->table[0]);
}
"'')
        }))

      # ZnoAllocClear: used to initialize an object on the stack.
      # Set np to Znoalloc, GC now needs to look inside the object.
      codeWriters.add(NEW(%noAllocClear,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void *ZnoAllocClear(size_t len, void *p, Tc **mt"'')
        IF gen.isDeclUsed(Declaration.hasFinish)
          fd.write(", Ts (*finish)(void*, Te)")
        }
        fd.write(''", void *(*init)(void*)) {"'')
        IF gen.hasNpField() && gen.isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 if (finish && ((Zoh*)p)->np != NULL) ZcallFinish(p, 3);"'')
        }
        fd.write(''"
 memset(p, 0, len);"'')
        IF gen.hasNpField()
          fd.write(''"
 ((Zoh*)p)->np = &Znoalloc;"'')
        }
        fd.write(''"
 if (mt) ((Tj*)p)->mt = mt;"'')
        IF gen.isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 if (finish) ((Zohf*)p)->ff = finish;"'')
        }
        fd.write(''"
 if (init) init(p);
 return p;
}
"'')
        }))

      # ZnoAllocNil: used to set an object on the stack to NIL.
      # Set np to NULL, GC must not look inside the object.
      codeWriters.add(NEW(%noAllocNil,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZnoAllocNil(void *p, int hasFinish) {"'')
        IF gen.hasNpField()
          IF gen.isDeclUsed(Declaration.hasFinish)
            fd.write(''"
 if (hasFinish && ((Zoh*)p)->np != NULL) ZcallFinish(p, 3);"'')
          }
          fd.write(''"
 ((Zoh*)p)->np = NULL;"'')
        }
        fd.write(''"
}
"'')
        }))

      # ZnoAllocNilIobj: used to call Finish() on an iobject.
      codeWriters.add(NEW(%noAllocNilIobj,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tr ZnoAllocNilIobj(Tr *p) {
 ZFinishIobj(p, 3);
 return trZero;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.proceed,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *Zproceed = (Tc *)"proceed";
"'')
        }))

      codeWriters.add(NEW(%char2byteIdx,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZChar2ByteIdx(Tc *p, Ti len, Ti charIdx) {
 Ti idx = 0;
 Ti count = 0;
 while (count < charIdx) {
  if (idx == len) break;
  ++idx;
  if ((p[idx - 1] & 0x80) != 0) {
    while ((p[idx] & 0xc0) == 0x80)
      ++idx;
  }
  ++count;
 }
 return idx;
}
"'')
        }))

      codeWriters.add(NEW(%fromChar,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZfromChar(Tc *p) {
 if (*p <= 0x7f)
  return *p;
 if ((*p & 0xe0) == 0xc0)
  return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);
 if  ((*p & 0xf0) == 0xe0)
  return ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6) + (p[2] & 0x3f);
 return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12) + ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);
}
"'')
        }))

      codeWriters.add(NEW(Declaration.stringGetChar,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringGetChar(Tc *sv, Ti idx) {
 Ti i;
 Tc *p;
 Ti len;
 Ti r;
 if (sv == NULL) ZthrowCstringNil("using [] on NIL");
 if (idx < 0) ZthrowCstringOutOfRange(idx, "using negative index");
 len = ZstringSizePtr(sv, &p);
 i = ZChar2ByteIdx(p, len, idx);
 if (i >= len) ZthrowCstringOutOfRange(idx, "index too big");
 r = ZfromChar(p + i);
 return r;
}
"'')
        }).setDependencies([%char2byteIdx, %fromChar,
                            Declaration.throwCstringNil,
                            Declaration.throwOutOfRange]))

      codeWriters.add(NEW(Declaration.byteStringGetByte,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringGetByte(Tc *sv, Ti idx, int dn) {
 Tc *p;
 Ti len;
 Ti r;
 if (sv == NULL) {
  if (dn) return 0;
  ZthrowCstringNil("getting byte from NIL");
 }
 if (idx < 0) ZthrowCstringOutOfRange(idx, "using negative index");
 len = ZstringSizePtr(sv, &p);
 if (idx >= len) ZthrowCstringOutOfRange(idx, "index too big");
 r = p[idx];
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil,
                            Declaration.throwOutOfRange]))

      codeWriters.add(NEW(Declaration.byteStringGetChar,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringGetChar(Tc *sv, Ti idx, int dn) {
 Tc *p;
 Ti len;
 Ti r;
 if (sv == NULL) {
  if (dn) return 0;
  ZthrowCstringNil("using getChar() on NIL");
 }
 if (idx < 0) ZthrowCstringOutOfRange(idx, "using negative index");
 len = ZstringSizePtr(sv, &p);
 if (idx >= len) ZthrowCstringOutOfRange(idx, "index too big");
 p += idx;
 r = *p;
 if (r > 0x7f) {
  if ((r & 0xe0) == 0xc0) {
   if (idx + 1 >= len)
    r = -1;
   else
    r = ((r & 0x1f) << 6) + (p[1] & 0x3f);
  } else if  ((*p & 0xf0) == 0xe0) {
   if (idx + 2 >= len)
    r = -1;
   else
    r = ((r & 0x0f) << 12) + ((p[1] & 0x3f) << 6) + (p[2] & 0x3f);
  } else if  ((*p & 0xf8) == 0xf0) {
   if (idx + 3 >= len)
    r = -1;
   else
    r = ((r & 0x07) << 18) + ((p[1] & 0x3f) << 12) + ((p[2] & 0x3f) << 6) + (p[4] & 0x3f);
  } else {
   r = -1;
  }
 }
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil,
                            Declaration.throwOutOfRange]))

      codeWriters.add(NEW(Declaration.byteStringGetCharSize,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringGetCharSize(Tc *sv, Ti idx, int dn) {
 Tc *p;
 Ti len;
 Ti c;
 Ti r;
 if (sv == NULL) {
  if (dn) return 0;
  ZthrowCstringNil("using getChar() on NIL");
 }
 if (idx < 0) ZthrowCstringOutOfRange(idx, "using negative index");
 len = ZstringSizePtr(sv, &p);
 if (idx >= len) ZthrowCstringOutOfRange(idx, "index too big");
 c  = p[idx];
 if (c <= 0x7f) {
  r = 1;
 } else if ((c & 0xe0) == 0xc0) {
  if (idx + 1 >= len)
   r = -1;
  else
   r = 2;
 } else if ((c & 0xf0) == 0xe0) {
  if (idx + 2 >= len)
   r = -1;
  else
   r = 3;
 } else if ((c & 0xf8) == 0xf0) {
  if (idx + 3 >= len)
   r = -1;
  else
   r = 4;
 } else {
  r = -1;
 }
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil,
                            Declaration.throwOutOfRange]))

      codeWriters.add(NEW(%bool2string,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *Zbool2string(Tb n) {
 return Zstr(n == 0 ? "FALSE" : "TRUE");
}
"'')
        }))

      codeWriters.add(NEW(%status2string,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *Zstatus2string(Ts n) {
 return Zstr(n == 0 ? "FAIL" : "OK");
}
"'')
        }))

      # string-like Size()
      codeWriters.add(NEW(%utf8size,
        PROC (WriteC gen, IO.File fd)
          # This assumes "sp[len]" is valid UTF-8.
          fd.write(''"
Ti Zutf8size(Tc *sp, Ti len) {
 Tc *p = (Tc*)sp;
 Tc *pend = p + len;
 Ti clen = 0;
 while (p < pend) {
  if ((*p & 0xc0) != 0x80) ++clen;
  ++p;
 }
 return clen;
}
"'')
        }))

      codeWriters.add(NEW(%stringSize,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringSize(Tc *s) {
 Tc *p;
 Ti r;
 Ti len;
 if (s == NULL) return 0;
 len = ZstringSizePtr(s, &p);
 r = Zutf8size(p, len);
 return r;
}
"'')
        }).setDependencies([%utf8size]))

      codeWriters.add(NEW(Declaration.varStringSize,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringSize(Ty *b) {
 Ti clen;
 if (b == NULL) clen = 0;
 else if (b->charSize >= 0) clen = b->charSize;
 else if (b->byteSize == 0) clen = 0;
 else {
  clen = Zutf8size(ZvarByteStringPtr(b), b->byteSize);
  b->charSize = clen;
 }
 return clen;
}
"'')
        }).setDependencies([%utf8size, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.byteStringSize,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringSize(Tc *s) {
 Tc *p;
 Ti len;
 if (s == NULL) return 0;
 p = s + ZOH_OFF;
 if ((*p & 0x80) == 0) {
  return *p;  /* be quick for short string */
 }
 len = *p & 0x7f;
 ++p;
 while ((*p & 0x80) != 0) {
  len = (len << 7) + (*p & 0x7f);
  ++p;
 }
 return (len << 7) + *p;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.varByteStringSize,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarByteStringSize(Ty *b) {
 if (b == NULL) return 0;
 return b->byteSize;
}
"'')
        }).setDependencies([%varByteStringType]))

      codeWriters.add(NEW(%int2string,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *Zint2string(Ti n) {
 char buf[30];
 char *p;
 int len;
 sprintf(buf, ZINT_FORMAT, n);
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
        }).setDependencies([%string_h]))

      codeWriters.add(NEW(%stringFormat,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZStringFormat(Tc *str, Tc *fmt) {
 Tc *strp;
 Ti strlen;
 Ti charlen;
 Tc *fmtp;
 Tc *p;
 Ti fmtlen;
 Ti minlen = -1;
 int maxType = 0;
 int ellipses = 0;
 Tc *ellipp;
 Ti maxlen = -1;
 Ti firstByte = 0;
 Ti lastByte;
 Ti fill = 0;
 Ti filloff;
 int twoparts = 0;
 Ti len;
 Tc *pp;
 Tc *res;
 if (str == NULL || fmt == NULL) return str;
 fmtlen = ZstringSizePtr(fmt, &fmtp);
 if (fmtp[fmtlen - 1] != 's') {
  ZthrowCstringBadValue("ToString(): format must end in 's'");
 }
 strlen = ZstringSizePtr(str, &strp);
 charlen = Zutf8size(strp, strlen);
 lastByte = strlen;
 p = fmtp;
 if (*p == '-') ++p;
 if (isdigit(*p)) {
  sscanf((char *)p, ZINT_FORMAT, &minlen);
  while (isdigit(*p)) ++p;
 }
 if (*p == '.') {
  ellipp = p;
  ++p;
  if (*p == '.') { ellipses += 2; ++p; }
  if (*p == '.') { ++ellipses; ++p; }
  if (*p == '-' || *p == '+') maxType = *p++;
  if (isdigit(*p)) {
   sscanf((char *)p, ZINT_FORMAT, &maxlen);
   if (charlen > maxlen) {
    if (maxType == '-') firstByte = ZChar2ByteIdx(strp, strlen, charlen - maxlen);
    else if (maxType == '+' || ellipses == 0) lastByte = ZChar2ByteIdx(strp, strlen, maxlen);
    else {
     twoparts = 1;
     lastByte = ZChar2ByteIdx(strp, strlen, maxlen / 2);
     firstByte = ZChar2ByteIdx(strp, strlen, charlen - maxlen / 2);
    }
    if (minlen >= 0) fill = minlen - maxlen;
   }
  }
 } else {
  fill = minlen - charlen;
 }
 fill = fill < 0 ? 0 : fill;
 filloff = *fmtp == '-' ? 0 : fill;
 if (twoparts) {
  len = lastByte + (strlen - firstByte) + fill;
  res = ZnewStringInit(len, &pp);
  memmove(pp + filloff, strp, lastByte);
  memmove(pp + filloff + lastByte, strp + firstByte, strlen - firstByte);
 } else {
  len = lastByte - firstByte + fill;
  res = ZnewStringInit(len, &pp);
  memmove(pp + filloff, strp + firstByte, lastByte - firstByte);
 }
 if (ellipses) memmove(pp + (maxType == '-' ? 0 : maxType == '+' ? len - ellipses : (len - ellipses) / 2), ellipp, ellipses);
 if (fill > 0) {
  if (*fmtp == '-') pp += len - fill;
  while (--fill >= 0) *pp++ = ' ';
 }
 return res;
}
"'')
        }).setDependencies([%string_h,
                            Declaration.throwCstringBadValue,
                            %utf8size,
                            %char2byteIdx]))

      codeWriters.add(NEW(%intFormat,
        PROC (WriteC gen, IO.File fd)
          # TODO: check for "d" type, check format.
          fd.write(''"
Tc *ZintFormat(Tc *fmt, Ti n) {
 char fmtbuf[100];
 char buf[100];
 char *p;
 int len;
 int c;
 Tc *fmtp;
 if (fmt == NULL) ZthrowCstringNil("ToString(): format is NIL");
 if (ZstringSizePtr(fmt, &fmtp) > 90) {
  ZthrowCstringBadValue("ToString(): format too long");
 }
 c = fmtp[strlen((char*)fmtp) - 1];
 if (c != 'd' && c != 'x') {
  ZthrowCstringBadValue("ToString(): format must end in 'd' or 'x'");
 }
 sprintf(fmtbuf, "%%%s", fmtp);
 strcpy(fmtbuf + strlen(fmtbuf) - 1, (c == 'd' ? ZINT_FORMAT : ZINT_XFORMAT) + 1);
 sprintf(buf, fmtbuf, n);
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
        }).setDependencies([%string_h,
                            Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(%nat2string,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *Znat2string(Tu n) {
 char buf[30];
 char *p;
 int len;
 sprintf(buf, ZNAT_FORMAT, n);
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
        }).setDependencies([%string_h]))

      codeWriters.add(NEW(%natFormat,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZnatFormat(Tc *fmt, Tu n) {
 char fmtbuf[100];
 char buf[30];
 char *p;
 int len;
 int c;
 Tc *fmtp;
 if (fmt == NULL) ZthrowCstringNil("ToString(): format is NIL");
 if (ZstringSizePtr(fmt, &fmtp) > 90) {
  ZthrowCstringBadValue("ToString(): format too long");
 }
 c = fmtp[strlen((char*)fmtp) - 1];
 if (c != 'd' && c != 'x') {
  ZthrowCstringBadValue("ToString(): format must end in 'd' or 'x'");
 }
 sprintf(fmtbuf, "%%%s", fmtp);
 strcpy(fmtbuf + strlen(fmtbuf) - 1, (c == 'd' ? ZNAT_FORMAT : ZINT_XFORMAT) + 1);
 sprintf(buf, fmtbuf, n);
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
        }).setDependencies([%string_h,
                            Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(%corrFloatStr,
        PROC (WriteC gen, IO.File fd)
          # Corrections for MingW:
          # - Exponent is always three digits, should be two when possible.
          #   If field width specified and the result is shorter, insert a space.
          # - INF and NAN have a wrong format.
          # TODO: Implement a printf that works properly.
          fd.write(''"
#ifdef __MINGW32__
void ZcorrFloatStr(char *buf, char *fmt) {
 size_t len = strlen(buf);
 if (len > 5 && buf[len - 3] == '0' && (buf[len - 5] == 'e' || buf[len - 5] == 'E')) {
  if (fmt != NULL && isdigit(fmt[1]) && strchr(fmt, '.') > 0 && atoi(fmt + 1) >= strlen(buf)) {
   memcpy(buf + 1, buf, len - 2);
   buf[0] = ' ';
  } else {
   buf[len - 3] = buf[len - 2];
   buf[len - 2] = buf[len - 1];
   buf[len - 1] = 0;
  }
 } else if (strcmp(buf, "1.#INF") == 0) {
  strcpy(buf, "inf");
 } else if (strcmp(buf, "-1.#INF") == 0) {
  strcpy(buf, "-inf");
 } else if (strcmp(buf, "1.#QNAN") == 0) {
  strcpy(buf, "nan");
 }
}
#endif
"'')
        }))

      codeWriters.add(NEW(%float2string,
        PROC (WriteC gen, IO.File fd)
          # MingW uses three digits for the exponent: 1.23e+003.
          # Inside the #ifdef this is corrected.
          fd.write(''"
Tc *Zfloat2string(Tf n) {
 char buf[30];
 char *p;
 int len;
 sprintf(buf, ZFLOAT_FORMAT, n);"'')
        IF Config.isMingw || Config.portable
          fd.write(''"
#ifdef __MINGW32__
 ZcorrFloatStr(buf, NULL);
#endif"'')
        }
        fd.write(''"
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
        }).setDependencies([%string_h, %corrFloatStr]))

      codeWriters.add(NEW(%float2int,
        PROC (WriteC gen, IO.File fd)
          # MingW uses three digits for the exponent: 1.23e+003.
          # Inside the #ifdef this is corrected.
          fd.write(''"
Ti Zfloat2int(Tf n) {
 if (isnan(n)) return 0;
 if (n == INFINITY) return 9223372036854775807UL;
 if (n == -INFINITY) return (-0x7fffffffffffffffLL - 1);
 return round(n);
}
"'')
        }).setDependencies([%string_h, %corrFloatStr]))

      codeWriters.add(NEW(%floatFormat,
        PROC (WriteC gen, IO.File fd)
          # TODO: check the format.
          fd.write(''"
Tc *ZfloatFormat(Tc *fmt, Tf n) {
 char fmtbuf[100];
 char buf[100];
 char *p;
 int len;
 Tc *fmtp;
 if (fmt == NULL) ZthrowCstringNil("ToString(): format is NIL");
 if (ZstringSizePtr(fmt, &fmtp) > 90) {
  ZthrowCstringBadValue("ToString(): format too long");
 }
 sprintf(fmtbuf, "%%%s", fmtp);"'')
        IF Config.isMingw || Config.portable
          # MingW doesn't support %F, change to %f.
          fd.write(''"
#ifdef __MINGW32__
 len = (int)strlen(fmtbuf);
 if (fmtbuf[len - 1] == 'F')
  fmtbuf[len - 1] = 'f';
#endif"'')
        }
        fd.write(''"
 sprintf(buf, fmtbuf, n);"'')
        IF Config.isMingw || Config.portable
          fd.write(''"
#ifdef __MINGW32__
 ZcorrFloatStr(buf, fmtbuf);
#endif"'')
        }
        fd.write(''"
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
        }).setDependencies([%string_h,
                            %corrFloatStr,
                            Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(%enum2string,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *Zenum2string(char **names, Te n) {
 return Zstr((n < 0 || n >= (Te)(size_t)names[0]) ? "INVALID" : names[n + 1]);
}
"'')
        }).setDecl("Tc *Zenum2string(char **names, Te n);\n"))

      codeWriters.add(NEW(%enumFromString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZenumFromString(char **names, Tc *s) {
 int i;
 Tc *p;
 ZstringSizePtr(s, &p);
 for (i = 1; i <= (Te)(size_t)names[0]; ++i)
  if (strcmp((char *)p, names[i]) == 0)
   return i - 1;
 return 0;
}
"'')
        }))

      codeWriters.add(NEW(%bool2varString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *Zbool2varString(Tb n) {
 return Zstring2varString(Zbool2string(n));
}
"'')
        }).setDependencies([%string2varString,
                            %bool2string,
                            %varByteStringType]))

      codeWriters.add(NEW(%status2varString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *Zstatus2varString(Ts n) {
 return Zstring2varString(Zstatus2string(n));
}
"'')
        }).setDependencies([%string2varString,
                            %status2string,
                            %varByteStringType]))

      codeWriters.add(NEW(%int2varString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *Zint2varString(Ti n) {
 char p[30];
 sprintf(p + ZOH_OFF, ZINT_FORMAT, n);
 return Zstring2varString(Zstr(p));
}
"'')
        }).setDependencies([%string2varString, %varByteStringType]))

      codeWriters.add(NEW(%byteStringWriteTo,
        PROC (WriteC gen, IO.File fd)
          # Write |len| bytes from bytes |b| to |p|, using offset |off|.
          fd.write(''"
void ZbyteStringWriteTo(Ty *b, Tc *p, Ti off, Ti len) {
 switch (b->flags & ZbyteStringT_mask) {
  case ZbyteStringT_tiny:
   memmove(p, b->tiny + off, len);
   break;
  case ZbyteStringT_string:
   {
    Tc *s;
    ZstringSizePtr(b->data, &s);
    memmove(p, s + off, len);
    break;
   }
  case ZbyteStringT_piece:
   memmove(p, (Tc*)b->data + sizeof(Tp) + off, len);
   break;
  case ZbyteStringT_pieceval:
   {
    Tv *pv = (Tv *)b->data;
    memmove(p, (Tc*)pv->data + pv->offset + off, len);
   }
   break;
  case ZbyteStringT_cord:
   {
    Tc *dest = p;
    Tc *src;
    Tcd *cord;
    Ti skip = off;
    Ti todo = len;
    Ti n;
    for (cord = b->data; cord != NULL && todo > 0; cord = cord->next) {
     if (cord->byteSize <= skip) {
      skip -= cord->byteSize;
     } else {
      switch (cord->type) {
       case ZbyteStringT_tiny: src = cord->tiny; break;
       case ZbyteStringT_string: src = (Tc*)cord->data; break;
       case ZbyteStringT_piece: src = (Tc*)cord->data + sizeof(Tp); break;
       default:
        fprintf(stderr, "Not implemented yet: ZbyteStringWriteTo(cord)\n");
        src = (Tc*)"";
      }
      if (cord->byteSize < todo)
       n = cord->byteSize;
      else
       n = todo;
      if (skip > 0) {
       memmove(dest, src + skip, n);
       skip = 0;
      } else {
       memmove(dest, src, n);
      }
      todo -= n;
      dest += n;
     }
    }
   }
   break;
  default:
   fprintf(stderr, "Not implemented yet: ZbyteStringWriteTo(?)\n");
   break;
 }
}
"'')
        }).setDependencies([%string_h, %cordType, %varByteStringType,
                            %piecevalType, %pieceType]))

      codeWriters.add(NEW(%varString2string,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZvarString2string(Ty *b) {
 Ti len;
 int  n = 1;
 Tc *r;
 if (b == NULL) return NULL;
 len = b->byteSize;
 while (len > 127) {
  ++n;
  len = len >> 7;
 }
 r = Za(ZOH_OFF + n + b->byteSize + 1) + ZOH_OFF;
 ZbyteStringWriteTo(b, r + n, 0, b->byteSize);
 r[n + b->byteSize] = 0;
 len = b->byteSize;
 r[--n] = len & 127;
 while (len > 127) {
  len = len >> 7;
  r[--n] = (len & 127) + 128;
 }
 return r - ZOH_OFF;
}
"'')
        }).setDependencies([%string_h, %varByteStringType, %byteStringWriteTo]))

      codeWriters.add(NEW(Declaration.usesCtx,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tx CtxGet(Tt *t) {
 Tx r = {NULL};
 Tn *e = "'' .. gen.getEnvCode() .. ''";
 int i;
 for (i = e->ctxUsed; --i >= 0; )
  if (e->ctxArr[i].type == t) {
   if (e->ctxArr[i].provide)
    return ((Tx (*)(void*))(e->ctxArr[i].provide))(e->ctxArr[i].obj.u.ptr);
   return e->ctxArr[i].obj;
  }
 return r;
}
void CtxAdd(Tt *t, Tx o) {
 Tn *e = "'' .. gen.getEnvCode() .. ''";
 if (e->ctxUsed == e->ctxLen) {
  e->ctxLen += 20;
  if (e->ctxArr == NULL) {
   e->ctxArr = malloc(sizeof(Tce) * e->ctxLen);
  } else {
   e->ctxArr = realloc(e->ctxArr, sizeof(Tce) * e->ctxLen);
  }
 }
 e->ctxArr[e->ctxUsed].type = t;
 e->ctxArr[e->ctxUsed].obj = o;
 e->ctxArr[e->ctxUsed].provide = NULL;
 ++e->ctxUsed;
}
void CtxAddProvider(Tt *t, void *o, void *p) {
 Tn *e = "'' .. gen.getEnvCode() .. ''";
 if (e->ctxUsed == e->ctxLen) {
  e->ctxLen += 20;
  if (e->ctxArr == NULL) {
   e->ctxArr = malloc(sizeof(Tce) * e->ctxLen);
  } else {
   e->ctxArr = realloc(e->ctxArr, sizeof(Tce) * e->ctxLen);
  }
 }
 e->ctxArr[e->ctxUsed].type = t;
 e->ctxArr[e->ctxUsed].obj.u.ptr = o;
 e->ctxArr[e->ctxUsed].provide = p;
 ++e->ctxUsed;
}
"'')
        }).setTypedef("typedef struct ctxEntry__S Tce;")
          .setDecl("struct ctxEntry__S {\n"
                .. " Tt *type;\n"
                .. " Tx obj;\n"
                .. " void *provide;\n"
                .. "};"))

      codeWriters.add(NEW(%getCstring,
        PROC (WriteC gen, IO.File fd)
          # In a string or byteString get a pointer to the text string.  Used
          # for C code.
          fd.write(''"
char *ZgetCstring(Tc *s) {
 Tc *p;
 if (s == NULL) return NULL;
 p = s + ZOH_OFF;
 while ((*p & 0x80) != 0) ++p;
 return (char *)p + 1;
}
"'')
        }).setDecl("char *ZgetCstring(Tc *s);"))

      codeWriters.add(NEW(%string2varString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *Zstring2varString(Tc *s) {
 Tc *p;
 Ty *r;
 if (s == NULL) return NULL;
 r = (Ty *)Za(sizeof(Ty));
 r->flags = ZbyteStringT_string;
 r->byteSize = ZstringSizePtr(s, &p);
 r->charSize = -1;
 r->data = s;
 return r;
}
"'')
        }).setDependencies([%varByteStringType])
          .setDecl("Ty *Zstring2varString(Tc *s);"))

      codeWriters.add(NEW(%varByteStringSet,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZvarByteStringSet(Ty *r, Tc *s) {
 Tc *p;
 if (s == NULL) return NULL;
 memset(r, 0, sizeof(Ty));"'')
        IF gen.hasNpField()
          fd.write(''"
 r->np = &Znoalloc;"'')
        }
        fd.write(''"
 r->flags = ZbyteStringT_string;
 r->byteSize = ZstringSizePtr(s, &p);
 r->charSize = -1;
 r->data = s;
 return r;
}
"'')
        }).setDependencies([%varByteStringType])
          .setDecl("Ty *ZvarByteStringSet(Ty*r, Tc *s);"))

      codeWriters.add(NEW(%varByteStringCheckUtf8,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZvarByteStringCheckUtf8(Ty *b) {
 /* TODO */
 return b;
}
"'')
        }).setDependencies([%varByteStringType]))

      codeWriters.add(NEW(Declaration.varStringAddVal,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZvarStringAddVal(Ty *b, Tc *s) {
 Tc *p;
 Ti len;
 if (b == NULL) ZthrowCstringNil("using add() on NIL");
 if (s == NULL) ZthrowCstringNil("add() argument is NIL");
 len = ZstringSizePtr(s, &p);
 if (b->byteSize == 0) {
  b->flags = ZbyteStringT_string;
  b->byteSize = len;
  b->data = s;
 } else if (b->byteSize + len < sizeof(void*)) {
  /* put data in tiny[] */
  if ((b->flags & ZbyteStringT_mask) != ZbyteStringT_tiny) {
   Tc buf[sizeof(void*)];
   ZbyteStringWriteTo(b, buf, 0, b->byteSize);"'')
        IF !gen.manageMemory()
          fd.write(''"
   ZclearVarByteString(b);"'')
        }
        fd.write(''"
   memmove(b->tiny, buf, b->byteSize);"'')
        IF gen.manageMemory()
          fd.write(''"
  }"'')
        ELSE
          fd.write(''"
  } else ZclearVarByteString(b);"'')
        }
        fd.write(''"
  memmove(b->tiny + b->byteSize, p, len);
  b->byteSize += len;
  b->tiny[b->byteSize] = 0;
  b->flags = ZbyteStringT_tiny;
 } else {
  /* put data in Tp */
  int zlen = b->byteSize + len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  piece->offset = 0;
  ZbyteStringWriteTo(b, zp, 0, b->byteSize);"'')
        IF !gen.manageMemory()
          fd.write(''"
  ZclearVarByteString(b);"'')
        }
        fd.write(''"
  memmove(zp + b->byteSize, p, len);
  b->byteSize += len;
  zp[b->byteSize] = 0;
  b->flags = ZbyteStringT_piece;
  b->data = piece;
 }
 b->charSize = -1;
 return b;
}
"'')
        }).setDependencies([%string_h,
                            %varByteStringType,
                            %pieceType,
                            %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%byteStringCopyMutable,
        PROC (WriteC gen, IO.File fd)
          # Make a mutable copy of a varByteString.
          # Returned byteString has type ZbyteStringT_tiny or ZbyteStringT_piece.
          fd.write(''"
Ty *ZvarByteStringCopyMutable(Ty *b) {
 Ty *r = (Ty *)Za(sizeof(Ty));
 Ti len = b->byteSize;
 if (len < sizeof(void*)) {
  ZbyteStringWriteTo(b, r->tiny, 0, len);
  r->tiny[len] = 0;
  r->flags = ZbyteStringT_tiny;
 } else {
  Tp *piece = Za(sizeof(Tp) + len + 1);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = len;
  piece->offset = 0;
  ZbyteStringWriteTo(b, zp, 0, len);
  zp[len] = 0;
  r->data = piece;
  r->flags = ZbyteStringT_piece;
 }
 r->byteSize = len;
 return r;
}
"'')
        }).setDependencies([%string_h,
                            %varByteStringType, %pieceType,
                            %byteStringWriteTo]))

      codeWriters.add(NEW(Declaration.varStringToLowerAscii,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZvarStringToLowerAscii(Ty *b) {
 Ty *r;
 if (b == NULL) return NULL;
 r = ZvarByteStringCopyMutable(b);
 if (b->byteSize > 0) {
  Tc *p;
  Ti i;
  if ((b->flags & ZbyteStringT_mask) == ZbyteStringT_tiny) {
   p = (Tc*)r->tiny;
  } else {
   p = (Tc*)r->data + sizeof(Tp);
  }
  for (i = b->byteSize; --i >= 0; ) {
   *p = tolower(*p);
   ++p;
  }
 }
 return r;
}
"'')
        }).setDependencies([%string_h, %varByteStringType,
                            %pieceType, %byteStringCopyMutable,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%varStringToLower,
        PROC (WriteC gen, IO.File fd)
          # TODO: handle utf-8
          fd.write(''"
Ty *ZvarStringToLower(Ty *b) {
 return ZvarStringToLowerAscii(b);
}
"'')
        }).setDependencies([Declaration.varStringToLowerAscii,
                            %varByteStringType]))

      codeWriters.add(NEW(Declaration.varStringToUpperAscii,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZvarStringToUpperAscii(Ty *b) {
 Ty *r;
 if (b == NULL) return NULL;
 r = ZvarByteStringCopyMutable(b);
 if (b->byteSize > 0) {
  Tc *p;
  Ti i;
  if ((b->flags & ZbyteStringT_mask) == ZbyteStringT_tiny) {
   p = (Tc*)r->tiny;
  } else {
   p = (Tc*)r->data + sizeof(Tp);
  }
  for (i = b->byteSize; --i >= 0; ) {
   *p = toupper(*p);
   ++p;
  }
 }
 return r;
}
"'')
        }).setDependencies([%string_h, %varByteStringType,
                            %pieceType, %byteStringCopyMutable,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%varStringToUpper,
        PROC (WriteC gen, IO.File fd)
          # TODO: handle utf-8
          fd.write(''"
Ty *ZvarStringToUpper(Ty *b) {
 return ZvarStringToUpperAscii(b);
}
"'')
        }).setDependencies([Declaration.varStringToUpperAscii,
                            %varByteStringType]))

      codeWriters.add(NEW(Declaration.stringToLowerAscii,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZstringToLowerAscii(Tc *ss) {
 Tc *r;
 Tc *d;
 Tc *s;
 Ti len;
 if (ss == NULL) return NULL;
 len = ZstringSizePtr(ss, &s);
 r = ZnewString(s, len);
 d = r + (s - (Tc*)ss);
 while (*s != 0)
  *d++ = tolower(*s++);
 *d = 0;
 return (Tc*)r;
}
"'')
        }).setDependencies([%string_h,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%stringToArray,
        PROC (WriteC gen, IO.File fd)
          # TODO: Set locale to fix format
          string throwIllegalByte =
          DeclStore.getPName("MEModule", "FthrowIllegalByte")
          fd.write(''"
Ta *ZStringToArray(Tc *ss) {
 Ti blen;
 Ti clen;
 Ti i;
 Tc *s;
 Tc *end;
 Ta *r;
 Tu32 c;
 if (ss == NULL) return NULL;
 blen = ZstringSizePtr(ss, &s);
 end = s + blen;
 clen = Zutf8size(s, blen);
 r = ZnewArray(&nat32__T, sizeof(Tu32), clen);
 for (i = 0; i < clen; ++i) {
  if (*s <= 0x7f) {
   c = *s;
   ++s;
  } else if ((*s & 0xe0) == 0xc0) {
   if (s + 1 >= end) "'' .. throwIllegalByte .. ''"();
   c = ((s[0] & 0x1f) << 6) + (s[1] & 0x3f);
   s += 2;
  } else if ((*s & 0xf0) == 0xe0) {
   if (s + 2 >= end) "'' .. throwIllegalByte .. ''"();
   c = ((s[0] & 0x0f) << 12) + ((s[1] & 0x3f) << 6) + (s[2] & 0x3f);
   s += 3;
  } else if ((*s & 0xf8) == 0xf0) {
   if (s + 3 >= end) "'' .. throwIllegalByte .. ''"();
   c = ((s[0] & 0x07) << 18) + ((s[1] & 0x3f) << 12) + ((s[2] & 0x3f) << 6) + (s[3] & 0x3f);
   s += 4;
  } else "'' .. throwIllegalByte .. ''"();
  ((Tu32*)r->ptr)[i] = c;
 }
 return r;
}
"'')
        }).setDependencies([["MEModule", "FthrowIllegalByte"]])
          .setDependencies([Declaration.newArray, %utf8size]))

      codeWriters.add(NEW(%byteStringToArray,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ta *ZByteStringToArray(Tc *ss) {
 Ti blen;
 Ti i;
 Tc *s;
 Ta *r;
 if (ss == NULL) return NULL;
 blen = ZstringSizePtr(ss, &s);
 r = ZnewArray(&nat32__T, sizeof(Tu32), blen);
 for (i = 0; i < blen; ++i) {
  ((Tu32*)r->ptr)[i] = *s++;
 }
 return r;
}
"'')
        }).setDependencies([Declaration.newArray]))

      codeWriters.add(NEW(%stringFromArray,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZStringFromArray(Ta *head, Ti si, Ti ei) {
 Tc *r;
 Tc *p;
 int loop;
 Ti idx;
 Ti len = 0;
 Ti end = head->size[0] - 1;
 if (ei >= 0 && ei < end) end = ei;
 for (loop = 0; loop <= 1; ++loop) {
  for (idx = si; idx <= end; ++idx) {
   int c;
   switch (head->itemType->nr) {
    case 0: c = ((Ti*)head->ptr)[idx]; break;
    case 10: c = ((Tu*)head->ptr)[idx]; break;
    case 1: c = ((char*)head->ptr)[idx]; break;
    case 11: c = ((Tc*)head->ptr)[idx]; break;
    case 2: c = ((Ti16*)head->ptr)[idx]; break;
    case 12: c = ((Tu16*)head->ptr)[idx]; break;
    case 3: c = ((Ti32*)head->ptr)[idx]; break;
    case 13: c = ((Tu32*)head->ptr)[idx]; break;
    default:
     ZthrowCstringBadValue("array must contain int or nat numbers");
   }
   if (loop == 1) {
    int clen = Zchar2stringBuf(c, p);
    p += clen;
   } else {
    if (c <= 0x7f) len += 1;
    else if (c <= 0x7ff) len += 2;
    else if (c <= 0xffff) len += 3;
    else len += 4;
   }
  }
  if (loop == 0) r = ZnewStringInit(len, &p);
 }
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringBadValue,
                            %toCharBuf]))

      codeWriters.add(NEW(%stringToFloat,
        PROC (WriteC gen, IO.File fd)
          # TODO: Set locale to fix format
          fd.write(''"
Tf Zstring2float(Tc *ss, Ti *dn) {
 Tc *s;
 char *e;
 Ti len;
 if (ss == NULL) {
  ZthrowCstringNil("using toFloat() on NIL");
 }
 len = ZstringSizePtr(ss, &s);
 Tf r = strtod((char *)s, &e);
 if (dn) *dn = (Tc*)e - s;
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil]))

      codeWriters.add(NEW(%stringToLower,
        PROC (WriteC gen, IO.File fd)
          # TODO: handle utf-8
          fd.write(''"
Tc *ZstringToLower(Tc *ss) {
 return ZstringToLowerAscii(ss);
}
"'')
        }).setDependencies([Declaration.stringToLowerAscii]))

      codeWriters.add(NEW(Declaration.stringToUpperAscii,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZstringToUpperAscii(Tc *ss) {
 Tc *r;
 Tc *d;
 Tc *s;
 Ti len;
 if (ss == NULL) return NULL;
 len = ZstringSizePtr(ss, &s);
 r = ZnewString(s, len);
 d = r + (s - (Tc*)ss);
 while (*s != 0)
  *d++ = toupper(*s++);
 *d = 0;
 return (Tc*)r;
}
"'')
        }).setDependencies([%string_h, Declaration.throwCstringNil]))

      codeWriters.add(NEW(%stringToUpper,
        PROC (WriteC gen, IO.File fd)
          # TODO: handle utf-8 above latin1
          fd.write(''"
Tc *ZstringToUpper(Tc *ss) {
 Tc *r;
 Tc *d;
 Tc *s;
 Ti len;
 if (ss == NULL) return NULL;
 len = ZstringSizePtr(ss, &s);
 r = ZnewString(s, len);
 d = r + (s - (Tc*)ss);
 while (*s != 0) {
  int c = *s++;
  if (c <= 0x7f) {
   *d++ = toupper(c);
  } else if (c == 0xc3) {
   *d++ = c;
   *d++ = *s++ & 0xdf;
  } else {
   for(;;) {
    *d++ = c;
    if ((c & 0x80) == 0) break;
    c = *s++;
   }
  }
 }
 *d = 0;
 return (Tc*)r;
}
"'')
        }).setDependencies([Declaration.stringToUpperAscii]))

      PROC writeCordTypeDecl(WriteC gen, IO.File fd)
        fd.write("struct Zcord__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Tcd *next;\n"
              .. " Ti byteSize;\n"
              .. " Ti charSize;\n"
              .. " Tc type;\n"
              .. " Ti space;\n"
              .. " Ti offset;\n"
              .. " union {\n"
              .. "  void *data;\n"
              .. "  Tc tiny[sizeof(void*)];\n"
              .. " };\n"
              .. "};\n")
      }

      codeWriters.add(NEW(%cordType)
          .setTypedef("typedef struct Zcord__S Tcd; /* cord */")
          .setProduceDecl(writeCordTypeDecl))

      PROC writeVarByteStringType(WriteC gen, IO.File fd)
        IF !gen.manageMemory()
          fd.write(''"
void ZfreeVarByteString(Ty *p) {
 ZclearVarByteString(p);
 Zfree(p);
}
void ZclearVarByteString(Ty *p) {
 if (p->flags == ZbyteStringT_pieceval) {
  // TODO
  // Zfree(((Tv*)p->data)->data);
  Zfree(p->data);
 } else if (p->flags == ZbyteStringT_piece) {
  Zfree(p->data);
#if 0
 } else if (p->flags == ZbyteStringT_cord) {
  Zfree(((Tcd*)p->data)->data);
  Zfree(p->data);
#endif
 } else if (p->flags == ZbyteStringT_string) {
  // may be a static string
  // Zfree(p->data);
 }
}
"'')
        }
      }
      PROC writeVarByteStringTypeDecl(WriteC gen, IO.File fd)
        fd.write("struct ZvarByteString__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " union {\n"
              .. "  void *data;\n"
              .. "  Tc tiny[sizeof(void*)];\n"
              .. " };\n"
              .. " Ti byteSize;\n"
              .. " Ti charSize;\n"
              .. " /* short growsize; not used yet */\n"
              .. " Tc flags;\n"
              .. "};\n"
              .. "#define ZbyteStringT_mask     0x07\n"
              .. "#define ZbyteStringT_tiny     0\n"
              .. "#define ZbyteStringT_string   1\n"
              .. "#define ZbyteStringT_piece    2\n"
              .. "#define ZbyteStringT_pieceval 3\n"
              .. "#define ZbyteStringT_cord     4\n"
              # .. "\n"
              # .. "#define ZbyteString_cow       0x08\n"
              # .. "\n"
              # .. "#define ZbyteStringP_mask     0xe0\n"
              # .. "#define ZbyteStringP_default  0x00\n"
              # .. "#define ZbyteStringP_nocord   0x20\n"
              # .. "#define ZbyteStringP_minmem   0x40\n"
              # .. "#define ZbyteStringP_minalloc 0x80\n"
              .. (gen.manageMemory() ? "" : "void ZfreeVarByteString(Ty *p);\n")
              .. (gen.manageMemory() ? "" : "void ZclearVarByteString(Ty *p);\n")
              )
      }
      CodeWriter varByteStringFrag =
                               NEW(%varByteStringType, writeVarByteStringType)
          .setTypedef("typedef struct ZvarByteString__S Ty;")
          .setProduceDecl(writeVarByteStringTypeDecl)
      # TODO: only when memory is not managed
      varByteStringFrag.setDependencies([%zfree])
      codeWriters.add(varByteStringFrag)

      PROC writePiecevalTypeDecl(WriteC gen, IO.File fd)
        fd.write("struct Zpieceval__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Ti space;\n"
              .. " Ti offset;\n"
              .. " void *data;\n"
              .. "};\n")
      }

      codeWriters.add(NEW(%piecevalType)
          .setTypedef("typedef struct Zpieceval__S Tv;")
          .setProduceDecl(writePiecevalTypeDecl))

      PROC writePieceTypeDecl(WriteC gen, IO.File fd)
        fd.write("struct Zpiece__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Ti space;\n"
              .. " Ti offset;\n"
              .. "};\n")
      }

      codeWriters.add(NEW(%pieceType)
          .setTypedef("typedef struct Zpiece__S Tp;")
          .setProduceDecl(writePieceTypeDecl))

      # FOR x IN string
      codeWriters.add(NEW(Declaration.forString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZforStringNew(Tc *p, Tfs *s) {
 s->len = p == NULL ? 0 : ZstringSizePtr(p, &(s->ptr));
 s->idx = 0;
}
void ZforStringGetInt(Tfs *s, Ti *p) {
 if (s->idx >= s->len) *p = 0;
 else *p = ZfromChar(s->ptr + s->idx);
}
int ZforStringContInt(Tfs *s) {
return s->idx < s->len;
}
void ZforStringNextInt(Tfs *s, Ti *p) {
 if (s->idx < s->len) {
  ++(s->idx);
  while ((s->ptr[s->idx] & 0xc0) == 0x80) ++(s->idx);
 }
 ZforStringGetInt(s, p);
}
"'')
        }).setDependencies([%fromChar,
                            Declaration.throwCstringNil]))

      # FOR x IN byteString
      codeWriters.add(NEW(Declaration.forBytestring,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZforBytestringNew(void *p, Tfs *fs) {
 fs->len = p == NULL ? 0 : ZstringSizePtr(p, &(fs->ptr));
 fs->idx = 0;
}
void ZforBytestringGetInt(Tfs *fs, Ti *p) {
 if (fs->idx >= fs->len) *p = 0;
 else *p = fs->ptr[fs->idx];
}
int ZforBytestringContInt(Tfs *fs) {
 return fs->idx < fs->len;
}
void ZforBytestringNextInt(Tfs *fs, Ti *p) {
 if (fs->idx < fs->len) ++(fs->idx);
 ZforBytestringGetInt(fs, p);
}
"'')
        }).setDependencies([Declaration.throwCstringNil]))

      PROC writeForStringStruct(WriteC gen, IO.File fd)
        fd.write("struct ZforString__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Tc *ptr;\n"  # pointer to the first byte
              .. " Ti idx;\n"
              .. " Ti len;\n"
              .. "};\n")
      }
      codeWriters.add(NEW(%forStringStruct)
          .setTypedef("typedef struct ZforString__S Tfs; /* FOR in string */")
          .setProduceDecl(writeForStringStruct))

      PROC writeForArrayStruct(WriteC gen, IO.File fd)
        fd.write("struct ZforArray__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Ta *a;\n"
              .. " Ti i;\n"
              .. " Ti *keyp;\n"
              .. " void *valp;\n"
              .. "};\n")
      }
      codeWriters.add(NEW(%forArray)
          .setTypedef("typedef struct ZforArray__S Tfa; /* FOR in array */")
          .setProduceDecl(writeForArrayStruct))

      PROC writeForListStruct(WriteC gen, IO.File fd)
        fd.write("struct ZforList__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Tl *l;\n"
              .. " Ti i;\n"
              .. " Ti *keyp;\n"
              .. " void *valp;\n"
              .. "};\n")
      }
      codeWriters.add(NEW(%forList)
          .setTypedef("typedef struct ZforList__S Tfl; /* FOR in list */")
          .setProduceDecl(writeForListStruct))

      PROC writeForDictStruct(WriteC gen, IO.File fd)
        fd.write("struct ZforDict__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Td *d;\n"
              .. " CDictItem *di;\n"
              .. " Ti todo;\n"
              .. " void *keyp;\n"
              .. " void *valp;\n"
              .. "};\n")
      }
      codeWriters.add(NEW(%forDict)
          .setTypedef("typedef struct ZforDict__S Tfd; /* FOR in dict */")
          .setProduceDecl(writeForDictStruct))

      # FOR x IN start TO end [STEP step]
      codeWriters.add(NEW(%forRange,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZforRangeNew(Ti start, Ti last, int until, Ti step, Tfr *s) {
 s->idx = start;
 if (until)
  s->last = last - (step > 0 ? 1 : -1);
 else
  s->last = last;
 s->step = step;
}
void ZforRangeGetInt(Tfr *s, Ti *p) {
 *p = s->idx;
}
int ZforRangeContInt(Tfr *s) {
 return s->step > 0 ? (s->idx <= s->last) : (s->idx >= s->last);
}
void ZforRangeNextInt(Tfr *s, Ti *p) {
 Ti idx = *p + s->step;
 s->idx = idx;
 *p = idx;
}
"'')
        }).setTypedef("typedef struct ZforRange__S Tfr; /* FOR in range */")
          .setDecl("struct ZforRange__S {\n"
                .. " Ti idx;\n"
                .. " Ti step;\n"
                .. " Ti last;\n"
                .. "};\n"))

      # FOR x IN enum
      codeWriters.add(NEW(%forEnum,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZforEnumGetEnum(Tfe *fe, Te *p) {
 *p = fe->idx;
}
int ZforEnumContEnum(Tfe *fe) {
 return fe->idx < fe->count;
}
void ZforEnumNextEnum(Tfe *fe, Te *p) {
 if (fe->idx < fe->count)
  ++(fe->idx);
 *p = fe->idx;
}
"'')
        }).setTypedef("typedef struct ZforEnum__S Tfe; /* FOR in enum */")
          .setDecl("struct ZforEnum__S {\n"
                .. " int count;\n"
                .. " int idx;\n"
                .. "};"))

      # The stack of TRY/CATCH and thrown exceptions.
      codeWriters.add(NEW(Declaration.try,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZtryDeeper(Tn *e, Zsf *sf) {
 if (e->tryCtx == NULL) {
  e->tryCtxSize = 20;
  e->tryCtx = ZaNm(sizeof(Ttc) * e->tryCtxSize);
  e->tryCtxUsed = 1;
 } else if (++e->tryCtxUsed > e->tryCtxSize) {
  e->tryCtxSize += 20;
  e->tryCtx = ZranNm(e->tryCtx, sizeof(Ttc) * (e->tryCtxSize - 20), sizeof(Ttc) * e->tryCtxSize);
 }
 e->tryCtx[e->tryCtxUsed - 1].sf = sf;
}
void Zrethrow() {
 Tn *e = "'' .. gen.getEnvCode() .. ''";
 ZthrowIobject(e->thrown[--e->thrownUsed]);
}
"'')
        }).setDependencies([Declaration.throwObject]))

      codeWriters.add(NEW(Declaration.throwObject,
        PROC (WriteC gen, IO.File fd)
          string unhandled = DeclStore.getPName("MEModule", "FunhandledException")
          
          # ZthrowIobject handles the exception and jumps back to the CATCH.
          # If there is no TRY/CATCH call E.unhandledException().
          fd.write(''"
void ZthrowIobject("'' .. exceptionPname() .. ''" *eo) {"'')

        # If there is any TRY jump there.  Put the exception on the stack.
        # Call Finish() for objects on the stack in frames that are going to
        # be dropped.
        IF gen.isDeclUsed(Declaration.try)
          fd.write(''"
 Tn *e = "'' .. gen.getEnvCode() .. ''";
 Ttc *ctx = &e->tryCtx[e->tryCtxUsed - 1];"'')
          IF (gen.isDeclUsed(Declaration.hasFinish)
                                         || gen.isDeclUsed(Declaration.defer))
              && gen.hasNpField()
            fd.write(''"
 int i;
 Zsf *stop = NULL;
 if (e->tryCtxUsed > 0) stop = ctx->sf;
 while ("'' .. gen.topFrameName() .. ''" != stop) {
  Zfo *fo = "'' .. gen.topFrameName() .. ''"->frof;
  if (fo != NULL) {
   i = 0;
   while (fo[i].off != 0) ++i;
   while (--i >= 0) {
    Tto *tto = (Tto*)fo[i].type;"'')
            IF gen.isDeclUsed(Declaration.hasFinish)
              fd.write(''"
    if (tto->nr == 390 && tto->Finish != NULL && (fo[i].off & 1)) {
     Zohf *p = (Zohf*)((char *)"'' .. gen.topFrameName() .. ''" - (fo[i].off - 1));
     if (p->np != NULL) {
      ZcallFinish(p, 2);
      p->np = NULL;
     }
    } else if (tto->nr == 391 && (fo[i].off & 1)) {
     ZFinishIobj((Tr*)((char *)"'' .. gen.topFrameName() .. ''" - (fo[i].off - 1)), 2);
    } else if (tto->nr == 392 && (fo[i].off & 1)) {
     ZFinishXobj(((char *)"'' .. gen.topFrameName() .. ''" - (fo[i].off - 1)), 2);"'')
            }
            IF gen.isDeclUsed(Declaration.defer)
              fd.write("\n    ")
              IF gen.isDeclUsed(Declaration.hasFinish)
                fd.write("} else ")
              }
              fd.write(''"if ((Tt*)tto == &defer__T) {
     ZdeferCall((Tl*)((char *)"'' .. gen.topFrameName() .. ''" - (fo[i].off - 1)));"'')
            }
            fd.write(''"
    }
   }
  }
  if ("'' .. gen.topFrameName() .. ''"->prev == NULL) break;
  "'' .. gen.topFrameName() .. ''" = "'' .. gen.topFrameName() .. ''"->prev;
 }"'')
          }
          fd.write(''"
 if (e->tryCtxUsed > 0) {
  if (e->thrown == NULL) {
   e->thrownSize = 10;
   e->thrown = ZaNmi(sizeof(Tr) * e->thrownSize);
   e->thrownUsed = 1;
  } else if (++e->thrownUsed > e->thrownSize) {
   e->thrownSize += 20;
   e->thrown = ZranNm(e->thrown, sizeof(Tr) * (e->thrownSize - 20), sizeof(Tr *) * e->thrownSize);
  }
  e->thrown[e->thrownUsed - 1] = eo;
  longjmp(ctx->jmpBuf, 42);
 } else"'')
        }
        # If there is no TRY print the exception and exit.
        fd.write("\n " .. unhandled .. ''"(eo);
}"'')
        }).setDependencies([["MEModule", "FunhandledException"]])
          .addCondDepends(Declaration.hasFinish, %finishIobj)
          .setDecl("void ZthrowObject(Tr *eo);\nvoid ZthrowIobject("
              .. exceptionPname() .. " *eo);"))

      PROC writeGaAppend(WriteC gen, IO.File fd)
        fd.write(''"
void ga_append(Tg *ga, char *str) {
 int len = (int)strlen(str);
 if (ga->data == NULL || ga->used + len >= ga->len) {
  int newLen = ga->used + len + 200;
  Tc *newData = ZaOff(newLen);
  if (ga->data != NULL) {
    memmove(newData, ga->data, ga->used);"'')
        IF !gen.manageMemory()
          fd.write(''"
    Zfree(ga->data - ZOH_OFF);"'')
        }
        fd.write(''"
  }
  ga->data = newData;
  ga->len = newLen;
 }
 strcpy((char *)ga->data + ga->used, str);
 ga->used += len;
}
"'')
      }
      CodeWriter garrayFrag = NEW(%garray, writeGaAppend)
          .setTypedef("typedef struct garray__S Tg; /* grow array */")
          .setDecl("struct garray__S {\n"
                .. " Tc *data;\n"
                .. " int used;\n"
                .. " int len;\n"
                .. "};")
      # TODO: zfree only when not managing memory
      garrayFrag.setDependencies([%string_h, %zfree])
      codeWriters.add(garrayFrag)

      codeWriters.add(NEW(Declaration.byteStringHash,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tu ZbyteStringHash(Tc *s) {
 Tc *p;
 Ti l;
 Tu hash;
 if (s == NULL) return 0;
 l = ZstringSizePtr(s, &p);
 if (l == 0) return 0;
 hash = *p;
 while (--l > 0) {
  hash = hash * 101 + *++p;
 }
 return hash;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.varByteStringHash,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarByteStringHash(Ty *b) {
 if (b == NULL) return 0;
 return b->byteHash;
}
"'')
        }).setDependencies([%varByteStringType]))


      # Note: only returns 0 or 1, cannot be used for sorting.
      codeWriters.add(NEW(%stringCmp,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZstringCmp(Tc *s1, Tc *s2) {
 Tc *p1;
 Tc *p2;
 Ti len1;
 Ti len2;
 int r;
 if (s1 == NULL || s2 == NULL) {
  if (s1 == NULL && s2 == NULL) r = 0;
  else r = 1;
  goto end;
 }
 if (s1[ZOH_OFF] != s2[ZOH_OFF]) {
  r = 1;
  goto end;
 }
 len1 = ZstringSizePtr(s1, &p1);
 len2 = ZstringSizePtr(s2, &p2);
 if (len1 == len2) {
  r = memcmp(p1, p2, len1);
  goto end;
 }
 r = 1;
end:
 return r;
}
"'')
        }).setDependencies([%string_h]))

      # TODO: varByteStringCmp

      codeWriters.add(NEW(%char2byteIdxEnd,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZChar2ByteIdxEnd(Tc *p, Ti len, Ti charIdx) {
 Ti idx = len;
 Ti count = 0;
 while (count < charIdx) {
  if (idx == 0) return -1;
  --idx;
  while (idx > 0 && (p[idx] & 0xc0) == 0x80)
    --idx;
  ++count;
 }
 return idx;
}
"'')
        }))

      codeWriters.add(NEW(%stringFindLen,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFindLen(Tc *big, Ti biglen, Tc *small, Ti smalllen) {
 Ti i;
 Ti ci = 0;
 for (i = 0; i <= biglen - smalllen; ++ci) {
  if (memcmp(big + i, small, smalllen) == 0)
   return ci;
  ++i;
  while ((big[i] & 0xc0) == 0x80 && i < biglen)
   ++i;
 }
 return -1;
}
"'')
        }).setDependencies([%string_h]))

      codeWriters.add(NEW(Declaration.stringCompare,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringCompare(Tc *one, Tc *two, int dn) {
 Tc *onep;
 Tc *twop;
 Ti onelen;
 Ti twolen;
 Ti r;
 size_t len;
 if (one == NULL) {
  if (!dn) ZthrowCstringNil("using Compare() on NIL");
  if (two == NULL) r = 0;
  else r = -1;
 } else {
  if (two == NULL) ZthrowCstringNil("using Compare() with NIL argument");
  onelen = ZstringSizePtr(one, &onep);
  twolen = ZstringSizePtr(two, &twop);
  len = onelen < twolen ? onelen : twolen;
  r = memcmp(onep, twop, len);
  if (r == 0) r = onelen - twolen;
  if (r < 0) r = -1;
  else if (r > 0) r = 1;
 }
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringEqual,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringEqual(Tc *one, Tc *two, int dn) {
 Tc *onep;
 Tc *twop;
 Ti onelen;
 Ti twolen;
 Ti r;
 if (one == NULL) {
  if (!dn) ZthrowCstringNil("using Equal() on NIL");
  r = (two == NULL);
 } else {
  if (two == NULL) return 0;
  onelen = ZstringSizePtr(one, &onep);
  twolen = ZstringSizePtr(two, &twop);
  r = onelen == twolen && memcmp(onep, twop, onelen) == 0;
 }
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringFind,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFind(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  smalllen = ZstringSizePtr(small, &smallp);
  r = ZstringFindLen(bigp, biglen, smallp, smalllen);
 }
 return r;
}
"'')
        }).setDependencies([%stringFindLen, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringFind2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFind2(Tc *big, Tc *small, long start, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 Ti i = start;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  while (biglen > 0 && i > 0) {
   --i;
   while (biglen > 1 && (*bigp & 0xc0) == 0x80) {
    ++bigp;
    --biglen;
   }
   ++bigp;
   --biglen;
  }
  if (i == 0) {
   smalllen = ZstringSizePtr(small, &smallp);
   r = ZstringFindLen(bigp, biglen, smallp, smalllen);
   if (r >= 0) r += start;
  } else {
   r = -1;
  }
 }
 return r;
}
"'')
        }).setDependencies([%stringFindLen, Declaration.throwCstringNil]))

      codeWriters.add(NEW(%stringFindLastLen,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFindLastLen(Tc *big, Ti biglen, Tc *small, Ti smalllen) {
 Ti i;
 Ti ci = 0;
 Ti best = -1;
 for (i = 0; i <= biglen - smalllen; ++ci) {
  if (memcmp(big + i, small, smalllen) == 0)
   best = ci;
  ++i;
  while ((big[i] & 0xc0) == 0x80 && i < biglen)
   ++i;
 }
 return best;
}
"'')
        }).setDependencies([%string_h]))

      codeWriters.add(NEW(Declaration.stringFindLast,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFindLast(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using findLast() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  smalllen = ZstringSizePtr(small, &smallp);
  r = ZstringFindLastLen(bigp, biglen, smallp, smalllen);
 }
 return r;
}
"'')
        }).setDependencies([%stringFindLastLen, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringFind,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringFind(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = ZstringFindLen(bigp, big->byteSize, smallp, small->byteSize);
 }
 return r;
}
"'')
        }).setDependencies([%stringFindLen, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringFindLast,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringFindLast(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using findLast() with NIL argument");
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = ZstringFindLastLen(bigp, big->byteSize, smallp, small->byteSize);
 }
 return r;
}
"'')
        }).setDependencies([%stringFindLastLen, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%byteStringFindC,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringFindC(Tc *big, Ti biglen, Tc *small, Ti smalllen) {
 Ti i;
 for (i = 0; i <= biglen - smalllen; ++i) {
  if (memcmp(big + i, small, smalllen) == 0)
   return i;
 }
 return -1;
}
"'')
        }).setDependencies([%string_h]))

      codeWriters.add(NEW(%byteStringFindLastC,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringFindLastC(Tc *big, Ti biglen, Tc *small, Ti smalllen) {
 Ti i;
 for (i = biglen - smalllen; i >= 0; --i) {
  if (memcmp(big + i, small, smalllen) == 0)
   return i;
 }
 return -1;
}
"'')
        }).setDependencies([%string_h]))

      codeWriters.add(NEW(Declaration.byteStringFind,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringFind(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  smalllen = ZstringSizePtr(small, &smallp);
  r = ZbyteStringFindC(bigp, biglen, smallp, smalllen);
 }
 return r;
}
"'')
        }).setDependencies([%byteStringFindC, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.byteStringFindLast,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringFindLast(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using findLast() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  smalllen = ZstringSizePtr(small, &smallp);
  r = ZbyteStringFindLastC(bigp, biglen, smallp, smalllen);
 }
 return r;
}
"'')
        }).setDependencies([%byteStringFindLastC, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varByteStringFind,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarByteStringFind(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = ZbyteStringFindC(bigp, big->byteSize, smallp, small->byteSize);
 }
 return r;
}
"'')
        }).setDependencies([%byteStringFindC, %byteStringPtr,
                          Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varByteStringFindLast,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarByteStringFindLast(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using findLast() with NIL argument");
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = ZbyteStringFindLastC(bigp, big->byteSize, smallp, small->byteSize);
 }
 return r;
}
"'')
        }).setDependencies([%byteStringFindLastC, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%ptrFindChar2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZptrFindChar2(Tc *s, Ti slen, Ti c, Ti low) {
 Tc *p = s;
 Ti idx = 0;
 Ti len;
 Tc buf[5];
 int charlen;
 int clen = Zchar2stringBuf(c, buf);
 for (len = slen; len > 0; len -= charlen) {
  for (charlen = 1; (p[charlen] & 0xc0) == 0x80; ++charlen)
   ;
  if (charlen == clen && memcmp(buf, p, charlen) == 0 && idx >= low) {
   return idx;
  }
  p += charlen;
  ++idx;
 }
 return -1;
}
"'')
        }).setDependencies([%string_h, %toCharBuf]))

      codeWriters.add(NEW(Declaration.stringFindChar2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFindChar2(Tc *s, Ti c, Ti low, int dn) {
 Tc *p;
 int len;
 Ti r;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  len = ZstringSizePtr(s, &p);
  r = ZptrFindChar2(p, len, c, low);
 }
 return r;
}
"'')
        }).setDependencies([%ptrFindChar2, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringFindChar,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFindChar(Tc *s, Ti c, int dn) {
 return ZstringFindChar2(s, c, 0, dn);
}
"'')
        }).setDependencies([Declaration.stringFindChar2]))

      codeWriters.add(NEW(Declaration.varStringFindChar2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringFindChar2(Ty *b, Ti c, Ti low, int dn) {
 Ti r;
 if (b == NULL) {
  if (dn) return -1;
  ZthrowCstringNil("using find() on NIL");
 }
 r = ZptrFindChar2(ZvarByteStringPtr(b), b->byteSize, c, low);
 return r;
}
"'')
        }).setDependencies([%ptrFindChar2, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringFindChar,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringFindChar(Ty *b, Ti c, int dn) {
 return ZvarStringFindChar2(b, c, 0, dn);
}
"'')
        }).setDependencies([Declaration.varStringFindChar2,
                            %varByteStringType]))

      codeWriters.add(NEW(Declaration.stringStartsWith,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tb ZstringStartsWith(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Tb r = 0;
 if (big == NULL) {
  if (dn) goto end;
  ZthrowCstringNil("using startsWith() on NIL");
 }
 if (small == NULL) ZthrowCstringNil("using startsWith() with NIL argument");
 biglen = ZstringSizePtr(big, &bigp);
 smalllen = ZstringSizePtr(small, &smallp);
 if (smalllen <= biglen) r = memcmp(bigp, smallp, smalllen) == 0;
end:
 return r;
}
"'')
        }).setDependencies([%string_h, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringEndsWith,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tb ZstringEndsWith(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Tb r = 0;
 if (big == NULL) {
  if (dn) goto end;
  ZthrowCstringNil("using endsWith() on NIL");
 }
 if (small == NULL) ZthrowCstringNil("using endsWith() with NIL argument");
 biglen = ZstringSizePtr(big, &bigp);
 smalllen = ZstringSizePtr(small, &smallp);
 if (smalllen <= biglen) r = memcmp(bigp + biglen - smalllen, smallp, smalllen) == 0;
end:
 return r;
}
"'')
        }).setDependencies([%string_h, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringStartsWith,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tb ZvarStringStartsWith(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Tb r = 0;
 if (big == NULL) {
  if (dn) goto end;
  ZthrowCstringNil("using startsWith() on NIL");
 }
 if (small == NULL) ZthrowCstringNil("using startsWith() with NIL argument");
 if (small->byteSize <= big->byteSize) {
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = memcmp(bigp, smallp, small->byteSize) == 0;
 }
end:
 return r;
}
"'')
        }).setDependencies([%string_h, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringEndsWith,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tb ZvarStringEndsWith(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Tb r = 0;
 if (big == NULL) {
  if (dn) goto end;
  ZthrowCstringNil("using endsWith() on NIL");
 }
 if (small == NULL) ZthrowCstringNil("using endsWith() with NIL argument");
 if (small->byteSize <= big->byteSize) {
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = memcmp(bigp + big->byteSize - small->byteSize, smallp, small->byteSize) == 0;
 }
end:
 return r;
}
"'')
        }).setDependencies([%string_h, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(%ptrFindLastChar2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZptrFindLastChar2(Tc *s, Ti slen, Ti c, Ti high) {
 Tc *p = s;
 Ti idx = 0;
 Ti best = -1;
 Ti len;
 Tc buf[5];
 int charlen;
 int clen = Zchar2stringBuf(c, buf);
 for (len = slen; len > 0 && idx <= high; len -= charlen) {
  for (charlen = 1; (p[charlen] & 0xc0) == 0x80; ++charlen)
   ;
  if (charlen == clen && memcmp(buf, p, charlen) == 0)
   best = idx;
  p += charlen;
  ++idx;
 }
 return best;
}
"'')
        }).setDependencies([%string_h, %toCharBuf]))

      codeWriters.add(NEW(Declaration.stringFindLastChar2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFindLastChar2(Tc *s, Ti c, Ti high, int dn) {
 Tc *p;
 int len;
 Ti r;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  len = ZstringSizePtr(s, &p);
  r = ZptrFindLastChar2(p, len, c, high);
 }
 return r;
}
"'')
        }).setDependencies([%ptrFindLastChar2,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringFindLastChar,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringFindLastChar(Tc *s, Ti c, int dn) {
 Tc *p;
 int len;
 Ti r;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  len = ZstringSizePtr(s, &p);
  r = ZptrFindLastChar2(p, len, c, len);
 }
 return r;
}
"'')
        }).setDependencies([%ptrFindLastChar2, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringFindLastChar2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringFindLastChar2(Ty *b, Ti c, Ti high, int dn) {
 Ti r;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else r = ZptrFindLastChar2(ZvarByteStringPtr(b), b->byteSize, c, high);
 return r;
}
"'')
        }).setDependencies([%ptrFindLastChar2, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringFindLastChar,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringFindLastChar(Ty *b, Ti c, int dn) {
 return ZvarStringFindLastChar2(b, c, b ? b->byteSize : 0, dn);
}
"'')
        }).setDependencies([Declaration.varStringFindLastChar2,
                            %varByteStringType]))

      codeWriters.add(NEW(Declaration.byteStringFindByte2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringFindByte2(Tc *s, Ti c, Ti low, int dn) {
 Ti len;
 Tc *p;
 Ti i;
 Ti r = -1;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("find() argument out of range");
  len = ZstringSizePtr(s, &p);
  for (i = low; i < len; ++i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(Declaration.byteStringFindByte,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringFindByte(Tc *s, Ti c, int dn) {
 return ZbyteStringFindByte2(s, c, 0, dn);
}
"'')
        }).setDependencies([Declaration.byteStringFindByte2]))

      codeWriters.add(NEW(Declaration.byteStringFindLastByte2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringFindLastByte2(Tc *s, Ti c, Ti high, int dn) {
 Ti len;
 Tc *p;
 Ti i;
 Ti r = -1;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("findLast() argument out of range");
  len = ZstringSizePtr(s, &p);
  for (i = high >= len ? len - 1 : high; i >= 0; --i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(Declaration.byteStringFindLastByte,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZbyteStringFindLastByte(Tc *s, Ti c, int dn) {
 Ti len;
 Tc *p;
 Ti i;
 Ti r = -1;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("findLast() argument out of range");
  len = ZstringSizePtr(s, &p);
  for (i = len - 1; i >= 0; --i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(Declaration.varByteStringFindByte2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarByteStringFindByte2(Ty *b, Ti c, Ti low, int dn) {
 Tc *p;
 Ti i;
 Ti r = -1;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("find() argument out of range");
  p = ZvarByteStringPtr(b);
  for (i = low; i < b->byteSize; ++i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
        }).setDependencies([%byteStringPtr, Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(Declaration.varByteStringFindByte,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarByteStringFindByte(Ty *b, Ti c, int dn) {
 return ZvarByteStringFindByte2(b, c, 0, dn);
}
"'')
        }).setDependencies([Declaration.varByteStringFindByte2,
                            %varByteStringType]))

      codeWriters.add(NEW(Declaration.varByteStringFindLastByte2,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarByteStringFindLastByte2(Ty *b, Ti c, Ti high, int dn) {
 Tc *p;
 Ti i;
 Ti r = -1;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("findLast() argument out of range");
  p = ZvarByteStringPtr(b);
  for (i = (high >= b->byteSize) ? b->byteSize - 1 : high; i >= 0; --i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
        }).setDependencies([%byteStringPtr, Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(Declaration.varByteStringFindLastByte,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarByteStringFindLastByte(Ty *b, Ti c, int dn) {
 return ZvarByteStringFindLastByte2(b, c, b ? b->byteSize : 0, dn);
}
"'')
        }).setDependencies([Declaration.varByteStringFindLastByte2,
                            %varByteStringType]))

      codeWriters.add(NEW(%stringSplitLen,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tl *ZstringSplitLen(Tc *pss, Ti len, Tc *m) {
 Tl *head = ZnewList(&string__T, 0);
 if (len > 0) {
  Tc *mp;
  Ti mlen = ZstringSizePtr(m, &mp);
  Tc *ps;
  Tc *pe;

  for (ps = pss; ; ps = pe + mlen) {
   int nlen;
   /* TODO: handle NULL byteString */
   pe = (Tc*)strstr((char *)ps, (char *)mp);
   if (pe == NULL) {
    nlen = len - (ps - pss);
   } else {
    nlen = pe - ps;
   }
   ZLa(head, -1, (Tz)(void*)ZnewString(ps, nlen));
   if (pe == NULL) break;
  }
 }
 return head;
}
"'')
        }).setDependencies([%string_h]))

      codeWriters.add(NEW(Declaration.stringSplit,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tl *ZstringSplit(Tc *b, Tc *m) {
 Tc *p;
 Ti len;
 Tl *r;
 if (b == NULL) {
  r = NULL;
 } else {
  if (m == NULL) ZthrowCstringNil("split() argument is NIL");
  len = ZstringSizePtr(b, &p);
  r = ZstringSplitLen(p, len, m);
 }
 return r;
}
"'')
        }).setDependencies([%stringSplitLen, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringSplit,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tl *ZvarStringSplit(Ty *b, Tc *m) {
 Tl *r;
 if (b == NULL) {
  r = NULL;
 } else {
  if (m == NULL) ZthrowCstringNil("split() argument is NIL");
  r = ZstringSplitLen(ZvarByteStringPtr(b), b->byteSize, m);
 }
 return r;
}
"'')
        }).setDependencies([%stringSplitLen, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.byteStringSplit,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tl *ZbyteStringSplit(Tc *b, Tc *m) {
 return ZstringSplit(b, m);
}
"'')
        }).setDependencies([Declaration.stringSplit]))

      codeWriters.add(NEW(Declaration.varByteStringSplit,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tl *ZvarByteStringSplit(Ty *b, Tc *m) {
 Tl *r;
 if (b == NULL) {
  r = NULL;
 } else {
  if (m == NULL) ZthrowCstringNil("split() argument is NIL");
  r = ZstringSplitLen(ZvarByteStringPtr(b), b->byteSize, m);
 }
 return r;
}
"'')
        }).setDependencies([%stringSplitLen, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringSliceWrap,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZstringSliceWrap(Tc *sv, Ti start, Ti end) {
 Ti is;
 Ti ie;
 Tc *p;
 Ti len;
 Tc *r;
 if (sv == NULL) return NULL;
 len = ZstringSizePtr(sv, &p);
 is = start < 0 ? ZChar2ByteIdxEnd(p, len, -start) : ZChar2ByteIdx(p, len, start);
 ie = end < 0 ? ZChar2ByteIdxEnd(p, len, -end - 1) - 1 : ZChar2ByteIdx(p, len, end + 1) - 1;
 if (is < 0)
  is = 0;
 if (ie < 0 || ie < is) r = ZnewString((Tc*)"", 0);
 else r = ZnewString(p + is,  ie - is + 1);
 return r;
}
"'')
        }).setDependencies([%string_h, Declaration.throwCstringNil,
                            %char2byteIdx, %char2byteIdxEnd]))

      # Note: varStringSliceWrap depends on varByteStringSliceWrap thus
      # varByteStringSliceWrap must come first.
      codeWriters.add(NEW(Declaration.varByteStringSliceWrap,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZvarByteStringSliceWrap(Ty *b, Ti start, Ti end) {
 Ty *newb;
 Ti is;
 Ti ie;
 if (b == NULL) return NULL;
 is = start < 0 ? b->byteSize + start : start;
 ie = end < 0 ? b->byteSize + end : end;
 if (is < 0) is = 0;
 if (is > b->byteSize) is = b->byteSize;
 if (ie < is - 1) ie = is - 1;
 if (ie >= b->byteSize) ie = b->byteSize - 1;
 newb = Za(sizeof(Ty));
 newb->byteSize = ie - is + 1;
 newb->charSize = -1;
 if (newb->byteSize < sizeof(void*)) {
  /* put data in tiny[] */
  ZbyteStringWriteTo(b, newb->tiny, is, newb->byteSize);
  newb->tiny[newb->byteSize] = 0;
  newb->flags = ZbyteStringT_tiny;
 } else {
  /* use a Tv */
  Tv *pieceval = Za(sizeof(Tv));
  newb->data = pieceval;
  newb->flags = ZbyteStringT_pieceval;
  pieceval->data = ZvarByteStringPtr(b);
  pieceval->offset = is;
  pieceval->space = b->byteSize;
 }
 return newb;
}
"'')
        }).setDependencies([%string_h,
                            Declaration.throwCstringNil,
                            %piecevalType,
                            %byteStringPtr,
                            %byteStringWriteTo]))

      codeWriters.add(NEW(Declaration.varStringSliceWrap,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZvarStringSliceWrap(Ty *b, Ti start, Ti end) {
 Ti is;
 Ti ie;
 Tc *p;
 if (b == NULL) return NULL;
 p = ZvarByteStringPtr(b);
 is = start < 0 ? ZChar2ByteIdxEnd(p, b->byteSize, -start) : ZChar2ByteIdx(p, b->byteSize, start);
 ie = end < 0 ? ZChar2ByteIdxEnd(p, b->byteSize, -end - 1) - 1 : ZChar2ByteIdx(p, b->byteSize, end + 1) - 1;
 if (ie < 0) {
  Ty *newb = Za(sizeof(Ty));
  newb->tiny[0] = 0;
  newb->flags = ZbyteStringT_tiny;
  return newb;
 }
 if (is < 0) is = 0;
 return ZvarByteStringSliceWrap(b, is, ie);
}
"'')
        }).setDependencies([%string_h, Declaration.throwCstringNil,
                            Declaration.varByteStringSliceWrap, %byteStringPtr,
                            %char2byteIdx, %char2byteIdxEnd]))

      codeWriters.add(NEW(Declaration.byteStringSliceWrap,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZbyteStringSliceWrap(Tc *b, Ti start, Ti end) {
 Tc *p;
 Ti is;
 Ti ie;
 Ti len;
 Tc *r;
 if (b == NULL) return NULL;
 len = ZstringSizePtr(b, &p);
 is = start < 0 ? len + start : start;
 if (is < 0) is = 0;
 ie = end < 0 ? len + end : end;
 if (ie >= len) ie = len - 1;
 if (ie < 0 || ie < is) r = ZnewString((Tc*)"", 0);
 else r = ZnewString(p + is,  ie - is + 1);
 return r;
}
"'')
        }).setDependencies([%string_h, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringConcatAssign,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZvarStringConcatAssign(Ty *b, Tc *r) {
 Tc *p;
 Ti r_len;
 Ti len;
 if (b == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (r == NULL) ZthrowCstringNil("Concatenating NIL to a string");
 r_len = ZstringSizePtr(r, &p);
 len = b->byteSize + r_len;
 if (len < sizeof(void*)) {
  if ((b->flags & ZbyteStringT_mask) != ZbyteStringT_tiny) {
   ZbyteStringWriteTo(b, b->tiny, 0, b->byteSize);
   b->flags = ZbyteStringT_tiny;
  }
  memmove(b->tiny + b->byteSize, p, r_len + 1);
 } else {
  /* TODO: when b is immutable can use a Tcd */
  /* TODO: when b is Tp with space write there */
  /* put data in Tp */
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  ZbyteStringWriteTo(b, zp, 0, b->byteSize);
  memmove(zp + b->byteSize, p, r_len + 1);
  b->data = piece;
  b->flags = ZbyteStringT_piece;
 }
 b->byteSize = len;
}
"'')
        }).setDependencies([%string_h, %varByteStringType,
                            %pieceType, %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.concatVarStringBB,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZconcatVarStringBB(Ty *le, Ty *ri) {
 Ty *r;
 Ti len;
 if (le == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (ri == NULL) ZthrowCstringNil("Concatenating NIL to a string");
 r = (Ty *)Za(sizeof(Ty));
 len = le->byteSize + ri->byteSize;
 if (len < sizeof(void*)) {
  r->flags = ZbyteStringT_tiny;
  ZbyteStringWriteTo(le, r->tiny, 0, le->byteSize);
  ZbyteStringWriteTo(ri, r->tiny + le->byteSize, 0, ri->byteSize);
  r->tiny[len] = 0;
 } else {
  /* TODO: when le and/or ri is immutable can use a Tcd */
  /* put data in Tp */
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  piece->offset = 0;
  ZbyteStringWriteTo(le, zp, 0, le->byteSize);
  ZbyteStringWriteTo(ri, zp + le->byteSize, 0, ri->byteSize);
  zp[len] = 0;
  r->data = piece;
  r->flags = ZbyteStringT_piece;
 }
 r->byteSize = len;
 return r;
}
"'')
        }).setDependencies([%string_h,
                            %varByteStringType,
                            %pieceType,
                            %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.concatVarStringBV,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZconcatVarStringBV(Ty *le, Tc *ri) {
 Ty *r;
 Tc *p;
 Ti r_len;
 Ti len;
 if (le == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (ri == NULL) ZthrowCstringNil("Concatenating NIL to a string");
 r = (Ty *)Za(sizeof(Ty));
 r_len = ZstringSizePtr(ri, &p);
 len = le->byteSize + r_len;

 if (len < sizeof(void*)) {
  r->flags = ZbyteStringT_tiny;
  ZbyteStringWriteTo(le, r->tiny, 0, le->byteSize);
  memmove(r->tiny + le->byteSize, p, r_len + 1);
 } else {
  /* TODO: when le is immutable can use a Tcd */
  /* put data in Tp */
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  ZbyteStringWriteTo(le, zp, 0, le->byteSize);
  memmove(zp + le->byteSize, p, r_len + 1);
  r->data = piece;
  r->flags = ZbyteStringT_piece;
 }
 r->byteSize = len;
 return r;
}
"'')
        }).setDependencies([%string_h,
                            %varByteStringType,
                            %pieceType,
                            %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.concatVarStringVB,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZconcatVarStringVB(Tc *le, Ty *ri) {
 Ty *r;
 Tc *p;
 Ti l_len;
 Ti len;
 if (le == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (ri == NULL) ZthrowCstringNil("Concatenating NIL to a string");
 r = (Ty *)Za(sizeof(Ty));
 l_len = ZstringSizePtr(le, &p);
 len = l_len + ri->byteSize;
 if (len < sizeof(void*)) {
  r->flags = ZbyteStringT_tiny;
  memmove(r->tiny, p, l_len);
  ZbyteStringWriteTo(ri, r->tiny + l_len, 0, ri->byteSize);
  r->tiny[len] = 0;
 } else {
  /* TODO: when le is immutable can use a Tcd */
  /* put data in Tp */
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  piece->offset = 0;
  memmove(zp, p, l_len);
  ZbyteStringWriteTo(ri, zp + l_len, 0, ri->byteSize);
  zp[len] = 0;
  r->data = piece;
  r->flags = ZbyteStringT_piece;
 }
 r->byteSize = len;
 return r;
}
"'')
        }).setDependencies([%string_h,
                            %varByteStringType,
                            %pieceType,
                            %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.concatVarStringVV,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ty *ZconcatVarStringVV(Tc *le, Tc *ri) {
 Ty *r;
 Tc *l_p;
 Ti l_len;
 Tc *r_p;
 Ti r_len;
 Ti len;
 if (le == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (ri == NULL) ZthrowCstringNil("Concatenating NIL to a varString");
 r = (Ty *)Za(sizeof(Ty));
 l_len = ZstringSizePtr(le, &l_p);
 r_len = ZstringSizePtr(ri, &r_p);
 len = l_len + r_len;
 if (len < sizeof(void*)) {
  r->flags = ZbyteStringT_tiny;
  memmove(r->tiny, l_p, l_len);
  memmove(r->tiny + l_len, r_p, r_len + 1);
 } else {
#if 0
  /* do not create a Cord for now */
  Tcd *l_cord = ZcordFromBytesval(le);
  Tcd *r_cord = ZcordFromBytesval(ri);
  r->flags = ZbyteStringT_cord;
  r->data = l_cord;
  l_cord->next = r_cord;
#else
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  memmove(zp, l_p, l_len);
  memmove(zp + l_len, r_p, r_len + 1);
  r->data = piece;
  r->flags = ZbyteStringT_piece;
#endif
 }
 r->byteSize = len;
 return r;
}
"'')
# not used
#Tcd *ZcordFromBytesval(Tc *bv) {
#  Tcd *r = Za(sizeof(Tcd));
#  Tc *p;
#  r->type = ZbyteStringT_string;
#  r->byteSize = ZstringSizePtr(bv, &p);
#  r->data = p;
#  return r;
#}
        }).setDependencies([%string_h,
                            %varByteStringType,
                            %pieceType,
                            %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.ptrToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZptrToInt(Tc *s, int t, Ti def) {
 Ti r;
 char *p = (char*)s;
 if ((*p < '0' || *p > '9') && *p != '-') {
  if (t == 1) ZthrowCstringBadValue("toInt(): argument does not start with a digit or -");
  return def;
 }
 sscanf(p, ZINT_FORMAT, &r);
 return r;
}
"'')
        }).setDependencies([Declaration.throwCstringBadValue]))

      codeWriters.add(NEW(%ptrQuotedToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZptrQuotedToInt(Tc *s, int t, Ti def) {
 Ti r = 0;
 Ti m = 1;
 Tc *p = s;
 if (*p == '-') { ++p; m = -1; }
 if (*p < '0' || *p > '9') {
  if (t == 1) ZthrowCstringBadValue("quotedToInt(): argument does not start with a digit or -");
  return def;
 }
 for ( ; *p != 0; ++p) {
  if (*p >= '0' && *p <= '9')
   r = r * 10 + (*p - '0');
  else if (*p != '\'' && *p != '_')
   break;
 }
 return r * m;
}
"'')
        }))

      codeWriters.add(NEW(%ptrBinToInt,
        PROC (WriteC gen, IO.File fd)
          # TODO: throw exception if illegal char found.
          fd.write(''"
Ti ZptrBinToInt(Tc *s, int t, Ti def) {
 Ti r = 0;
 if (*s < '0' || *s > '1') {
  if (t == 1) ZthrowCstringBadValue("binToInt(): argument does not start with 0 or 1");
  return def;
 }
 if (s != NULL) {
  Tc *p;
  for (p = s; *p != 0; ++p) {
   if (*p == '0')
    r <<= 1;
   else if (*p == '1')
    r = (r << 1) + 1;
   else
    break;
  }
 }
 return r;
}
"'')
        }))

      codeWriters.add(NEW(%ptrQuotedBinToInt,
        PROC (WriteC gen, IO.File fd)
          # TODO: throw exception if illegal char found.
          fd.write(''"
Ti ZptrQuotedBinToInt(Tc *s, int t, Ti def) {
 Ti r = 0;
 Tc *p;
 if (*s < '0' || *s > '1') {
  if (t == 1) ZthrowCstringBadValue("quotedBinToInt(): argument does not start with 0 or 1");
  return def;
 }
 for (p = s; *p != 0; ++p) {
  if (*p == '0')
   r <<= 1;
  else if (*p == '1')
   r = (r << 1) + 1;
  else if (*p != '\'' && *p != '_')
   break;
 }
 return r;
}
"'')
        }))

      codeWriters.add(NEW(%ptrHexToInt,
        PROC (WriteC gen, IO.File fd)
          # TODO: should argument to sscanf() be unsigned?
          fd.write(''"
Ti ZptrHexToInt(Tc *s, int t, Ti def) {
 Ti r;
 char *p = (char *)s;
 if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) p += 2;
 if ((*p < '0' || *p > '9') && (*p < 'a' || *p > 'f') && (*p < 'A' || *p > 'F')) {
  if (t == 1) ZthrowCstringBadValue("hexToInt(): argument does not start with a hex digit");
  return def;
 }
 sscanf(p, ZINT_XFORMAT, &r);
 return r;
}
"'')
        }))

      codeWriters.add(NEW(%ptrQuotedHexToInt,
        PROC (WriteC gen, IO.File fd)
          # TODO: throw exception if illegal char found.
          fd.write(''"
Ti ZptrQuotedHexToInt(Tc *s, int t, Ti def) {
 Ti r = 0;
 Tc *p = s;
 if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) p += 2;
 if ((*p < '0' || *p > '9') && (*p < 'a' || *p > 'f') && (*p < 'A' || *p > 'F')) {
  if (t == 1) ZthrowCstringBadValue("hexToInt(): argument does not start with a hex digit");
  return def;
 }
 for (; *p != 0; ++p) {
  if (*p >= '0' && *p <= '9')
   r = r * 16 + (*p - '0');
  else if (*p >= 'a' && *p <= 'f')
   r = r * 16 + (*p - 'a' + 10);
  else if (*p >= 'A' && *p <= 'F')
   r = r * 16 + (*p - 'A' + 10);
  else if (*p != '\'' && *p != '_')
   break;
 }
 return r;
}
"'')
        }))

      codeWriters.add(NEW(%intCompare,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZintCompare(Ti a, Ti b) {
 return a == b ? 0 : a < b ? -1 : 1;
}
"'')
        }))

      codeWriters.add(NEW(%natCompare,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZnatCompare(Tu a, Tu b) {
 return a == b ? 0 : a < b ? -1 : 1;
}
"'')
        }))

      codeWriters.add(NEW(%floatCompare,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZfloatCompare(Tf a, Tf b) {
 return a == b ? 0 : a < b ? -1 : 1;
}
"'')
        }))

      codeWriters.add(NEW(Declaration.stringToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using toInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([Declaration.ptrToInt,
                          Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringQuotedToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringQuotedToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrQuotedToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrQuotedToInt, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringBinToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringBinToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using binToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrBinToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrBinToInt, Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringQuotedBinToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringQuotedBinToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedBinToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrQuotedBinToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrQuotedBinToInt,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringHexToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringHexToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using hexToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrHexToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrHexToInt,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.stringQuotedHexToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZstringQuotedHexToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedhexToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrQuotedHexToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrQuotedHexToInt,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using toInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([Declaration.ptrToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringQuotedToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringQuotedToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrQuotedToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrQuotedToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringBinToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringBinToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using binToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrBinToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrBinToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringQuotedBinToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringQuotedBinToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedBinToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrQuotedBinToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrQuotedBinToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringHexToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringHexToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using hexToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrHexToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrHexToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.varStringQuotedHexToInt,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Ti ZvarStringQuotedHexToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedhexToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrQuotedHexToInt(s, t, def);
 return r;
}
"'')
        }).setDependencies([%ptrQuotedHexToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      codeWriters.add(NEW(Declaration.itemToString,
        PROC (WriteC gen, IO.File fd)
          # This code uses TYPE_NUMBERS, keep in sync!
          fd.write(''"
void ZitemToString(Tt *type, int useq, Tz val, Tg *ga);

void ZobjectToString(Tto *typearg, void *ptrarg, Tg *ga) {
 Tto *type = typearg;
 void *ptr = ptrarg;
 To *to;
 int cnt;
 if (type == NULL && ptr != NULL) {
  type = ((Tto *)ZiobjType(ptr));
  ptr = ((Tr *)ptr)->ptr;
 }
 if ((Tt *)type == &xobj__T) type = (Tto *)((Tj *)ptr)->mt[0];
 if (ptr == NULL "'')
        IF gen.manageMemory()
          fd.write("|| ((Zoh*)ptr)->np == NULL ")
        }
        fd.write(''") {
  ga_append(ga, "NIL");
 } else {
  int i;
  int first = 1;
  if (type->ToString != NULL) {
   Tc *p = ((Tc * (*)(void *))type->ToString)(ptr);
   ga_append(ga, ZgetCstring(p));
   return;
  }
  to = type->to;
  ga_append(ga, "{");
  cnt = to[0].off;
  for (i = 1; i <= cnt; ++i) {
   Tz val;
   void *vptr = ptr + to[i].off;

   if (!first) ga_append(ga, ", ");
   first = 0;
   ga_append(ga, type->names[i - 1]);
   ga_append(ga, ": ");
   switch (to[i].type->nr) {
    case 0:
    case 24:
    case 25:
     val = (Tz)*((Ti*)vptr); break;
    case 10:
     val = (Tz)(Ti)*((Tu*)vptr); break;
    case 1:
     val = (Tz)(Ti)*((char*)vptr); break;
    case 11:
     val = (Tz)(Ti)*((Tc*)vptr); break;
    case 2:
     val = (Tz)(Ti)*((Ti16*)vptr); break;
    case 12:
     val = (Tz)(Ti)*((Tu16*)vptr); break;
    case 3:
     val = (Tz)(Ti)*((Ti32*)vptr); break;
    case 13:
     val = (Tz)(Ti)*((Tu32*)vptr); break;
    case 21:
    case 22:
    case 23:
     val = (Tz)(Ti)*((int*)vptr); break;
    case 80:
    case 82:
    case 83:
     val = (Tz)*((Tf*)vptr); break;
    case 81:
     val = (Tz)(Tf)*((Tf32*)vptr); break;
    case 391:
     val = (Tz)vptr; break;
    default:
     val = (Tz)*(((void**)vptr)); break;
   }
   ZitemToString(to[i].type, 1, val, ga);
  }
  ga_append(ga, "}");
 }
}

Tc *ZobjectToStringval(Tto *type, void *ptr) {
 Tg ga;"'')
        IF !gen.manageMemory()
          fd.write(''"
 Tc *r;"'')
        }
        fd.write(''"
 ga.data = NULL;
 ga.used = 0;
 ++"'' .. gen.getEnvCode() .. ''"->tosNr;
 ZobjectToString(type, ptr, &ga);"'')
        IF gen.manageMemory()
          fd.write(''"
 return ZnewString(ga.data, ga.used);"'')
        ELSE
          fd.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
        }
        fd.write(''"
}

Tc *ZxobjectToStringval(void *p) {
 Tg ga;"'')
        IF !gen.manageMemory()
          fd.write(''"
 Tc *r;"'')
        }
        fd.write(''"
 ga.data = NULL;
 ga.used = 0;
 ++"'' .. gen.getEnvCode() .. ''"->tosNr;
 ZobjectToString((Tto*)((Tj *)p)->mt[0], p, &ga);"'')
        IF gen.manageMemory()
          fd.write(''"
 return ZnewString(ga.data, ga.used);"'')
        ELSE
          fd.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
        }
        fd.write(''"
}

Tc *ZiobjectToStringval(Tr tr) {
 Tg ga;"'')
        IF !gen.manageMemory()
          fd.write(''"
 Tc *r;"'')
        }
        fd.write(''"
 ga.data = NULL;
 ga.used = 0;
 ++"'' .. gen.getEnvCode() .. ''"->tosNr;
 ZobjectToString((Tto*)tr.table[0], tr.ptr, &ga);"'')
        IF gen.manageMemory()
          fd.write(''"
 return ZnewString(ga.data, ga.used);"'')
        ELSE
          fd.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
        }
        fd.write(''"
}

void ZitemToString(Tt *type, int useq, Tz val, Tg *ga) {
 char buf[30];
 if (type->nr < 100) {
  switch (type->nr) {
   case 0:
   case 1:
   case 2:
   case 3:
   case 25:
    sprintf(buf, ZINT_FORMAT, val.ival);
    ga_append(ga, buf);
    break;
   case 10:
    sprintf(buf, ZNAT_FORMAT, (Tu)val.ival);
    ga_append(ga, buf);
    break;
   case 11:
    sprintf(buf, ZNAT_FORMAT, (Tu)(Tc)val.ival);
    ga_append(ga, buf);
    break;
   case 12:
    sprintf(buf, ZNAT_FORMAT, (Tu)(Tu16)val.ival);
    ga_append(ga, buf);
    break;
   case 13:
    sprintf(buf, ZNAT_FORMAT, (Tu)(Tu32)val.ival);
    ga_append(ga, buf);
    break;
   case 21: ga_append(ga, val.ival ? "TRUE" : "FALSE"); break;
   case 22: ga_append(ga, val.ival ? "OK" : "FAIL"); break;
   case 23:
    if (type->ToString == NULL) {
     ga_append(ga, "-enum");
     if (type->name) {
      ga_append(ga, " ");
      ga_append(ga, ZgetCstring(type->name));
     }
     ga_append(ga, "-");
    } else {
     ga_append(ga, ((char * (*)(Te))type->ToString)(val.ival));
    }
    break;
   case 80:
   case 81:
   case 82:
   case 83:
    sprintf(buf, ZFLOAT_FORMAT, val.fval);"'')
        IF Config.isMingw || Config.portable
          fd.write(''"
#ifdef __MINGW32__
    ZcorrFloatStr(buf, NULL);
#endif"'')
        }
        fd.write(''"
    ga_append(ga, buf);
    break;
  }
 } else {
  void *ptr = val.ptr;
  if (ptr == NULL) ga_append(ga, "NIL");
  else switch (type->nr) {
   case 200:
   case 201: {
     Tc *p;
     (void)ZstringSizePtr(ptr, &p);
     if (useq) ga_append(ga, "\"");
     ga_append(ga, (char *)p);
     if (useq) ga_append(ga, "\"");
    }
    break;"'')
        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
   case 300:
    ZArrayToStringGa((Ta *)ptr, 1, ga);
    break;"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
   case 301:
    ZListToStringGa((Tl *)ptr, 1, ga);
    break;"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
   case 302:
    ZDictToStringGa((Td *)ptr, 1, 1, ga);
    break;"'')
        }
        fd.write(''"
   case 310:
    ga_append(ga, "-varString-");
    break;
   case 311:
    ga_append(ga, "-varByteString-");
    break;
   case 320:
    if (type->ToString == NULL) ga_append(ga, "-tuple-");
    else {
     Tc *p = ((Tc * (*)(void *))type->ToString)(ptr);
     ga_append(ga, ZgetCstring(p));
    }
    break;
   case 330:
    ga_append(ga, "-proc/func-");
    break;"'')

        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
   case 360:
    ZitemToString(((Tx*)ptr)->type, useq, ((Tx*)ptr)->u, ga);
    break;"'')
        }
        fd.write(''"
   case 390:
   case 392:
    ZobjectToString(((Tto*)type), ptr, ga);
    break;
   case 391:
    ZobjectToString((Tto*)((Tr*)ptr)->table[0], ((Tr*)ptr)->ptr, ga);
    break;
  }
 }
}
"'')
        }).setDependencies([%int2string, %iobjType,
                            %corrFloatStr, %getCstring]))

      codeWriters.add(NEW(%dynToString,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
Tc *ZdynToString(Tx arg) {
 Tg ga;"'')
        IF !gen.manageMemory()
          fd.write(''"
 Tc *r;"'')
        }
        fd.write(''"
 ga.data = NULL;
 ga.used = 0;
 ++"'' .. gen.getEnvCode() .. ''"->tosNr;
 if (arg.type == NULL)
  ga_append(&ga, "NIL");
 else
  ZitemToString(arg.type, 0, arg.u, &ga);"'')
        IF gen.manageMemory()
          fd.write(''"
 return ZnewString(ga.data, ga.used);"'')
        ELSE
          fd.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
        }
        fd.write(''"
}
"'')
        }).setDependencies([%garray,
                            Declaration.itemToString]))

      codeWriters.add(NEW(Declaration.dynSize,
        PROC (WriteC gen, IO.File fd)
          # This code uses TYPE_NUMBERS, keep in sync!
          fd.write(''"
Ti ZdynSize(Tx arg) {
 Tc *p;
 Ti len;
 if (arg.type->nr >= 200 && arg.u.ptr == NULL) return 0;
 switch (arg.type->nr) {
  case 0:
  case 10: return 8;
  case 1:
  case 11: return 1;
  case 2:
  case 12: return 2;
  case 3:
  case 13: return 4;
  case 21:
  case 22: return 1;
  case 23: return 4;
  case 25: return 8;
  case 80:
  case 82:
  case 83: return 8;
  case 81: return 4;

  case 101: return sizeof(Tt);

  case 200:
   len = ZstringSizePtr(arg.u.ptr, &p);
   return Zutf8size(p, len);
  case 201: return ZstringSizePtr(arg.u.ptr, &p);"'')
        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
  case 300: return ((Ta*)arg.u.ptr)->size[0];"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
  case 301: return ((Tl*)arg.u.ptr)->itemCount;"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
  case 302: return ((Td*)arg.u.ptr)->used;"'')
        }
        fd.write(''"
  case 310: return ZvarStringSize(arg.u.ptr);
  case 311: return ((Ty*)arg.u.ptr)->byteSize;

  case 360: return ZdynSize(*(Tx*)arg.u.ptr);

  case 390:
  case 391:
  case 392:
    if (((Tto*)arg.type)->Size != NULL)
     return ((Ti (*)(void *))((Tto*)arg.type)->Size)(arg.u.ptr);
    ZthrowDyn(Zstr("object does not support Size()"));
 }
 return 0;
}
"'')
        }).setDependencies([Declaration.varStringSize,
                            Declaration.throwDyn]))

      codeWriters.add(NEW(Declaration.itemEqual,
        PROC (WriteC gen, IO.File fd)
          # This code uses TYPE_NUMBERS, keep in sync!
          fd.write(''"
int ZitemEqual(Tt *aType, Tz aVal, Tt *bType, Tz bVal) {
 if (aType->nr == bType->nr) {
  switch (aType->nr) {
   case 0:
   case 1:
   case 2:
   case 3:
   case 10:
   case 11:
   case 12:
   case 13:
   case 22:
    return aVal.ival == bVal.ival;

   case 21:
    return !aVal.ival == !bVal.ival;

   case 23:
   case 25:
     return aVal.ival == bVal.ival && aType == bType;

   case 24:
   case 101:
     return aType == bType;

   case 80:
   case 81:
   case 82:
   case 83:
    return aVal.fval == bVal.fval;

   case 200:
   case 201:
    return ZstringCmp(aVal.ptr, bVal.ptr) == 0;"'')

        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
   case 300: {
    Ta *ah = aVal.ptr;
    Ta *bh = bVal.ptr;
    int i;
    if (ah == NULL || bh == NULL) return 0;
    if (ah->dim != bh->dim) return 0;
    if (ah->size[0] != bh->size[0]) return 0;
    for (i = 0; i < ah->size[0]; ++i)
     if  (ZitemEqual(ah->itemType, ZArrayGetTz(ah, i), bh->itemType, ZArrayGetTz(bh, i)) == 0) return 0;
   }"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
   case 301: {
    Tl *ah = aVal.ptr;
    Tl *bh = bVal.ptr;
    int i;
    if (ah == NULL || bh == NULL) return ah == bh;
    if (ah->itemCount != bh->itemCount) return 0;
    for (i = 0; i < ah->itemCount; i++)
     if (!ZitemEqual(ah->itemType, ZListGetTz(ah, i), bh->itemType, ZListGetTz(bh, i))) return 0;
   }"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
   case 302: {
    Td *ah = aVal.ptr;
    Td *bh = bVal.ptr;
    if (ah == NULL || bh == NULL) return ah == bh;
    return ZDictEqual(ah, bh);
   }
"'')
        }
        fd.write(''"
   case 310:
   case 311:
    ZthrowInternal(Zstr("Sorry, varString/varByteString compare not implemented yet"));
    return 0;

   case 320:
    ZthrowInternal(Zstr("Sorry, tuple compare not implemented yet"));
    return 0;

   case 330:
    ZthrowInternal(Zstr("Sorry, proc/func compare not implemented yet"));
    return 0;"'')

        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
   case 360: {
    Tx *a = aVal.ptr;
    Tx *b = bVal.ptr;
    return ZitemEqual(a->type, a->u, b->type, b->u);
   }"'')
        }
        fd.write(''"
   case 390:
   case 392:
    if (aType != bType) return 0;
    if (((Tto*)aType)->Equal != NULL)
     return ((int (*)(void *, void *))((Tto*)aType)->Equal)(aVal.ptr, bVal.ptr);
    if (((Tto*)aType)->Compare != NULL)
     return ((int (*)(void *, void *))((Tto*)aType)->Compare)(aVal.ptr, bVal.ptr) == 0;
    ZthrowDyn(Zstr("object does not support Equal() nor Compare()"));

   case 391:
    /* TODO */
    ZthrowDyn(Zstr("iobjec equal not supported yet"));
    return aType == bType;
  }
 }"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
 if (bType->nr == 360) {
  Tx *b = bVal.ptr;
  return ZitemEqual(aType, aVal, b->type, b->u);
 }"'')
        }
        fd.write(''"
 switch (aType->nr) {
  case 0:
  case 1:
  case 2:
  case 3:
  case 10:
  case 11:
  case 12:
  case 13:
   switch (bType->nr) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
     return aVal.ival == bVal.ival;
    case 80:
    case 81:
    case 82:
    case 83:
     return aVal.ival == bVal.fval;
   }
   return 0;
  case 80:
  case 81:
  case 82:
  case 83:
   switch (bType->nr) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
     return aVal.fval == bVal.ival;
    case 80:
    case 81:
    case 82:
    case 83:
     return aVal.fval == bVal.fval;
   }
   return 0;
  case 320:
   ZthrowInternal(Zstr("Sorry, tuple compare not implemented yet"));
   return 0;"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
  case 360: {
   Tx *a = aVal.ptr;
   return ZitemEqual(a->type, a->u, bType, bVal);
  }"'')
        }
        fd.write(''"
 }
 return 0;
}"'')
        }).setDependencies([Declaration.throwInternal,
                            Declaration.throwDyn]))
           # excluded: WriteArrayC.arrayGetTz: only when array used

      codeWriters.add(NEW(Declaration.dynEqual,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZdynEqual(Tx a, Tx b) {
 return ZitemEqual(a.type, a.u, b.type, b.u);
}
int ZdynEqualOne(Tx a, Tz v, Tt *type) {
 return ZitemEqual(a.type, a.u, type, v);
}"'')
        }).setDependencies([Declaration.throwInternal,
                            Declaration.itemEqual,
                            Declaration.throwDyn]))

      codeWriters.add(NEW(Declaration.itemCompare,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZitemCompare(Tt *aType, Tz aVal, Tt *bType, Tz bVal) {
 if (aType->nr == bType->nr) {
  switch (aType->nr) {
   case 0:
   case 1:
   case 2:
   case 3:
   case 10:
   case 11:
   case 12:
   case 13:
   case 22:
    return aVal.ival == bVal.ival ? 0 : aVal.ival > bVal.ival ? 1 : -1;

   case 21:
    return !aVal.ival == !bVal.ival ? 0 : aVal.ival > bVal.ival ? 1 : -1;

   case 23:
   case 25:
     return aVal.ival == bVal.ival && aType == bType ? 0 : 1;

   case 24:
   case 101:
     return aType == bType ? 0 : 1;

   case 80:
   case 81:
   case 82:
   case 83:
    return aVal.fval == bVal.fval ? 0 : aVal.fval > bVal.fval ? 1 : -1;

   case 200:
   case 201:
    return ZstringCmp(aVal.ptr, bVal.ptr);"'')

        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
   case 300: {
    Ta *ah = aVal.ptr;
    Ta *bh = bVal.ptr;
    int i;
    if (ah == NULL || bh == NULL) return 0;
    if (ah->dim != bh->dim) return 0;
    for (i = 0; i < ah->size[0] && i < bh->size[0]; ++i) {
     int v = ZitemCompare(ah->itemType, ZArrayGetTz(ah, i), bh->itemType, ZArrayGetTz(bh, i));
     if (v != 0) return v;
    }
    if (ah->size[0] == bh->size[0]) return 0;
    return ah->size[0] > bh->size[0] ? 1 : -1;
   }"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
   case 301: {
    Tl *ah = aVal.ptr;
    Tl *bh = bVal.ptr;
    int i;
    if (ah == NULL || bh == NULL) return ah == bh;
    for (i = 0; i < ah->itemCount; i++) {
     int v = ZitemEqual(ah->itemType, ZListGetTz(ah, i), bh->itemType, ZListGetTz(bh, i));
     if (v != 0) return v;
    }
    if (ah->itemCount == bh->itemCount) return 0;
    return ah->itemCount > bh->itemCount ? 1 : -1;
   }"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
   case 302: {
    Td *ah = aVal.ptr;
    Td *bh = bVal.ptr;
    if (ah == NULL || bh == NULL) return ah == bh;
    return ZDictCompare(ah, bh);
   }
"'')
        }
        fd.write(''"
   case 310:
   case 311:
    ZthrowInternal(Zstr("Sorry, varString/varByteString compare not implemented yet"));
    return 0;

   case 320:
    ZthrowInternal(Zstr("Sorry, tuple compare not implemented yet"));
    return 0;

   case 330:
    ZthrowInternal(Zstr("Sorry, proc/func compare not implemented yet"));
    return 0;"'')

        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
   case 360: {
    Tx *a = aVal.ptr;
    Tx *b = bVal.ptr;
    return ZitemCompare(a->type, a->u, b->type, b->u);
   }"'')
        }
        fd.write(''"
   case 390:
   case 392:
    if (aType != bType) return 0;
    if (((Tto*)aType)->Compare != NULL)
     return ((int (*)(void *, void *))((Tto*)aType)->Compare)(aVal.ptr, bVal.ptr);
    ZthrowDyn(Zstr("object does not support Compare()"));

   case 391:
    /* TODO */
    ZthrowDyn(Zstr("iobjec equal not supported yet"));
    return aType != bType;
  }
 }"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
 if (bType->nr == 360) {
  Tx *b = bVal.ptr;
  return ZitemCompare(aType, aVal, b->type, b->u);
 }"'')
        }
        fd.write(''"
 switch (aType->nr) {
  case 0:
  case 1:
  case 2:
  case 3:
  case 10:
  case 11:
  case 12:
  case 13:
   switch (bType->nr) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
     return aVal.ival == bVal.ival ? 0 : aVal.ival > bVal.ival ? 1 : -1;
   }
   return 0;
  case 80:
  case 81:
  case 82:
  case 83:
   switch (bType->nr) {
    case 80:
    case 81:
    case 82:
    case 83:
     return aVal.fval == bVal.fval ? 0 : aVal.fval == bVal.fval ? 1 : -1;
   }
   return 0;
  case 320:
   ZthrowInternal(Zstr("Sorry, tuple compare not implemented yet"));
   return 0;"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
  case 360: {
   Tx *a = aVal.ptr;
   return ZitemCompare(a->type, a->u, bType, bVal);
  }"'')
        }
        fd.write(''"
 }
 return 0;
}"'')
        }).setDependencies([Declaration.throwInternal,
                            Declaration.throwDyn]))

      codeWriters.add(NEW(Declaration.dynCompare,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZdynCompare(Tx a, Tx b) {
 return ZitemCompare(a.type, a.u, b.type, b.u);
}
int ZdynCompareOne(Tx a, Tz v, Tt *type) {
 return ZitemCompare(a.type, a.u, type, v);
}"'')
        }).setDependencies([Declaration.throwInternal,
                            Declaration.itemCompare,
                            Declaration.throwDyn]))

      codeWriters.add(NEW(%typeCompare,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
int ZtypeCompare(Tt *a, Tt *b) {
 if (a == b) return 0;
 if (a->nr == b->nr) return (Tip)a > (Tip)b ? 1 : -1;
 return a->nr > b->nr ? 1 : -1;
}"'')
        }))

      codeWriters.add(NEW(%copyItems,
        PROC (WriteC gen, IO.File fd)
          # Copy |len| items from one list or array to another list or array.
          # Allows for assigning different item sizes, e.g. int8 to int.
          # TODO: conversion between objects and iobjects of differe types.
          # Return non-zero for success, zero if copy is not possible.
          fd.write(''"
int ZcopyItems(Tt *toType, int toSize, void *toPtr, Ti toOff, Tt *fromType, int fromSize, void *fromPtr, Ti fromOff, Ti len) {
 Ti i;
 if (toType == fromType || (toType->nr >= 100 && fromType->nr >= 100)) {
  memmove((char*)toPtr + toOff * toSize, (char*)fromPtr + fromOff * fromSize, len * toSize);
  return 1;
 }
 if (fromType->nr >= 100 || toType->nr >= 100) return 0;
 for (i = 0; i < len; ++i) {
  Ti iv;
  Tf fv;
  switch (fromType->nr) {
   case 0:
   case 24:
   case 25:
    iv = ((Ti*)fromPtr)[fromOff + i]; fv = iv; break;
   case 1:
    iv = ((char*)fromPtr)[fromOff + i]; fv = iv; break;
   case 2:
    iv = ((Ti16*)fromPtr)[fromOff + i]; fv = iv; break;
   case 3:
    iv = ((Ti32*)fromPtr)[fromOff + i]; fv = iv; break;
   case 10:
    iv = ((Tu*)fromPtr)[fromOff + i]; fv = iv; break;
   case 11:
    iv = ((Tc*)fromPtr)[fromOff + i]; fv = iv; break;
   case 12:
    iv = ((Tu16*)fromPtr)[fromOff + i]; fv = iv; break;
   case 13:
    iv = ((Tu32*)fromPtr)[fromOff + i]; fv = iv; break;
   case 21:
   case 22:
   case 23:
    iv = ((int*)fromPtr)[fromOff + i]; fv = iv; break;
   case 80:
   case 82:
   case 83:
    fv = ((Tf*)fromPtr)[fromOff + i]; iv = fv; break;
   case 81:
    fv = ((Tf32*)fromPtr)[fromOff + i]; iv = fv; break;
  }
  switch (toType->nr) {
   case 0:
   case 10:
   case 24:
   case 25:
    ((Ti*)toPtr)[toOff + i] = iv; break;
   case 1:
   case 11:
    ((char*)toPtr)[toOff + i] = iv; break;
   case 2:
   case 12:
    ((Ti16*)toPtr)[toOff + i] = iv; break;
   case 3:
   case 13:
    ((Ti32*)toPtr)[toOff + i] = iv; break;
   case 21:
   case 22:
   case 23:
    ((int*)toPtr)[toOff + i] = iv; break;
   case 80:
   case 82:
   case 83:
    ((Tf*)toPtr)[toOff + i] = fv; break;
   case 81:
    ((Tf32*)toPtr)[toOff + i] = fv; break;
  }
 }
 return 1;
}"'')
        }))

      # Function to assign a value to a pointer, depending on the type.
      codeWriters.add(NEW(%ptrAssign,
        PROC (WriteC gen, IO.File fd)
          fd.write(''"
void ZptrAssign(void *ptr, int typenr, Tz val) {
 switch (typenr) {
  case 0:
  case 10:
  case 24:
  case 25:
   *((Ti*)ptr) = val.ival; break;
  case 1:
  case 11:
   *((char*)ptr) = val.ival; break;
  case 2:
  case 12:
   *((Ti16*)ptr) = val.ival; break;
  case 3:
  case 13:
   *((Ti32*)ptr) = val.ival; break;
  case 21:
  case 22:
  case 23:
   *((int*)ptr) = val.ival; break;
  case 80:
  case 82:
  case 83:
   *((Tf*)ptr) = val.fval; break;
  case 81:
   *((Tf32*)ptr) = val.fval; break;
  default:
   *(void**)ptr = val.ptr; break;
 }
}"'')
        }))

      codeWriters.add(NEW(Declaration.defer,
        PROC (WriteC gen, IO.File fd)
          # Catch exceptions thrown by the callback, report them and continue.
          string ewrite = DeclStore.getPName("MEModule", "FwriteToStderr")
          fd.write(''"
void ZdeferAdd(Tl *l, Tcb *cb) {
 if ("'')
        IF gen.hasNpField()
          fd.write("l->np")
        ELSE
          fd.write("l->itemType")
        }
        fd.write(''" == NULL) ZListInit(l, (Tt*)&cb__T);
 ZLap(l, (Tz)(void*)cb);
}
void ZdeferCall(Tl *l) {
 if ("'')
        IF gen.hasNpField()
          fd.write("l->np")
        ELSE
          fd.write("l->itemType")
        }
        fd.write(''" != NULL) {
  Tn *e = "'' .. gen.getEnvCode() .. ''";
  int i;
  while (l->itemCount > 0) {
   int try_index = e->tryCtxUsed;
   Zsf *tf = "'' .. gen.topFrameName() .. ''";
   ZtryDeeper(e, "'' .. gen.topFrameName() .. ''");
   if (setjmp(e->tryCtx[try_index].jmpBuf) == 0) {
    while (l->itemCount > 0) {
     Tcb *item = l->items[l->empty + l->itemCount - 1];
     ZListClearItem(l, -1);
     ((void (*)(Tcb *))item->cfunc)(item);
    }
   } else {
    "'' .. gen.topFrameName() .. ''" = tf;
    "'' .. ewrite .. ''"(e->thrown[--e->thrownUsed]);
   }
   e->tryCtxUsed = try_index;
  }
 }
}"'')
        }).setDependencies([WriteListC.listInit,
                            WriteListC.listAdd,
                            WriteListC.listClearItem,
                            Declaration.list])
          .setDecl("void ZdeferCall(Tl *l);"))

      WriteArrayC.initCodeWriters(codeWriters)
      WriteListC.initCodeWriters(codeWriters)
      WriteDictC.initCodeWriters(codeWriters)

    }  # end of initCodeWriters()

    string cThisName = "t"
    string cReturnName = "r"

    list<proc<WriteC, Output>> mainEarlyinitWriters = NEW()
    list<proc<Resolve, Output>> mainInitWriters = NEW()
    list<proc<WriteC, IO.File>> declWriters = NEW()
    list<proc<WriteC, IO.File>> bodyWriters = NEW()

    FUNC genExpr(Zui.Expression expr, SContext ctx) Type
      RETURN Generate.genExpr(expr, ctx)
    }
    FUNC genExpr(Zui.Expression expr, SContext ctx, Type destType) Type
      RETURN Generate.genExpr(expr, ctx, destType)
    }

    # Method declarations which are used as-is, for which we should generate a
    # static struct with zero extra arguments, if actually used.
    set<Declaration> directRefs = NEW()

    # Register that |decl| is a method which is used as a direct reference,
    # thus as a callback with zero extra arguments.
    PROC useDirectRef(Declaration decl)
      directRefs.set(decl)
    }

    # Return the direct reference name for |name|.
    FUNC directRefName(string name) string
      RETURN "ZCB_" .. name
    }

    # Declarations used to mark items as used.
    # NOTE: Only for items that do not, directly or indirectly, depend on
    # library code. These are marked as used after writing the library code,
    # thus it's too late to mark the library dependencies as used.
    Declaration %allocObjectRef = NEW("allocObjectRef")
    Declaration %noAllocObjectRef = NEW("noAllocObjectRef")
    Declaration %noAllocAssign = NEW("noAllocAssign")
    Declaration %iobject2noalloc = NEW("iobject2noalloc")
    Declaration %deref = NEW("deref")

    Declaration %varByteStringCheckUtf8 = NEW("varByteStringCheckUtf8")
    Declaration %forEnum = NEW("forEnum")
    Declaration %forStringStruct = NEW("forStringStruct")
    Declaration %forArray = NEW("forArray")

    Declaration %concat3 = NEW("concat3")
    Declaration %concat5 = NEW("concat5")
    Declaration %concat8 = NEW("concat8")
    Declaration %concat12 = NEW("concat12")

    Declaration %forList = NEW("forList")
    Declaration %forListIobj = NEW("forListIobj")
    Declaration %forListDyn = NEW("forListDyn")
    Declaration %forListEnum = NEW("forListEnum")
    Declaration %forListFloat = NEW("forListFloat")
    Declaration %forListInt = NEW("forListInt")
    Declaration %forListPtr = NEW("forListPtr")
    Declaration %forListIobjKey = NEW("forListIobjKey")
    Declaration %forListDynKey = NEW("forListDynKey")
    Declaration %forListEnumKey = NEW("forListEnumKey")
    Declaration %forListFloatKey = NEW("forListFloatKey")
    Declaration %forListIntKey = NEW("forListIntKey")
    Declaration %forListPtrKey = NEW("forListPtrKey")

    Declaration %forDict = NEW("forDict")
    Declaration %forRange = NEW("forRange")
    Declaration %garray = NEW("garray")
    Declaration %cordType = NEW("cordType")
    Declaration %varByteStringType = NEW("varByteStringType")
    Declaration %piecevalType = NEW("piecevalType")
    Declaration %pieceType = NEW("pieceType")
    Declaration %cstring = NEW("cstring")
    Declaration %byteStringCopyMutable = NEW("byteStringCopyMutable")
    Declaration %byteStringPtr = NEW("byteStringPtr")
    Declaration %byteStringWriteTo = NEW("byteStringWriteTo")
    Declaration %char2byteIdx = NEW("char2byteIdx")
    Declaration %char2byteIdxEnd = NEW("char2byteIdxEnd")
    Declaration %varStringAddBytes = NEW("varStringAddBytes")
    Declaration %iobjType = NEW("iobjType")
    Declaration %noAllocClear = NEW("noAllocClear")
    Declaration %noAllocNil = NEW("noAllocNil")
    Declaration %noAllocNilIobj = NEW("noAllocNilIobj")

    Declaration %utf8size = NEW("utf8size")
    Declaration %stringSize = NEW("stringSize")

    Declaration %getCstring = NEW("getCstring")
    Declaration %varString2string = NEW("varString2string")
    Declaration %string2varString = NEW("string2varString")

    Declaration %bool2string = NEW("bool2string")
    Declaration %status2string = NEW("status2string")
    Declaration %int2string = NEW("int2string")
    Declaration %stringFormat = NEW("stringFormat")
    Declaration %intFormat = NEW("intFormat")
    Declaration %nat2string = NEW("nat2string")
    Declaration %natFormat = NEW("natFormat")
    Declaration %float2string = NEW("float2string")
    Declaration %float2int = NEW("float2int")
    Declaration %floatFormat = NEW("floatFormat")
    Declaration %corrFloatStr = NEW("corrFloatStr")
    Declaration %dynToString = NEW("dynToString")
    Declaration %enum2string = NEW("enum2string")
    Declaration %enumFromString = NEW("enumFromString")
    Declaration %bool2varString = NEW("bool2varString")
    Declaration %status2varString = NEW("status2varString")
    Declaration %int2varString = NEW("int2varString")

    Declaration %ptrQuotedToInt = NEW("ptrQuotedToInt")

    Declaration %stringCmp = NEW("stringCmp")
    Declaration %varByteStringCmp = NEW("varByteStringCmp")
    Declaration %varByteStringSet = NEW("varByteStringSet")

    Declaration %stringFindLen = NEW("stringFindLen")
    Declaration %stringFindLastLen = NEW("stringFindLastLen")
    Declaration %byteStringFindC = NEW("byteStringFindC")
    Declaration %byteStringFindLastC = NEW("byteStringFindLastC")
    Declaration %toCharBuf = NEW("toCharBuf")

    Declaration %ptrFindChar2 = NEW("ptrFindChar2")
    Declaration %ptrFindLastChar2 = NEW("ptrFindLastChar2")

    Declaration %fromChar = NEW("fromChar")
    Declaration %typeInRange = NEW("typeInRange")
    Declaration %typepInRange = NEW("typepInRange")
    Declaration %xobjIsa = NEW("xobjIsa")
    Declaration %xobjIsaTab = NEW("xobjIsaTab")
    Declaration %objIsa = NEW("objIsa")
    Declaration %stringSplitLen = NEW("stringSplitLen")

    Declaration %byteStringCheckUtf8 = NEW("byteStringCheckUtf8")
    Declaration %intAsByteString = NEW("intAsByteString")
    Declaration %intCompare = NEW("intCompare")
    Declaration %natCompare = NEW("natCompare")
    Declaration %floatCompare = NEW("floatCompare")
    Declaration %typeCompare = NEW("typeCompare")

    Declaration %ptrBinToInt = NEW("ptrBinToInt")
    Declaration %ptrQuotedBinToInt = NEW("ptrQuotedBinToInt")
    Declaration %ptrHexToInt = NEW("ptrHexToInt")
    Declaration %ptrQuotedHexToInt = NEW("ptrQuotedHexToInt")

    Declaration %stringToArray = NEW("stringToArray")
    Declaration %byteStringToArray = NEW("byteStringToArray")
    Declaration %stringFromArray = NEW("stringFromArray")
    Declaration %stringToFloat = NEW("stringToFloat")

    Declaration %stringToLower = NEW("stringToLower")
    Declaration %stringToUpper = NEW("stringToUpper")
    Declaration %varStringToLower = NEW("varStringToLower")
    Declaration %varStringToUpper = NEW("varStringToUpper")

    Declaration %copyItems = NEW("copyItems")
    Declaration %finishIobj = NEW("finishIobj")

    # C header files.
    # Note: The following are always included:
    # stdio.h, stdlib.h, signal.h
    Declaration %fcntl = NEW("fcntl")
    Declaration %errno = NEW("errno")
    Declaration %dirent = NEW("dirent")
    Declaration %unistd = NEW("unistd")
    Declaration %limits = NEW("limits")
    Declaration %sys_types = NEW("sys_types")
    Declaration %sys_stat = NEW("sys_stat")
    Declaration %sys_wait = NEW("sys_wait")
    Declaration %string_h = NEW("string_h")
    Declaration %ctype_h = NEW("ctype_h")
    Declaration %termios = NEW("termios")
    Declaration %time_h = NEW("time_h")
    Declaration %sys_time = NEW("sys_time")
    Declaration %socket = NEW("socket")
    Declaration %hostname = NEW("hostname")
    Declaration %pthread = NEW("pthread")
    Declaration %math = NEW("math")
    Declaration %pcre = NEW("pcre")
    Declaration %windows_h = NEW("windows_h")
    Declaration %setjmp_h = NEW("setjmp_h")
    Declaration %ptrAssign = NEW("ptrAssign")

    Declaration %zfree = NEW("zfree")

    bool pcreUsed   # pcre.h used somewhere

    # Return the list of items that can be used in >>> uses().
    FUNC getUsesDeclarations() list<Declaration>
      RETURN [%fcntl, %errno, %dirent, %unistd, %limits, Declaration.gcRun,
              %getCstring, %sys_types, %sys_stat, %sys_wait, %string_h,
              %ctype_h, %termios, %time_h, %sys_time, %socket, %hostname,
              %pcre, %pthread, Declaration.throwThread, %windows_h, %setjmp_h,
              Declaration.usesCtx, %utf8size]
    }

    # Get the __T type name used for container items and dict keys:
    # 0  any kind of value type
    # &string__T       string - length field first
    # &byteString__T   byteString - length field first
    # &iobj__T         iobject
    # &{name}__T       object
    # "&name__T"       other reference type, not in managed memory
    FUNC getTname(Type type, SContext ctx) string
      IF type == NIL
        RETURN "0"
      }
      RETURN "(Tt*)&" .. type.getTypeName(ctx) .. "__T"
    }

    # Generate an argument for |expr| with destination type "Tz", unless it's
    # an iobject.
    PROC writeTzOrIobjArg(Type type, Zui.Expression expr, SContext ctx)
      IF type.isIobject(ctx) || type.getTtype() == Type.Enum.dyn
        Generate.genTopExprDoConv(expr, ctx, type)
      ELSE
        WriteC.genTzArg(type, expr, ctx)
      }
    }

    # Generate an argument for |expr| with destination type "Tz".
    # When the type is an iobject, put its address in the .ptr field.
    PROC genTzArg(Type type, Zui.Expression expr, SContext ctx)
      # If the type is NIL just use some type so that we can give error
      # messages.
      Type valType = type ?: Type.anInt
      ctx.out.write("(Tz)")
      IF valType.isFloatType()
        ctx.out.write("(Tf)")
      ELSEIF valType.isValueType()
        ctx.out.write("(Ti)")
      ELSE
        ctx.out.write("(void*)")
        IF type?.isIobject(ctx)
          ctx.out.write("&")
        }
      }
      Generate.genTopExprDoConv(expr, ctx, valType)
    }

    # Generate the start of using a temp var.
    # Zimbu code: foo = expr ->  foo = NEW(); foo = expr;
    # Zimbu code:       expr ->  (t1 = NEW(), t1 = expr, t1)
    FUNC genTempUseStart(Zui.Expression expr, string typeName,
                     bool &useTempVar, string &separator, SContext ctx) string
      string name
      ZuiExpressionExt exprExt = expr
      IF exprExt.tempDecl != NIL
        name = exprExt.tempDecl.pName
        useTempVar = TRUE
      ELSEIF exprExt.toplevelVar != NIL
        # Use the LHS of assignment as the temp var.
        name = exprExt.toplevelVar
        separator = "; "
      ELSE
        # Must be outside of a method, e.g., in initialization.
        name = getUid(ctx.scope.ToString())
        ctx.outs.varOut.writeIndent(ctx.scope.depth)
        ctx.outs.varOut.write(typeName .. name .. ";\n")
        useTempVar = TRUE
      }
      IF useTempVar
        ctx.out.write("(" .. name .. " = ")
      }
      RETURN name
    }

    # When |expr| may have side effects, declare a temp variable.
    # Return NIL or the name of the temp varialble.
    FUNC mayGetTempVar(Zui.Expression expr, string typeName,
                                                          SContext ctx) string
      IF expr.getType() == Zui.ExprType.eID
                 || expr.getType() == Zui.ExprType.eTHIS
                 || expr.getType() == Zui.ExprType.eNIL
         RETURN NIL
      }
      string name = getUid(ctx.scope.ToString() .. "tmp")
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      ctx.outs.varOut.write(typeName .. name .. ";\n")
      RETURN name
    }

    FUNC exceptionPname() string
      RETURN DeclStore.getPName("MEModule", "CException")
    }

  } # SHARED

}
