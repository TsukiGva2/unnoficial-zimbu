#
# The Zimbu compiler written in Zimbu
#
# Write IMT: create tables for calling methods on an interface.
#
# Copyright 2012 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT ../ClassType.zu
IMPORT ../Declaration.zu
IMPORT ../Generate.zu
IMPORT ../MethodType.zu
IMPORT ../Output.zu
IMPORT ../SContext.zu
IMPORT ../Type.zu
IMPORT WriteC.zu

MODULE WriteIMT @public @items=public         # TODO: restrict visibility

  # Generate the member table for class |classDecl|
  PROC generateMemberTable(Declaration classDecl, SContext ctx)
    ClassType classType = classDecl.type
    string tableName = classDecl.pName .. "__mt"

    # Write the actual table to bodyOut.  Use origBodyOut when inside a
    # method.
    Output out = ctx.outs.bodyOut
    IF ctx.outs.origBodyOut != NIL
      out = ctx.outs.origBodyOut
    }
    out.write("Tc *" .. tableName .. "[] = {\n")
    out.write(" (Tc*)&" .. classDecl.pName .. "__T,\n")
    out.write(" (Tc*)" .. classType.rootIndex .. ",\n")

    # Start at the root, do members  of this class last.
    list<ClassType> parentList = NEW()
    ClassType parent = classType
    WHILE parent != NIL
      parentList.insert(parent)
      parent = parent.parent
    }

    # Skip over one entry for the type and one entry for the rootIndex.
    int count = 2
    FOR p IN parentList
      # Methods are only produced for the class itself.
      count = generateIMT(classDecl, p, tableName, count, out, ctx, TRUE)
    }

    # Add members from child classes with AUGMENTS or GROWS
    FOR child IN classType.children
      IF child.parentFromAugments || child.parentFromGrows
        count = generateIMT(classDecl, child, tableName, count, out, ctx, TRUE)
      }
    }
    
    out.write("};\n")

    ctx.outs.declOut.write("Tc *" .. tableName)
    ctx.outs.declOut.write("[" .. count .. "];\n")
  }

  # Generate the interface member lookup table for class |classDecl|
  # implementing interface |itf|, with the interface members |itf.memberList|.
  PROC generateInterfaceMemberTable(Declaration classDecl,
                                                     Type itf, SContext ctx)
    ClassType itfClass = itf.getClassType(ctx)
    IF Generate.skipUnused() && !ctx.gen.isDeclUsed(classDecl)
      # The class is not used, the table will be unused.
      RETURN
    }

    # Write the header to declOut.
    string tableName = Declaration.interfaceMemberTableName(
                                                     classDecl, itfClass, ctx)

    # Write the actual table to bodyOut.  Use origBodyOut when inside a
    # method.
    Output out = ctx.outs.bodyOut
    IF ctx.outs.origBodyOut != NIL
      out = ctx.outs.origBodyOut
    }
    out.write("Tc *" .. tableName .. "[] = {\n")
    out.write(" (Tc*)&" .. classDecl.pName .. "__T,\n")

    # Start at the root, do members  of itfClass last.
    list<ClassType> parentList = NEW()
    ClassType parent = itfClass
    WHILE parent != NIL
      parentList.insert(parent)
      parent = parent.parent
    }

    # Skip over the first entry with the type.
    int count = 1
    FOR itfParent IN parentList
      # Member variables can be defined in parents.
      # For interfaces also methods.
      count = generateIMT(classDecl, itfParent, tableName, count, out, ctx,
              itfParent IS itfClass || itfParent.ttype == Type.Enum.interface)
    }

    # Add members from child classes with AUGMENTS or GROWS
    FOR child IN itfClass.children
      IF child.parentFromAugments || child.parentFromGrows
        count = generateIMT(classDecl, child, tableName, count, out, ctx,
                                           child.ttype == Type.Enum.interface)
      }
    }

    out.write("};\n")

    ctx.outs.declOut.write("Tc *" .. tableName)
    ctx.outs.declOut.write("[" .. count .. "];\n")
  }

  bool startedClass

  FUNC generateIMT(Declaration classDecl, Type itf,
                                             string tableName, int countStart,
                                     Output out, SContext ctx, bool doMethods
                 ) int
    int count = countStart
    VAR itfDeclDict = itf.getObjectDeclDict()
    IF itfDeclDict != NIL
      # CAREFUL: this loop must be done in exactly the same order as in
      # classMemberTableIndex()
      FOR itfMemberList IN itfDeclDict.values()
        FOR itfDecl IN itfMemberList
          IF itfDecl.name.find("__") > 0 || itfDecl.name == "NEW"
            # Skip method added from parent and skip NEW().
          ELSEIF itfDecl.getClassName() != NIL
            IF itfDecl.type.isMethodType()
              IF doMethods
                int undef
                Declaration method = classDecl.type.findMatchingMethod(
                                itfDecl.name, TRUE, itfDecl.type.getArgList(),
                                                NIL, :methodArgs, &undef, ctx)
                IF method == NIL
                  # This can happen when an argument is unknown while the
                  # function is not being generated.
                  out.write(" (Tc*)0, /* optimized-out: ")
                  out.write(itfDecl.name .. " */\n")
                ELSE
                  string name = method.pName
                  IF name == NIL
                    # Don't give this error when the last pass had undefined
                    # symbols, we are producing code that isn't used.
                    IF itfDecl.type.ttype != Type.Enum.builtinMethod
                                             && !Generate.previousPassHadUndef
                      LOG.internal("Method without pName: \(itfDecl)")
                    }
                    name = "0"
                  }
                  out.write(" (Tc*)")
                  # An Init() method is only generated when type.defined is
                  # TRUE.
                  IF (ctx.gen.isDeclUsed(method) || !Generate.skipUnused())
                         && (!Generate.isInitName(method.name)
                                                       || method.type.defined)
                    out.write(name)
                  ELSE
                    # TODO: Can we omit this table entry?
                    out.write("0")
                    name = "0"
                  }
                  out.write(", /* " .. method.getName(FALSE) .. " */\n")

                  IF itfDecl.hasDirectRef
                    out.write(" (Tc*)")
                    IF name == "0"
                      out.write("0")
                    ELSE
                      out.write("&")
                      out.write(WriteC.directRefName(name))
                    }
                    out.write(", /* Tcb */\n")
                    ++count
                  }

                  MethodType itfMethodType = itfDecl.type.<MethodType>
                  IF itfMethodType.callbackStmt != NIL
                    # The Init() method will allocate a callback, which must
                    # be found later for an iobject.
                    Declaration callbackDecl = method.type.<MethodType>
                                                         .getCallbackDecl(ctx)
                    ++count
                    IF !Generate.skipUnused()
                                           || ctx.gen.isDeclUsed(callbackDecl)
                      out.write(" (Tc*)offsetof(\(classDecl.pName), \(callbackDecl.pName)), /* cb \(callbackDecl.pName) */\n")
                    ELSE
                      out.write(" (Tc*)0, /* cb \(callbackDecl.pName) */\n")
                    }
                  }

                  IF itfDecl.name != "Init"
                    MethodType methodType = method.type
                    string error
                    IF itfMethodType.returnType != NIL
                      IF methodType.returnType == NIL
                        error = "Expected a FUNC but found a PROC for \(itfDecl.name)"
                      ELSEIF !Type.matchingTypes(itfMethodType.returnType,
                                                   methodType.returnType, ctx)
                        Generate.typeError(itfMethodType.returnType,
                                               methodType.returnType,
                                             methodType.zuiDecl.getPos(), ctx)
                        error = "First \(itfDecl.name) method here"
                      }
                    ELSEIF methodType.returnType != NIL
                      error = "Expected a PROC but found a FUNC for \(itfDecl.name)"
                    }
                    IF error != NIL
                      ctx.error(error, method.zuiDecl)
                      ctx.error("To match this method", itfDecl.zuiDecl)
                    }
                  }

                }
                ++count
              }
            ELSEIF itfDecl.type.ttype != Type.Enum.class
                && itfDecl.type.ttype != Type.Enum.enum
                && itfDecl.type.ttype != Type.Enum.bits
                && itfDecl.type.ttype != Type.Enum.javatype
                && itfDecl.type.ttype != Type.Enum.jstype
              IF !Generate.skipUnused() || ctx.gen.isDeclUsed(itfDecl)
                out.write(" (Tc*)offsetof(\(classDecl.pName), \(itfDecl.pName)), /* \(itfDecl.pName) */\n")
              ELSE
                out.write(" (Tc*)0, /* \(itfDecl.pName) */\n")
              }
              ++count
            }
          ELSE
            LOG.internal("object member without className: \(itfDecl.name)")
          }
        }
      }
    }
    RETURN count
  }

  # Return the table index for |member| in |itfType|.
  FUNC interfaceMemberTableIndex(Type itfType, Declaration member,
                                           bool reportError, SContext ctx) int
    RETURN classMemberTableIndex(itfType.getClassType(ctx), member,
                                     itfType.isIobject(ctx), reportError, ctx)
  }

  # Return the table index for |member| in |classType|.
  # When |forImt| is true for an _imt table, otherwise an __mt table.
  FUNC classMemberTableIndex(ClassType classType, Declaration member,
                              bool forImt, bool reportError, SContext ctx) int
    # Index starts at one, entry zero has the type: &obj__T.
    int idx = 1
    IF !forImt
      # For an xobject index one is used for the rootIndex.
      ++idx
    }
    # Start at the root, do members  of this class last.
    # Member variables and interface methods can be defined in parents.
    list<ClassType> parentList = NEW()
    ClassType parent = classType
    WHILE parent != NIL
      parentList.insert(parent)
      parent = parent.parent
    }

    FOR ct IN parentList
      VAR classDeclDict = ct.getObjectDeclDict()
      IF classDeclDict != NIL
        FOR memList IN classDeclDict.values()
          FOR decl IN memList
            IF decl IS member
              RETURN idx
            }
            IF decl.getClassName() != NIL
              && decl.name.find("__") < 0  # Don't count methods from the parent
              && decl.name != "NEW"        # Skip NEW()
              && (decl.type.isMethodType()
                      ? (ct.ttype == Type.Enum.interface
                          || ct IS classType
                          || !forImt)
                      : (decl.type.ttype != Type.Enum.class
                      && decl.type.ttype != Type.Enum.interface
                      && decl.type.ttype != Type.Enum.javatype
                      && decl.type.ttype != Type.Enum.jstype
                      && decl.type.ttype != Type.Enum.enum
                      && decl.type.ttype != Type.Enum.bits))
               idx++

              IF decl.hasDirectRef
                # directRef has another entry
                idx++
              }
              IF decl.type.isMethodType()
                                   && decl.type.<MethodType>.callbackStmt != NIL
                # callback has another entry
                idx++
              }
            }
          }
        }
      }
    }

    IF reportError
      string name = member.pName ?: member.name
      LOG.internal("could not find \(name) IN \(classType.pName)")
    }
    RETURN 0
  }

  # Generate the table of interface member lookup tables for class
  # |classType|.
  PROC generateIMTTable(ClassType classType,
                                  bool writeImtt, bool writeImp, SContext ctx)
    # Write the header to declOut.
    string decl = "Tc **" .. interfaceMemberTableTableName(classType)

    # Write the actual table to bodyOut.  Use origBodyOut when inside a
    # method.
    Output out = ctx.outs.bodyOut
    IF ctx.outs.origBodyOut != NIL
      out = ctx.outs.origBodyOut
    }
    bool saveWriting = out.writing
    out.writing = writeImtt
    out.write(decl .. "[] = {\n")

    IO.StringWriter sw = NEW()
    int count = writeIMTnames(classType, classType, out, FALSE, TRUE, sw, ctx)

    IF writeImtt
      out.write("};\n")
      ctx.outs.declOut.write(decl .. "[" .. count .. "];\n")
    }
    out.writing = saveWriting

    IF writeImp
      # Write the table with flags for implementers.
      ctx.outs.declOut.write("char " .. implementerTableName(classType))
      ctx.outs.declOut.write("[] = {")
      ctx.outs.declOut.write(sw.ToString())
      ctx.outs.declOut.write("};\n")
    }
  }

  # Write the InterfaceMemberTable name for each child of |class| to |out|.
  # Used recursively, keep in sync with ClassType.findChild().
  FUNC writeIMTnames(ClassType class, Declaration itfDecl, Output out,
                     bool isImplementer, bool writeEntry,
                     IO.StringWriter sw, SContext ctx) int
    int count
    IF class.countClass()
      # Do the class itself first.
      string value = "  0"
      IF writeEntry
            && (!Generate.skipUnused() || ctx.gen.isDeclUsed(class))
            && class.isUsingInterface(itfDecl, ctx) != NIL
        value = Declaration.interfaceMemberTableName(class, itfDecl, ctx)
      }
      out.write("  ")
      out.write(value)
      out.write(",\n")
      ++count

      IF sw.Size() > 0
        sw.write(", ")
      }
      sw.write(isImplementer ? "1" : "0")
    }

    # Then the children, recursively.
    FOR child IN class.children
      count += writeIMTnames(child, itfDecl, out, FALSE, writeEntry, sw, ctx)
    }
    # Then the implementers, recursively.
    # Do not write entries for implementers of implementers.
    FOR child IN class.implementers
      count += writeIMTnames(child, itfDecl, out, TRUE,
                                        writeEntry && !isImplementer, sw, ctx)
    }
    RETURN count
  }

  # Write the _itf tables for |classType|.
  PROC generateNeedItfTables(ClassType classType, SContext ctx)
    IF classType.needItfTable != NIL
      FOR itf IN classType.needItfTable
        IF ctx.gen.isDeclUsed(itf)
          ClassType type = itf.type

          Output out = ctx.outs.declOut
          out.write("char " .. interfaceTableName(classType, type, ctx))
          out.write("[] = {")
          string comma = ""
          writeItfFlags(classType, type, &comma, out, ctx)
          out.write("};\n")
        }
      }
    }
  }

  PROC writeItfFlags(ClassType class, ClassType type,
                                      string &comma, Output out, SContext ctx)
    IF class.countClass()
      out.write(comma)
      comma = ", "
      out.write(class.hasInterface(type, ctx) ? "1" : "0")
    }

    # Then the children, recursively.
    FOR child IN class.children
      writeItfFlags(child, type, comma, out, ctx)
    }
    # Then the implementers, recursively.
    # Do not write entries for implementers of implementers.
    FOR child IN class.implementers
      writeItfFlags(child, type, comma, out, ctx)
    }
  }

  # Return the name of the table with interface member table names
  # for class |decl|.
  FUNC interfaceMemberTableTableName(Declaration decl) string
    IF decl.pName == NIL
      RETURN "NIL"  # Must have had an error earlier.
    }
    RETURN decl.pName .. "__imtt"
  }

  # Return the name of the table with implementer flags
  # class |class|.
  FUNC implementerTableName(ClassType class) string
    IF class.pName == NIL
      RETURN "NIL"  # Must have had an error earlier.
    }
    RETURN class.pName .. "__imp"
  }

  # Return the name of the table for |leftClass| with flags for whether
  # interface |rightClass| is implemented.
  FUNC interfaceTableName(ClassType leftClass, ClassType rightClass,
                                                          SContext ctx) string
    RETURN leftClass.pName .. "__" .. rightClass.pName .. "_itf"
  }

  PROC writeToTable(Declaration classDecl, SContext ctx)
    # Write the actual table to bodyOut.  Use origBodyOut when inside a
    # method.
    Output out = ctx.outs.bodyOut
    IF ctx.outs.origBodyOut != NIL
      out = ctx.outs.origBodyOut
    }
    string typeName = classDecl.type.getTypeName(ctx)
    string tableName = "To" .. typeName
    out.write("To " .. tableName .. "[] = {\n")

    int count
    Output tmpOut = NEW()
    tmpOut.writing = TRUE

    list<string> memberNames
    IF ctx.gen.<WriteC>.ttoHasMemberNames()
      # Write a list with the member names.
      memberNames = NEW()
    }

    # Find member variables in the class itself and in parents.
    ClassType thisClass = classDecl.type.getClassType(ctx)
    ClassType class = thisClass
    WHILE class != NIL
      IF !(class.parentFromAugments || class.parentFromGrows)
        # Members of the class itself.
        count = writeToTableLines(classDecl, class, tableName,
                                              count, tmpOut, memberNames, ctx)
      }
      FOR child IN class.children
        IF child.parentFromAugments || child.parentFromGrows
          # Members of children that use AUGMENTS or GROWS
          count = writeToTableLines(classDecl, child, tableName,
                                              count, tmpOut, memberNames, ctx)
        }
      }
      class = class.parent
    }

    out.write(" {" .. count .. ", 0},\n")
    out.append(tmpOut)
    out.write("};\n")

    ctx.outs.declOut.write("To " .. tableName .. "[" .. (count + 1) .. "];\n")

    IF memberNames != NIL
      out.write("char *Str" .. typeName .. "[] = {\n")
      FOR name IN memberNames
        out.write(" \"")
        out.write(name)
        out.write("\",\n")
      }
      out.write("};\n")
      ctx.outs.declOut.write("char *Str" .. typeName .. "[];\n")
    }

    string staticName = ctx.gen.<WriteC>.writeStaticString(thisClass.name, ctx)
    writeClassType(thisClass, staticName, tableName, out, ctx)
  }

  PROC mayWriteNoAllocAssign(ClassType classType, SContext ctx)
    IF classType.hasNoAllocAssign
      # Write the actual table to bodyOut.  Use origBodyOut when inside a
      # method.
      Output out = ctx.outs.bodyOut
      IF ctx.outs.origBodyOut != NIL
        out = ctx.outs.origBodyOut
      }

      # Write a function that assigns the whole object "s" to "d", depending
      # on the actual type of the object.
      out.write("void Naa" .. classType.pName .. "(void *d, void *s) {\n")
      out.write(" switch ((int)(((Tj*)s)->mt[1])) {\n")
      writeAssignLine(classType, out)
      out.write(" }\n")
      out.write("}\n")
    }
  }

  PROC writeAssignLine(ClassType class, Output out)
    out.write(" case " .. class.rootIndex .. ": *((")
    out.write(class.pName)
    out.write(" *)d) = *((")
    out.write(class.pName)
    out.write(" *)s); break;\n")

    FOR child IN class.children
      writeAssignLine(child, out)
    }
    FOR child IN class.implementers
      writeAssignLine(child, out)
    }
  }

  PROC writeClassType(ClassType thisClass, string staticName, string toName,
                                                     Output out, SContext ctx)
    out.write("Tto ")
    out.write(thisClass.pName)
    out.write("__T = {390, (Tc*)&")
    out.write(staticName)
    out.write(", ")

    # Only lookup the ToString function when ToString() is used on an item.
    Declaration foundFunc
    int undef
    IF ctx.gen.isDeclUsed(Declaration.itemToString)
      foundFunc = thisClass.findMatchingMethod("ToString",
                                      TRUE, [], NIL, :skipShared, &undef, ctx)
    }
    IF foundFunc == NIL
      out.write("0")
    ELSE
      out.write(foundFunc.pName)
    }

    IF ctx.gen.<WriteC>.ttoHasMemberNames()
      IF thisClass.isAllocType(ctx)
        out.write(", 0")
      ELSE
        out.write(", Str")
        out.write(thisClass.pName)
      }
    }

    IF ctx.gen.<WriteC>.ttoHasAssign()
      IF thisClass.rootClass().hasNoAllocAssign
        out.write(", Naa" .. thisClass.rootClass().pName)
      ELSE
        out.write(", 0")
      }
    }

    IF ctx.gen.<WriteC>.ttoHasMethods()
      foundFunc = thisClass.findMatchingMethod("Size",
                                      TRUE, [], NIL, :skipShared, &undef, ctx)
      IF foundFunc == NIL || !ctx.gen.isDeclUsed(foundFunc)
        out.write(", 0")
      ELSE
        out.write(", ")
        out.write(foundFunc.pName)
      }

      # Finish is only really used when hasFinish is used.
      Declaration finishMethod
      IF ctx.gen.isDeclUsed(Declaration.hasFinish)
        finishMethod = Generate.getFinishMethod(thisClass.scope, ctx)
      }
      IF finishMethod == NIL
        out.write(", 0")
      ELSE
        out.write(", ")
        out.write(finishMethod.pName)
      }

      Declaration.C arg = NEW("", thisClass.getValueType(ctx))
      foundFunc = thisClass.findMatchingMethod("Equal",
                                    TRUE, [arg], NIL, :skipShared, &undef, ctx)
      IF foundFunc == NIL || !ctx.gen.isDeclUsed(foundFunc)
        out.write(", 0")
      ELSE
        out.write(", ")
        out.write(foundFunc.pName)
      }

      foundFunc = thisClass.findMatchingMethod("Compare",
                                   TRUE, [arg], NIL, :skipShared, &undef, ctx)
      IF foundFunc == NIL || !ctx.gen.isDeclUsed(foundFunc)
        out.write(", 0")
      ELSE
        out.write(", ")
        out.write(foundFunc.pName)
      }
    }

    out.write(", ")
    out.write(toName)

    out.write("};\n")
  }

  FUNC writeToTableLines(Declaration classDecl, Declaration decl,
               string tableName, int countStart, Output out,
               list<string> memberNames, SContext ctx) int
    int count = countStart
    VAR declDict = decl.type.getObjectDeclDict()
    IF declDict != NIL
      FOR memberList IN declDict.values()
        FOR d IN memberList
          IF !d.type.isMethodType()
               && (!Generate.skipUnused() || ctx.gen.isDeclUsed(d))
            string typeName = d.type.getTypeName(ctx)
            IF typeName != ""
                 && ((d.getClassName() != NIL && d.type.isManaged())
                               || ctx.gen.isDeclUsed(Declaration.itemToString))
              out.write(" {offsetof(\(classDecl.pName), \(d.pName)), (Tt*)&\(typeName)__T}, /* \(d.name) */\n")
              ++count
              IF memberNames != NIL
                memberNames.add(d.name)
              }
            }
          }
        }
      }
    }

    RETURN count
  }
}
