#
# The Zimbu compiler written in Zimbu
#
# C implementation for Dict
#
# Copyright 2009-2012 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO ../parser/zui.proto

IMPORT WriteC.zu
IMPORT WriteListC.zu
IMPORT ../CodeWriter.zu
IMPORT ../ContainerType.zu
IMPORT ../Declaration.zu
IMPORT ../DeclStore.zu
IMPORT ../DictStuff.zu
IMPORT ../ExprArg.zu
IMPORT ../Generate.zu
IMPORT ../ListStuff.zu
IMPORT ../ManageMemory.zu
IMPORT ../Output.zu
IMPORT ../Resolve.zu
IMPORT ../SContext.zu
IMPORT ../Type.zu
IMPORT ../WriteCommon.zu

MODULE WriteDictC @items=public                   # TODO: restrict visibility


  # [key1: value1, key2: value2] ->
  #    ZDictAdd(0, ZDictAdd(0, ZnewDict(), key1, value1), key2,  value2)
  # TODO: check for duplicate keys at compile time.
  # Return type of dict in |type|.
  PROC generateNewDict(Zui.Expression expr, string noAllocName,
                              SContext ctx, ContainerType type, Type destType)
    WriteCommon.getDictTypes(expr, ctx, type, destType)

    IF expr.sizeDictItem() == 0
      # empty dict: [:]
      writeDictAlloc(type, noAllocName, NIL, expr.getOrderedDict(), ctx)
    ELSE
      IF type.keyType == NIL || type.itemType == NIL
        RETURN
      }

      # First generate all the add calls.
      FOR item IN expr.getDictItemList()
        writeDictAddCall(type, ctx)
        ctx.out.write("0, ")
      }

      # Create the empty dict.
      writeDictAlloc(type, noAllocName, NIL, expr.getOrderedDict(), ctx)

      # Finish all the add calls.
      FOR item IN expr.getDictItemList()
        ctx.out.write(", ")
        # write the key argument
        WriteC.writeTzOrIobjArg(type.keyType, item.getKey(), ctx)
        # write the value argument
        ctx.out.write(", ")
        WriteC.writeTzOrIobjArg(type.itemType, item.getValue(), ctx)
        ctx.out.write(")")
      }
    }
  }

  # Write "ZDictAdd(" or a variant for an iobject argument.
  PROC writeDictAddCall(ContainerType type, SContext ctx)
    string keyName
    IF type.keyType.isIobject(ctx)
      keyName = "Iobj"
    ELSEIF type.keyType.getTtype() == Type.Enum.dyn
      keyName = "Dyn"
    ELSE
      keyName = ""
    }
    string itemName
    IF type.itemType.isIobject(ctx)
      itemName = "Iobj"
    ELSEIF type.itemType.getTtype() == Type.Enum.dyn
      itemName = "Dyn"
    ELSE
      itemName = ""
    }
    IF keyName == "" && itemName != ""
      keyName = "Tz"
    ELSEIF keyName != "" && itemName == ""
      itemName = "Tz"
    }
    ctx.out.write("ZDictAdd" .. keyName .. itemName .. "(")
  }

  PROC writeDictAlloc(ContainerType type, string noAllocName,
                        Zui.MethodCall call, bool isOrderedDict, SContext ctx)
    Output out = ctx.out
    IF noAllocName != NIL
      # %theDict = NEW()
      out.write("ZDictInit(&")
      out.write(noAllocName)
      out.write(", ")
    ELSE
      out.write("ZnewDict(")
    }
    out.write(WriteC.getTname(type.keyType, ctx))
    out.write(", ")
    out.write(WriteC.getTname(type.itemType, ctx))
    IF call != NIL && call.sizeArgument() == 1
      # NEW(bool): evaluate argument
      out.write(", ")
      ctx.gen.genArg(call.getArgument(0), ctx, Type.aBool)
    ELSEIF isOrderedDict
      # O[key: value]
      out.write(", 1")
    ELSE
      # [key: value]
      out.write(", 0")
    }
    out.write(")")
  }

  FUNC generateSubscript(ContainerType type, Zui.Expression expr, bool lvalue,
                                                 SContext ctx, Type destType
                        ) Type
    RETURN generateGet(type, expr.getLeft(), expr.getRight(),
                                                   NIL, lvalue, ctx, destType)
  }

  FUNC generateGet(ContainerType type, Zui.Expression dictExpr,
                                                       Zui.Expression keyExpr,
                         Zui.Expression defExpr, SContext ctx, Type destType
                 ) Type
    RETURN generateGet(type, dictExpr, keyExpr, defExpr, FALSE, ctx, destType)
  }

  FUNC generateGet(ContainerType type, Zui.Expression dictExpr,
                               Zui.Expression keyExpr, Zui.Expression defExpr,
                                      bool lvalue, SContext ctx, Type destType
                 ) Type
    string close = ")"
    IF type.itemType.isIobject(ctx)
      IF lvalue
        ctx.gen.setDeclUsed(%dictGetIobjP)
        ctx.out.write("*ZDictGetIobjP(")
      ELSEIF defExpr == NIL
        ctx.gen.setDeclUsed(%dictGetIobj)
        ctx.out.write("ZDictGetIobj(")
      ELSE
        ctx.gen.setDeclUsed(%dictGetIobjDef)
        ctx.out.write("ZDictGetIobjDef(")
      }
    ELSEIF type.itemType.getTtype() == Type.Enum.dyn
      IF lvalue
        ctx.gen.setDeclUsed(%dictGetDynP)
        ctx.out.write("*ZDictGetDynP(")
      ELSEIF defExpr == NIL
        ctx.gen.setDeclUsed(%dictGetDyn)
        ctx.out.write("ZDictGetDyn(")
      ELSE
        ctx.gen.setDeclUsed(%dictGetDynDef)
        ctx.out.write("ZDictGetDynDef(")
      }
    ELSEIF !type.itemType.isValueType()
      IF lvalue
        ctx.out.write("*")
        close ..= ctx.gen.typecast(type.itemType.getRefType(), ctx)
        ctx.gen.setDeclUsed(%dictGetPtrP)
        ctx.out.write("ZDictGetPtrP(")
      ELSE
        close ..= ctx.gen.typecast(type.itemType, ctx)
        IF defExpr == NIL
          ctx.gen.setDeclUsed(%dictGetPtr)
          ctx.out.write("ZDictGetPtr(")
        ELSE
          ctx.gen.setDeclUsed(%dictGetPtrDef)
          ctx.out.write("ZDictGetPtrDef(")
        }
      }
    ELSEIF type.itemType.isFloatType()
      IF lvalue
        ctx.gen.setDeclUsed(%dictGetFloatP)
        ctx.out.write("*ZDictGetFloatP(")
      ELSEIF defExpr == NIL
        ctx.gen.setDeclUsed(%dictGetFloat)
        ctx.out.write("ZDictGetFloat(")
      ELSE
        ctx.gen.setDeclUsed(%dictGetFloatDef)
        ctx.out.write("ZDictGetFloatDef(")
      }
    ELSE
      IF lvalue
        ctx.gen.setDeclUsed(%dictGetIntP)
        ctx.out.write("*ZDictGetIntP(")
      ELSEIF defExpr == NIL
        ctx.gen.setDeclUsed(%dictGetInt)
        ctx.out.write("ZDictGetInt(")
      ELSE
        ctx.gen.setDeclUsed(%dictGetIntDef)
        ctx.out.write("ZDictGetIntDef(")
      }
    }
    ctx.gen.setDeclUsed(%dictFind)
    Generate.genExpr(dictExpr, ctx)
    ctx.out.write(", ")
    WriteC.genTzArg(type.keyType, keyExpr, ctx)
    IF defExpr != NIL
      ctx.out.write(", ")
      Generate.genExprDoConv(defExpr, ctx, type.itemType)
    }
    ctx.out.write(close)
    IF type.itemType != NIL
      RETURN type.itemType
    }
    RETURN destType
  }

  FUNC generateMethodCall(ContainerType type, Zui.MethodCall call,
                                                 SContext ctx, Type destType
                         ) Type
    Type retType
    Zui.Expression name = call.getName()
    CHECK.true(name.getType() == Zui.ExprType.eMEMBER)
    string methodName = name.getRight().getName()
    Zui.Expression object = name.getLeft()
    list<Zui.Expression> argList = call.getArgumentList()
    bool dotnil = name.hasDotnil() && name.getDotnil()

    # If the types are not defined we must have produced an error already.
    IF type.keyType == NIL || type.itemType == NIL
      RETURN Type.anUnknown
    }

    IF methodName == "ToString"
      IF Generate.checkArgCount(call, 0, 1, ctx) == OK
        ctx.out.write("ZDictToString(")
        Generate.generateVarname(object, ctx, type)
        WriteC.oneToStringArgument(type.keyType, call, TRUE, ctx)
        WriteC.oneToStringArgument(type.itemType, call, TRUE, ctx)
        # TODO: format argument
        ctx.out.write(")")
        retType = Type.aString
      }
    ELSEIF methodName == "Type"
      ctx.out.write("(&")
      ctx.out.write(type.typeUsed(ctx).pName)
      ctx.out.write("__T)")
      retType = Type.aType
    ELSEIF methodName == "isOrdered"
      ctx.gen.setDeclUsed(%dictIsOrdered)
      ctx.out.write("ZDictIsOrdered(")
      Generate.genExpr(object, ctx, type)
      ctx.out.write(")")
      retType = Type.aBool
    ELSEIF methodName == "get"
      IF Generate.checkArgCount(call, 1, 2, ctx) == OK
        retType = ctx.gen.dictGet(type, object, argList[0],
                     call.sizeArgument() > 1 ? argList[1] : NIL,
                                                                ctx, destType)
      }
    ELSEIF methodName == "has"
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        ctx.gen.setDeclUsed(%dictHas)
        IF type.keyType.isIobject(ctx)
          ctx.out.write("ZDictHasIobj(")
        ELSEIF type.keyType.getTtype() == Type.Enum.dyn
          ctx.out.write("ZDictHasDyn(")
        ELSE
          ctx.out.write("ZDictHas(")
        }
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        WriteC.writeTzOrIobjArg(type.keyType, argList[0], ctx)
        ctx.out.write(")")
        retType = Type.aBool
      }
    ELSEIF methodName == "add" || methodName == "set"
      IF Generate.checkArgCount(call, 2, 2, ctx) == OK
        writeDictAddCall(type, ctx)
        ctx.out.write(methodName == "add" ? "0, " : "1, ")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        Zui.Expression arg0 = argList[0]
        Zui.Expression arg1 = argList[1]
        WriteC.writeTzOrIobjArg(type.keyType, arg0, ctx)
        ctx.out.write(", ")
        WriteC.writeTzOrIobjArg(type.itemType, arg1, ctx)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "remove"
                       || (methodName == "clear" && call.sizeArgument() > 0)
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        ctx.gen.setDeclUsed(%dictFind)
        Zui.Expression arg = argList[0]
        bool removeTz
        IF type.itemType != NIL && type.itemType.isValueType()
                                                      && methodName != "clear"
          # Only for remove() with value type item.
          ctx.gen.setDeclUsed(%dictRemoveInt)
          ctx.out.write("ZDictRemoveTz(")
          removeTz = TRUE
        ELSE
          ctx.gen.setDeclUsed(%dictRemovePtr)
          ctx.out.write("ZDictRemovePtr(")
        }
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        WriteC.genTzArg(type.keyType, arg, ctx)
        IF methodName == "clear"
          ctx.out.write(", 0)")  # no exception
          retType = DictStuff.newDict(type)
        ELSE
          IF removeTz
            IF type.itemType.isFloatType()
              ctx.out.write(").fval")
            ELSE
              ctx.out.write(").ival")
            }
          ELSE
            ctx.out.write(", 1)")  # exception when key not found
          }
          retType = type.itemType
        }
      }
    ELSEIF methodName == "clear"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.gen.setDeclUsed(%dictClear)
        ctx.out.write("ZDictClear(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "keys"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.gen.setDeclUsed(%dictKeys)
        ctx.out.write("ZDictKeys(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(dotnil ? ", 1)" : ", 0)")
        ContainerType listType = NEW(Type.Enum.list, "list")
        listType.itemType = type.keyType
        retType = listType
      }
    ELSEIF methodName == "values"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.gen.setDeclUsed(%dictValues)
        ctx.out.write("ZDictValues(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(dotnil ? ", 1)" : ", 0)")
        retType = ListStuff.newList(type)
      }
    ELSEIF methodName == "map" || methodName == "keyMap"
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        IF methodName == "map"
          ctx.gen.setDeclUsed(%dictMap)
          ctx.out.write("ZDictMap(")
        ELSE
          ctx.gen.setDeclUsed(%dictKeyMap)
          ctx.out.write("ZDictKeyMap(")
        }
        Generate.genExpr(object, ctx, type)

        ctx.out.write(", ")
        Zui.Expression arg = argList[0]
        Generate.genFuncArg(arg,
                 methodName == "map" ? NIL : type.keyType, type.itemType, ctx)

        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "copy"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.gen.setDeclUsed(%dictCopy)
        ctx.out.write("ZDictCopy(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "size" || methodName == "Size"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.gen.setDeclUsed(%dictSize)
        ctx.out.write("ZDictSize(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
      }
      retType = Type.anInt
    ELSEIF ctx.gen.writing
      ctx.error("Method " .. methodName .. "() not supported for Dict",
                                                                call.getPos())
    }

    IF retType == NIL
      RETURN Type.anUnknown
    }
    RETURN retType
  }

  PROC writeTypedefs(Resolve gen, IO.File fd)
    IF !gen.isDeclUsed(Declaration.dict)
      RETURN
    }
    fd.write(''"
typedef unsigned long Zhashtype;
typedef struct CDictItem__S CDictItem;
typedef struct CDictHead__S Td;
"'')
  }

  PROC writeDecl(WriteC gen, IO.File fd)
    IF !gen.isDeclUsed(Declaration.dict)
      RETURN
    }

    IF !gen.manageMemory()
      gen.setDeclUsed(WriteC.zfree)
    }

    # Basic Dict definitions.
    # dict with list:
    #   Td.first points to first item
    #   Td.last points to last item
    #   CDictItem.lnext points to next item (last one is NULL)
    #   CDictItem.lprev points to previous item (first one is NULL)
    fd.write(''"
#define HT_INIT_SIZE 16
#define PERTURB_SHIFT 5

#define DTYPE_ORDERED 1 /* dict with list to keep order of items */

#define CDI_FLAG_USED 1
#define CDI_FLAG_DEL 2
struct CDictItem__S {
 Zhashtype hash;
 union {
  Tz key;
  Tr iokey;"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(''"
  Tx dynkey;"'')
    }
    fd.write(''"
 };
 union {
  Tz item;
  Tr ioitem;"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(''"
  Tx dynitem;"'')
    }
    fd.write(''"
 };
 CDictItem *lnext;
 CDictItem *lprev;
 int flags;
};

struct CDictHead__S {
"'' .. gen.getStructHead() .. ''"
 Zhashtype mask;
 Zhashtype used;
 Zhashtype extra;
 Zhashtype filled;
 int tosNr;
 int type;
 CDictItem *array;
 CDictItem smallArray[HT_INIT_SIZE];"'')
    IF gen.manageMemory() && ManageMemory.isExitclean()
      # let valgrind find the allocated memory
      fd.write(''"
 void *alloced;"'')
    }
    fd.write(''"
 Tt *keyType;
 Tt *itemType;
 int (*eqfunc)(void *i, Tz *v);
 CDictItem *first;
 CDictItem *last;
};

Zhashtype ZDictHash(Tt *keyType, Tz key);
CDictItem *ZDictLookup(Td *d, Tz key, Zhashtype hash);
Td *ZDictAdd(int ow, Td *d, Tz key, Tz value);
void ZDictResize(Td *d, int minitems);
"'')
  }

  # Set dependencies of used items.
  PROC addDependencies(WriteC gen)
    # Items that are always used.
    Declaration.dict.addDependsOn(
                          DeclStore.getDecl("MEModule", "FthrowIntKeyExists"))
    Declaration.dict.addDependsOn(
                       DeclStore.getDecl("MEModule", "FthrowStringKeyExists"))
    Declaration.dict.addDependsOn(Declaration.throwInternal)
    Declaration.dict.addDependsOn(Declaration.throwCstringNil)

    # Not always used but too much work to figure it out properly.
    Declaration.dict.addDependsOn(
                        DeclStore.getDecl("MEModule", "FthrowIntKeyNotFound"))
    Declaration.dict.addDependsOn(
                     DeclStore.getDecl("MEModule", "FthrowStringKeyNotFound"))

    # ZdynEqual is used for dict when dyn is used.
    Declaration.dict.addDependsOnCond(Declaration.dynEqual, Type.aDyn, gen)

    Declaration.itemToString.addDependsOnCond(%dictToString, Declaration.dict,
                                                                          gen)
    Declaration.itemEqual.addDependsOnCond(%dictEqual, Declaration.dict, gen)
    Declaration.itemCompare.addDependsOnCond(%dictCompare, Declaration.dict,
                                                                          gen)
  }

  # Declarations used to keep track of used items.
  Declaration.C %dictFind = NEW("dictFind")
  Declaration.C %dictHas = NEW("dictHas")
  Declaration.C %dictIsOrdered = NEW("dictIsOrdered")
  Declaration.C %dictRemovePtr = NEW("dictRemovePtr")
  Declaration.C %dictRemoveInt = NEW("dictRemoveInt")
  Declaration.C %dictGetIobjP = NEW("dictGetIobjP")
  Declaration.C %dictGetIobj = NEW("dictGetIobj")
  Declaration.C %dictGetIobjDef = NEW("dictGetIobjDef")
  Declaration.C %dictGetDynP = NEW("dictGetDynP")
  Declaration.C %dictGetDyn = NEW("dictGetDyn")
  Declaration.C %dictGetDynDef = NEW("dictGetDynDef")
  Declaration.C %dictGetPtrP = NEW("dictGetPtrP")
  Declaration.C %dictGetPtr = NEW("dictGetPtr")
  Declaration.C %dictGetPtrDef = NEW("dictGetPtrDef")
  Declaration.C %dictGetInt = NEW("dictGetInt")
  Declaration.C %dictGetIntP = NEW("dictGetIntP")
  Declaration.C %dictGetIntDef = NEW("dictGetIntDef")
  Declaration.C %dictGetFloatP = NEW("dictGetFloatP")
  Declaration.C %dictGetFloat = NEW("dictGetFloat")
  Declaration.C %dictGetFloatDef = NEW("dictGetFloatDef")
  Declaration.C %dictToString = NEW("dictToString")
  Declaration.C %dictKeys = NEW("dictKeys")
  Declaration.C %dictValues = NEW("dictValues")
  Declaration.C %dictMap = NEW("dictMap")
  Declaration.C %dictKeyMap = NEW("dictKeyMap")
  Declaration.C %dictClear = NEW("dictClear")
  Declaration.C %dictCopy = NEW("dictCopy")
  Declaration.C %dictSize = NEW("dictSize")
  Declaration.C %dictEqual = NEW("dictEqual")
  Declaration.C %dictCompare = NEW("dictCompare")
  Declaration.C %dictIntKeyNotFound = NEW("dictIntKeyNotFound")
  Declaration.C %dictStringKeyNotFound = NEW("dictStringKeyNotFound")

  PROC initCodeWriters(list<CodeWriter> codeWriters)
    codeWriters.add(NEW(%dictIntKeyNotFound,
      PROC (WriteC gen, IO.File fd)
        string intKey = DeclStore.getPName("MEModule", "FthrowIntKeyNotFound")
        fd.write(''"
void ZthrowIntKeyNotFound(Tz key, Tc *msg) {
  "'' .. intKey .. ''"(key.ival, msg);
}
"'')
      }).setDependencies([["MEModule", "FthrowIntKeyNotFound"]]))

    codeWriters.add(NEW(%dictStringKeyNotFound,
      PROC (WriteC gen, IO.File fd)
        string stringKey = DeclStore.getPName("MEModule",
                                                  "FthrowStringKeyNotFound")
        fd.write(''"
void ZthrowStringKeyNotFound(Tz key, Tc *msg) {
  "'' .. stringKey .. ''"(key.ptr, msg);
}
"'')
      }).setDependencies([["MEModule", "FthrowStringKeyNotFound"]]))

    codeWriters.add(NEW(%dictFind,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
CDictItem *ZDictFind(Td *d, Tz key) {
 Zhashtype  hash = ZDictHash(d->keyType, key);
 CDictItem  *di = ZDictLookup(d, key, hash);
 if (di->flags & CDI_FLAG_USED) return di;
 return NULL;
}
"'')
      }))

    codeWriters.add(NEW(%dictGetIobjP,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tr *ZDictGetIobjP(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di == NULL) {
  static Tr dummy = {0, 0, 0};
  ZDictAdd(1, d, key, (Tz)(void*)&dummy);
  di = ZDictFind(d, key);
 }
 return &di->ioitem;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetIobj,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tr ZDictGetIobj(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) {
  return di->ioitem;
 }
 if (d->keyType->nr >= 100) ZthrowStringKeyNotFound(key, Zstr(""));
 ZthrowIntKeyNotFound(key, Zstr(""));
 return trZero;
}
"'')
      }).setDependencies([%dictFind,
                          %dictStringKeyNotFound,
                          %dictIntKeyNotFound]))

    codeWriters.add(NEW(%dictGetIobjDef,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tr ZDictGetIobjDef(Td *d, Tz key, Tr def) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) return di->ioitem;
 return def;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetDynP,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tx *ZDictGetDynP(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di == NULL) {
  static Tx dummy = {0, 0};
  ZDictAdd(1, d, key, (Tz)(void*)&dummy);
  di = ZDictFind(d, key);
 }
 return &di->dynitem;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetDyn,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tx ZDictGetDyn(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) {
  return di->dynitem;
 }
 if (d->keyType->nr >= 100) ZthrowStringKeyNotFound(key, Zstr(""));
 ZthrowIntKeyNotFound(key, Zstr(""));
 return trZero;
}
"'')
      }).setDependencies([%dictFind,
                          %dictStringKeyNotFound,
                          %dictIntKeyNotFound]))

    codeWriters.add(NEW(%dictGetDynDef,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tx ZDictGetIobjDef(Td *d, Tz key, Tx def) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) return di->dynitem;
 return def;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetPtrP,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
void *ZDictGetPtrP(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di == NULL) {
  ZDictAdd(1, d, key, (Tz)(void*)0);
  di = ZDictFind(d, key);
 }
 return &di->item.ptr;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetPtr,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
void *ZDictGetPtr(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) {
  return di->item.ptr;
 }
 if (d->keyType->nr >= 100) ZthrowStringKeyNotFound(key, Zstr(""));
 ZthrowIntKeyNotFound(key, Zstr(""));
 return NULL;
}
"'')
      }).setDependencies([%dictFind,
                          %dictStringKeyNotFound,
                          %dictIntKeyNotFound]))

    codeWriters.add(NEW(%dictGetPtrDef,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
void *ZDictGetPtrDef(Td *d, Tz key, void *def) {
 void *r;
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) r = di->item.ptr;
 else r = def;
 return r;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetIntP,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Ti *ZDictGetIntP(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di == NULL) {
  ZDictAdd(1, d, key, (Tz)(Ti)0);
  di = ZDictFind(d, key);
 }
 return &di->item.ival;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetInt,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Ti ZDictGetInt(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) {
  return di->item.ival;
 }
 if (d->keyType->nr >= 100) ZthrowStringKeyNotFound(key, Zstr(""));
 ZthrowIntKeyNotFound(key, Zstr(""));
 return 0;
}
"'')
      }).setDependencies([%dictFind,
                          %dictStringKeyNotFound,
                          %dictIntKeyNotFound]))

    codeWriters.add(NEW(%dictGetIntDef,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Ti ZDictGetIntDef(Td *d, Tz key, Ti def) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) return di->item.ival;
 return def;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetFloatP,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tf *ZDictGetFloatP(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di == NULL) {
  ZDictAdd(1, d, key, (Tz)(Tf)0);
  di = ZDictFind(d, key);
 }
 return &di->item.fval;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictGetFloat,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tf ZDictGetFloat(Td *d, Tz key) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) {
  return di->item.fval;
 }
 if (d->keyType->nr >= 100) ZthrowStringKeyNotFound(key, Zstr(""));
 ZthrowIntKeyNotFound(key, Zstr(""));
 return 0;
}
"'')
      }).setDependencies([%dictFind,
                          %dictStringKeyNotFound,
                          %dictIntKeyNotFound]))

    codeWriters.add(NEW(%dictGetFloatDef,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tf ZDictGetFloatDef(Td *d, Tz key, Tf def) {
 CDictItem *di = ZDictFind(d, key);
 if (di != NULL) return di->item.fval;
 return def;
}
"'')
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictHas,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tb ZDictHas(Td *d, Tz key) {
 return (ZDictFind(d, key) != NULL);
}
Tb ZDictHasIobj(Td *d, Tr key) {
 return (ZDictFind(d, (Tz)(void*)&key) != NULL);
}"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
Tb ZDictHasDyn(Td *d, Tx key) {
 return (ZDictFind(d, (Tz)(void*)&key) != NULL);
}"'')
        }
      }).setDependencies([%dictFind]))

    codeWriters.add(NEW(%dictIsOrdered,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tb ZDictIsOrdered(Td *d) {
 if (d == NULL) ZthrowCstringNil("Invoking isOrdered() on NIL dict");
 return (d->type & DTYPE_ORDERED) != 0;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

    codeWriters.add(NEW(%dictRemovePtr,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
void *ZDictRemovePtr(Td *d, Tz key, int remove) {
 CDictItem *di;
 void *r = NULL;
 if (d == NULL) ZthrowCstringNil("Invoking remove() on NIL dict");
 di = ZDictFind(d, key);
 if (di != NULL) {
  r = di->item.ptr;
  di->flags = CDI_FLAG_DEL;
  --d->used;
  ZDictResize(d, 0);
  if (d->type & DTYPE_ORDERED) {
   if (di->lprev) di->lprev->lnext = di->lnext;
   else d->first = di->lnext;
   if (di->lnext) di->lnext->lprev = di->lprev;
   else d->last = di->lprev;
  }
 } else if (remove) {
  if (d->keyType->nr >= 100) ZthrowStringKeyNotFound(key, Zstr("dict.remove(): "));
  ZthrowIntKeyNotFound(key, Zstr("dict.remove(): "));
 }
 if (remove)
   return r;
 return d;
}

"'')
      }).setDependencies([%dictFind,
                          Declaration.throwCstringNil,
                          %dictStringKeyNotFound,
                          %dictIntKeyNotFound]))

    codeWriters.add(NEW(%dictRemoveInt,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tz ZDictRemoveTz(Td *d, Tz key) {
 CDictItem *di;
 Tz r;
 if (d == NULL) ZthrowCstringNil("Invoking remove() on NIL dict");
 di = ZDictFind(d, key);
 if (di != NULL) {
  di->flags = CDI_FLAG_DEL;
  r = di->item;
  --d->used;
  ZDictResize(d, 0);
  if (d->type & DTYPE_ORDERED) {
   if (di->lprev) di->lprev->lnext = di->lnext;
   else d->first = di->lnext;
   if (di->lnext) di->lnext->lprev = di->lprev;
   else d->last = di->lprev;
  }
 } else {
  if (d->keyType->nr >= 100) ZthrowStringKeyNotFound(key, Zstr("dict.remove(): "));
  ZthrowIntKeyNotFound(key, Zstr("dict.remove(): "));
  r.ival = 0;
 }
 return r;
}

"'')
      }).setDependencies([%dictFind,
                          Declaration.throwCstringNil,
                          %dictStringKeyNotFound,
                          %dictIntKeyNotFound]))

    codeWriters.add(NEW(%dictToString,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
void ZDiToString(Td *d, int keyUseq, int itemUseq, CDictItem *di, Tg *ga) {
 if (d->keyType == &iobj__T)
  ZitemToString((Tt*)(di->iokey.table[0]), keyUseq, (Tz)di->iokey.ptr, ga);"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
 else if (d->keyType == &dyn__T)
  ZitemToString(di->dynkey.type, keyUseq, di->dynkey.u, ga);"'')
        }
        fd.write(''"
 else
  ZitemToString(d->keyType, keyUseq, di->key, ga);
 ga_append(ga, ": ");
 if (d->itemType == &iobj__T)
  ZitemToString((Tt*)(di->ioitem.table[0]), keyUseq, (Tz)di->ioitem.ptr, ga);"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
 else if (d->itemType == &dyn__T)
  ZitemToString(di->dynitem.type, itemUseq, di->dynitem.u, ga);"'')
        }
        fd.write(''"
 else
  ZitemToString(d->itemType, itemUseq, di->item, ga);
}

void ZDictToStringGa(Td *d, int keyUseq, int itemUseq, Tg *ga) {
 int first = 1;
 int todo = d->used;
 Tn *e = "'' .. gen.getEnvCode() .. ''";
 CDictItem *di;
 ga_append(ga, "[");
 if (todo == 0) {
  ga_append(ga, ":");  /* empty dictionary: [:] */
 } else if (e->tosNr == d->tosNr) {
  ga_append(ga, "recursive-dict");
 } else {
  d->tosNr = e->tosNr;
  if (d->type & DTYPE_ORDERED) {
   for (di = d->first; di; di = di->lnext) {
    if (first == 0) ga_append(ga, ", "); else first = 0;
    ZDiToString(d, keyUseq, itemUseq, di, ga);
   }
  } else {
   for (di = d->array; todo > 0; ++di) {
    if (di->flags & CDI_FLAG_USED) {
     --todo;
     if (first == 0) ga_append(ga, ", "); else first = 0;
     ZDiToString(d, keyUseq, itemUseq,di, ga);
    }
   }
  }
  d->tosNr = 0;
 }
 ga_append(ga, "]");
}

Tc *ZDictToString(Td *d, int keyUseq, int itemUseq) {
 Tg ga;
 Tc *r;
 if (d == NULL) return (Tc*)&ZNilString;
 ++"'' .. gen.getEnvCode() .. ''"->tosNr;
 ga.data = NULL;
 ga.used = 0;
 ZDictToStringGa(d, keyUseq, itemUseq, &ga);
 r = ZnewString(ga.data, ga.used);"'')
        IF !gen.manageMemory()
          fd.write(''"
 Zfree((void*)ga.data - ZOH_OFF);"'')
        }
        fd.write(''"
 return r;
}
"'')
      }).setDecl("void ZDictToStringGa(Td *d, int keyUseq, int itemUseq, Tg *ga);\n"))

    codeWriters.add(NEW(%dictKeys,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tl *ZDictKeys(Td *d, int dn) {
 Tl *l;
 int todo;
 CDictItem *di;
 if (d == NULL) {
  if (dn) return NULL;
  ZthrowCstringNil("Invoking keys() on NIL dict");
 }
 l = ZnewList(d->keyType, d->used);
 if (d->type & DTYPE_ORDERED) {
  if (d->keyType == &iobj__T)
   for (di = d->first; di; di = di->lnext) {
    ZLaIobj(l, -1, di->iokey);
   }"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
  else if (d->keyType == &dyn__T)
   for (di = d->first; di; di = di->lnext) {
    ZLaDyn(l, -1, di->dynkey);
   }"'')
        }
        fd.write(''"
  else
   for (di = d->first; di; di = di->lnext) {
    ZLa(l, -1, di->key);
   }
 } else {
  todo = d->used;
  for (di = d->array; todo > 0; ++di) {
   if (di->flags & CDI_FLAG_USED) {
    --todo;
    if (d->keyType == &iobj__T)
     ZLaIobj(l, -1, di->iokey);"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
    else if (d->keyType == &dyn__T)
     ZLaDyn(l, -1, di->dynkey);"'')
        }
        fd.write(''"
    else
     ZLa(l, -1, di->key);
   }
  }
 }
 return l;
}
"'')
      }).setDependencies([Declaration.throwCstringNil,
                          WriteListC.listAdd]))

    codeWriters.add(NEW(%dictValues,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tl *ZDictValues(Td *d, int dn) {
 Tl *l;
 int todo;
 CDictItem *di;
 if (d == NULL) {
  if (dn) return NULL;
  ZthrowCstringNil("Invoking values() on NIL dict");
 }
 l = ZnewList(d->itemType, d->used);
 if (d->type & DTYPE_ORDERED) {
  if (d->itemType == &iobj__T)
   for (di = d->first; di; di = di->lnext) {
    ZLaIobj(l, -1, di->ioitem);
   }"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
  else if (d->itemType == &dyn__T)
   for (di = d->first; di; di = di->lnext) {
    ZLaDyn(l, -1, di->dynitem);
   }"'')
        }
        fd.write(''"
  else
   for (di = d->first; di; di = di->lnext) {
    ZLa(l, -1, di->item);
   }
 } else {
  todo = d->used;
  for (di = d->array; todo > 0; ++di) {
   if (di->flags & CDI_FLAG_USED) {
    --todo;
    if (d->itemType == &iobj__T)
     ZLaIobj(l, -1, di->ioitem);"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
    else if (d->itemType == &dyn__T)
     ZLaDyn(l, -1, di->dynitem);"'')
        }
        fd.write(''"
    else
     ZLa(l, -1, di->item);
   }
  }
 }
 return l;
}
"'')
      }).setDependencies([Declaration.throwCstringNil,
                          WriteListC.listAdd]))

    codeWriters.add(NEW(WriteC.forDict,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
void ZforDictGet(Tfd *tfd) {
 Td *d = tfd->d;
 CDictItem *di = tfd->di;
 if (di) {
  if (tfd->keyp) {
   if (d->keyType == &iobj__T)
    *(Tr*)tfd->keyp = di->iokey;"'')
         IF gen.isDeclUsed(Type.aDyn)
           fd.write(''"
   else if (d->keyType == &dyn__T)
    *(Tx*)tfd->keyp = di->dynkey;"'')
         }
         fd.write(''"
   else
    ZptrAssign(tfd->keyp, d->keyType->nr, di->key);
  }
  if (d->itemType == &iobj__T)
   *(Tr*)tfd->valp = di->ioitem;"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
  else if (d->itemType == &dyn__T)
   *(Tx*)tfd->valp = di->dynitem;"'')
        }
        fd.write(''"
  else
    ZptrAssign(tfd->valp, d->itemType->nr, di->item);
 }
}

void ZforDictStart(Tfd *tfd) {
 Td *d = tfd->d;
 if (d != NULL && d->used) {
  if (d->type & DTYPE_ORDERED) {
   tfd->di = d->first;
  } else {
   CDictItem *di = d->array;
   while ((di->flags & CDI_FLAG_USED) == 0) ++di;
   tfd->di = di;
   tfd->todo = d->used - 1;
  }
  ZforDictGet(tfd);
 } else {
  tfd->di = NULL;
 }
}

int ZforDictCont(Tfd *tfd) {
 return tfd->di != NULL;
}

void ZforDictNext(Tfd *tfd) {
 Td *d = tfd->d;
 if (d->type & DTYPE_ORDERED) {
  tfd->di = tfd->di->lnext;
 } else if (tfd->todo > 0) {
  CDictItem *di = tfd->di + 1;
  while ((di->flags & CDI_FLAG_USED) == 0) ++di;
  tfd->di = di;
  --tfd->todo;
 } else {
  tfd->di = NULL;
 }
 ZforDictGet(tfd);
}

"'')
      }).setDependencies([WriteC.ptrAssign]))

    codeWriters.add(NEW(%dictMap,
      PROC (WriteC gen, IO.File fd)
        IF gen.manageMemory()
          fd.write(''"
Zfo ZDictMapfo[3] = {{0,&dict__T},{0,&cb__T},{0,0}};"'')
        }
        fd.write(''"
Td *ZDictMap(Td *d, Tcb *f) {
 int todo;
 CDictItem *di;"'')
        IF gen.manageMemory()
          fd.write(''"
 Tn *e = "'' .. gen.getEnvCode() .. ''";"'')
          gen.stackFrameLead("ZDictMapfo", fd)
          fd.write(''"
  ZDictMapfo[0].off = (void*)&sf - (void*)&d;
  ZDictMapfo[1].off = (void*)&sf - (void*)&f;"'')
          gen.stackFrameFoot(fd)
        }
        fd.write(''"
 if (d == NULL) ZthrowCstringNil("Invoking map() on NIL dict");
 todo = d->used;
 for (di = d->array; todo > 0; ++di) {
  if (di->flags & CDI_FLAG_USED) {
   --todo;
   if (d->itemType->nr >= 100) {
    di->item.ptr = ((void *(*)(Tcb *, void *))f->cfunc)(f, di->item.ptr);
   } else di->item.ival = ((Ti (*)(Tcb *, Ti))f->cfunc)(f, di->item.ival);
  }
 }"'')
        IF gen.manageMemory()
          gen.stackFrameEnd(fd)
        }
        fd.write(''"
 return d;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

    codeWriters.add(NEW(%dictKeyMap,
      PROC (WriteC gen, IO.File fd)
        IF gen.manageMemory()
          fd.write(''"
Zfo ZDictKeyMapfo[3] = {{0,&dict__T},{0,&cb__T},{0,0}};"'')
        }
        fd.write(''"
Td *ZDictKeyMap(Td *d, Tcb *f) {
 int todo;
 CDictItem *di;"'')
        IF gen.manageMemory()
          fd.write(''"
 Tn *e = "'' .. gen.getEnvCode() .. ''";"'')
          gen.stackFrameLead("ZDictKeyMapfo", fd)
          fd.write(''"
  ZDictKeyMapfo[0].off = (void*)&sf - (void*)&d;
  ZDictKeyMapfo[1].off = (void*)&sf - (void*)&f;"'')
          gen.stackFrameFoot(fd)
        }
        fd.write(''"
 if (d == NULL) ZthrowCstringNil("Invoking keymap() on NIL dict");
  todo = d->used;
  for (di = d->array; todo > 0; ++di) {
   if (di->flags & CDI_FLAG_USED) {
    --todo;
    if (d->keyType->nr >= 100) {
     if (d->itemType->nr >= 100) {
      di->item.ptr = ((void *(*)(Tcb *, void *, void *))f->cfunc)(f, di->key.ptr, di->item.ptr);
     } else di->item.ival = ((Ti (*)(Tcb *, void *, Ti))f->cfunc)(f, di->key.ptr, di->item.ival);
    } else {
     if (d->itemType->nr >= 100) {
      di->item.ptr = ((void *(*)(Tcb *, Ti, void *))f->cfunc)(f, di->key.ival, di->item.ptr);
     } else di->item.ival = ((Ti (*)(Tcb *, Ti, Ti))f->cfunc)(f, di->key.ival, di->item.ival);
    }
   }
 }"'')
        IF gen.manageMemory()
          gen.stackFrameEnd(fd)
        }
        fd.write(''"
 return d;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

    codeWriters.add(NEW(%dictClear,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Td *ZDictClear(Td *d) {
 int todo;
 CDictItem *item;
 if (d == NULL) ZthrowCstringNil("Invoking clear() on NIL dict");"'')
        IF !gen.manageMemory()
          fd.write(''"
 if (d->array != d->smallArray) Zfree((void*)d->array - ZOH_OFF);"'')
        }
        fd.write(''"
 d->mask = HT_INIT_SIZE - 1;
 d->used = 0;
 d->filled = 0;
 d->array = d->smallArray;
 d->first = NULL;
 d->last = NULL;
 memset(d->smallArray, 0, (size_t)(sizeof(CDictItem) * HT_INIT_SIZE));
 return d;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

    codeWriters.add(NEW(%dictCopy,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Td *ZDictCopy(Td *d) {
 Td *newd = Za(sizeof(Td));
 CDictItem *item;
 int todo = (int)d->used;
 memcpy((char *)newd + ZOH_OFF, (char *)d + ZOH_OFF, sizeof(Td) - ZOH_OFF);
 if (d->array == d->smallArray) newd->array = newd->smallArray;
 else {
  size_t len = (d->mask + 1) * sizeof(CDictItem);
  newd->array = ZaOff(len);"'')
      IF gen.manageMemory() && ManageMemory.isExitclean()
        fd.write(''"
  newd->alloced = (void *)newd->array - ZOH_OFF;"'')
      }
      fd.write(''"
  memcpy(newd->array, d->array, len);
 }
 return newd;
}
"'')
      }))

    codeWriters.add(NEW(%dictSize,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Ti ZDictSize(Td *d) {
 if (d == NULL) return 0;
 return d->used;
}
"'')
      }))

    codeWriters.add(NEW(%dictEqual,
      PROC (WriteC gen, IO.File fd)
        fd.write(''"
Tb ZDictEqual(Td *ah, Td *bh) {
 int todo;
 CDictItem *itema;
 CDictItem *itemb;
 if (ah == NULL || bh == NULL) ZthrowCstringNil("Comparing with NIL dict");
 if (ah->keyType != bh->keyType) return 0;
 if (ah->used != bh->used) return 0;
 if (ah->itemType->nr < 80) {
  if (bh->itemType->nr >= 80) return 0;
 } else if (ah->itemType->nr < 100) {
  if (bh->itemType->nr < 80 || bh->itemType->nr >= 100) return 0;
 } else if (bh->itemType->nr < 100) return 0;
 todo = (int)ah->used;
 for (itema = ah->array, itemb = bh->array; todo > 0; ++itema, ++itemb) {
  if (itema->flags & CDI_FLAG_USED) {
   if (!(itemb->flags & CDI_FLAG_USED)) return 0;
   if (!ZitemEqual(ah->itemType, itema->item, bh->itemType, itemb->item)) return 0;
   --todo;
  }
 }
 return 1;
}"'')
      }).setDependencies([Declaration.throwCstringNil])
        .setDecl("Tb ZDictEqual(Td *ah, Td *bh);\n"))
    
    codeWriters.add(NEW(%dictCompare,
      PROC (WriteC gen, IO.File fd)
        # For now only take number of items into account.
        # TODO: when is one dict really bigger than another?
        fd.write(''"
int ZDictCompare(Td *ah, Td *bh) {
 if (ah == NULL || bh == NULL) ZthrowCstringNil("Comparing with NIL dict");
 if (ah->keyType != bh->keyType) return 1;
 if (ah->used == bh->used) return 0;
 return ah->used > bh->used ? 1 : -1;
}"'')
      }).setDependencies([Declaration.throwCstringNil])
        .setDecl("int ZDictCompare(Td *ah, Td *bh);\n"))

  } # end of initCodeWriters()

  PROC writeBody(WriteC gen, IO.File fd)
    IF !gen.isDeclUsed(Declaration.dict)
      RETURN
    }

    # Functions mandatory for dict use.
    # The implementation mostly comes from src/hashtab.c in Vim.  For
    # comments on how it works see that file.

    fd.write(''"
int ZDeqNr(Tz *l, Tz *r) {
 return l->ival == r->ival;
}
int ZDeqFloat(Tz *l, Tz *r) {
 return l->fval == r->fval;
}
int ZDeqStr(Tz *l, Tz *r) {
 Tc *p1;
 Tc *p2;
 Ti len1;
 Ti len2;
 if (r->ptr != NULL) {
  len1 = ZstringSizePtr(l->ptr, &p1);
  len2 = ZstringSizePtr(r->ptr, &p2);
  if (len1 == len2) return memcmp(p1, p2, len1) == 0;
 }
 return 0;
}
int ZDeqRef(Tz *l, Tz *r) {
 return l->ptr == r->ptr;
}
int ZDeqIobj(Tr *l, Tz *r) {
 return l->ptr == ((Tr*)r->ptr)->ptr;
}"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(''"
int ZDeqDyn(Tx *l, Tz *r) {
 return ZdynEqual(*l, *(Tx*)r->ptr);
}"'')
    }
    fd.write(''"

Td *ZDictHead(Td *d, Tt *keyType, Tt *itemType, Tb ordered) {
 d->array = d->smallArray;
 d->mask = HT_INIT_SIZE - 1;
 d->keyType = keyType;
 d->itemType = itemType;
 if (itemType == NULL) ZthrowCstringNil("Creating dict without item type");
 if (keyType == NULL) ZthrowCstringNil("Creating dict without key type");
 if (ordered) d->type = DTYPE_ORDERED;
 if (keyType->nr < 80) d->eqfunc = (int (*)(void*, Tz*))ZDeqNr;
 else if (keyType->nr < 100) d->eqfunc = (int (*)(void*, Tz*))ZDeqFloat;
 else if (keyType == &iobj__T) d->eqfunc = (int (*)(void*, Tz*))ZDeqIobj;"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(''"
 else if (keyType == &dyn__T) d->eqfunc = (int (*)(void*, Tz*))ZDeqDyn;"'')
    }
    fd.write(''"
 else if (keyType == &string__T || keyType == &byteString__T) d->eqfunc = (int (*)(void*, Tz*))ZDeqStr;"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(''"
 else if (keyType == &dyn__T) d->eqfunc = (int (*)(void*, Tz*))ZDeqDyn;"'')
    }
    fd.write(''"
 else d->eqfunc = (int (*)(void*, Tz*))ZDeqRef;
 return d;
}
Td *ZDictInit(Td *d, Tt *keyType, Tt *itemType, Tb ordered) {
 memset(d, 0, sizeof(Td));"'')
    IF gen.hasNpField()
      fd.write(''"
 d->np = &Znoalloc;"'')
    }
    fd.write(''"
 ZDictHead(d, keyType, itemType, ordered);
 return d;
}
Td *ZnewDict(Tt *keyType, Tt *itemType, Tb ordered) {
 return ZDictHead(Za(sizeof(Td)), keyType, itemType, ordered);
}

Zhashtype ZDictHash(Tt *keyType, Tz key) {
 Zhashtype hash;
 void *ptr;
 if (keyType->nr < 80) return (Zhashtype)key.ival;
 if (keyType->nr < 100) return (Zhashtype)key.fval;
 if (keyType == &iobj__T) {
  ptr = ((Tr*)key.ptr)->ptr;"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(''"
 } else if (keyType == &dyn__T) {
  return ZDictHash(((Tx*)key.ptr)->type, ((Tx*)key.ptr)->u);"'')
    }
    fd.write(''"
 } else {
  ptr = key.ptr;
 }
 if (ptr == NULL) ZthrowCstringNil("dict key is NIL");
 if (keyType == &string__T || keyType == &byteString__T) {
  Tc *p;
  int l = ZstringSizePtr(key.ptr, &p);
  if (l == 0) {
   hash = 0;
  } else {
   hash = *p;
   while (--l > 0) {
    hash = hash * 101 + *++p;
   }
  }
 } else {
  Tip k = (Tip)ptr;
  int l = sizeof(Tc*);
  hash = k & 0xff;
  while (--l > 0) {
   k >>= 8;
   hash = hash * 101 + (k & 0xff);
  }
 }
 return hash;
}
"'')
    string intKeyEx = DeclStore.getPName("MEModule", "FthrowIntKeyExists")
    string stringKeyEx = DeclStore.getPName("MEModule",
                                                    "FthrowStringKeyExists")
    fd.write(''"
void ZthrowIntKeyExists(Tz key, Tc *msg) {
  "'' .. intKeyEx .. ''"(key.ival, msg);
}
void ZthrowStringKeyExists(Tz key, Tc *msg) {
  "'' .. stringKeyEx .. ''"(key.ptr, msg);
}

/* #define DICT_DEBUG 1 */

CDictItem *ZDictLookup(Td *d, Tz key, Zhashtype hash)
{
 Zhashtype  perturb;
 CDictItem  *freeitem;
 int        idx = (int)(hash & d->mask);
 CDictItem  *di = &d->array[idx];
 if (di->flags == 0) return di;
 if (di->flags == CDI_FLAG_DEL) freeitem = di;
 else if (di->hash == hash && d->keyType == &iobj__T ? d->eqfunc(&di->iokey, &key)"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(" : d->keyType == &dyn__T ? d->eqfunc(&di->dynkey, &key)")
    }
    fd.write(''" : d->eqfunc(&di->key, &key)) {
  return di;
 } else {
  freeitem = NULL;
 }

 for (perturb = hash; ; perturb >>= PERTURB_SHIFT)
 {
  idx = (int)((idx << 2) + idx + perturb + 1);
  di = &d->array[idx & d->mask];
  if (di->flags == 0) return freeitem == NULL ? di : freeitem;
  if (di->hash == hash && di->flags != CDI_FLAG_DEL && d->keyType == &iobj__T ? d->eqfunc(&di->iokey, &key)"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(" : d->keyType == &dyn__T ? d->eqfunc(&di->dynkey, &key)")
    }
    fd.write(''" : d->eqfunc(&di->key, &key)) return di;
  if (di->flags == CDI_FLAG_DEL && freeitem == NULL) freeitem = di;
 }
}

void ZDictResize(Td *d, int minitems) {
 CDictItem temparray[HT_INIT_SIZE];
 CDictItem *oldarray, *newarray;
 CDictItem *olditem, *newitem, *nextitem;
 int newi;
 int todo;
 Zhashtype oldsize, newsize;
 Zhashtype minsize;
 Zhashtype newmask;
 Zhashtype perturb;

#ifdef DICT_DEBUG
 printf("size: %lu, filled: %lu, used: %lu\n",
           d->mask + 1, d->filled, d->used);
#endif

 if (minitems == 0) {
  if (d->filled < HT_INIT_SIZE - 1 && d->array == d->smallArray) {
#ifdef DICT_DEBUG
   printf("small array not full\n");
#endif
   return;
  }
  oldsize = d->mask + 1;
  if (d->filled * 3 < oldsize * 2 && d->used > oldsize / 5) {
#ifdef DICT_DEBUG
   printf("size OK\n");
#endif
   return;
  }
  if (d->used > 1000) minsize = d->used * 2;
  else minsize = d->used * 4;
 } else {
  if ((Zhashtype)minitems < d->used) minitems = (int)d->used;
  minsize = minitems * 3 / 2;
 }

 newsize = HT_INIT_SIZE;
 while (newsize < minsize) {
  newsize <<= 1;
  if (newsize == 0) {
   ZthrowInternal(Zstr("ZDictResize"));
   return;
  }
 }

#ifdef DICT_DEBUG
 printf("resizing from %lu to %lu\n", d->mask + 1, newsize);
#endif

 if (newsize == HT_INIT_SIZE) {
  newarray = d->smallArray;
  if (d->array == newarray) {
   memmove(temparray, newarray, sizeof(temparray));
   oldarray = temparray;
  } else
   oldarray = d->array;
  memset(newarray, 0, (size_t)(sizeof(CDictItem) * newsize));
 } else {
  newarray = (CDictItem *)ZaOff((sizeof(CDictItem) * newsize));"'')
    IF gen.manageMemory() && ManageMemory.isExitclean()
      fd.write(''"
  d->alloced = (void *)newarray - ZOH_OFF;"'')
    }
    fd.write(''"
  oldarray = d->array;
 }

 newmask = newsize - 1;
 todo = (int)d->used;
 for (olditem = oldarray; todo > 0; ++olditem)
  if (olditem->flags & CDI_FLAG_USED) {
   newi = (int)(olditem->hash & newmask);
   newitem = &newarray[newi];
   if (newitem->flags != 0)
    for (perturb = olditem->hash; ; perturb >>= PERTURB_SHIFT) {
     newi = (int)((newi << 2) + newi + perturb + 1);
     newitem = &newarray[newi & newmask];
     if (newitem->flags == 0) break;
    }
   *newitem = *olditem;
   if (d->type & DTYPE_ORDERED) {
    olditem->lprev = newitem;
   }
   --todo;
  }
 if ((d->type & DTYPE_ORDERED) && d->first) {
  olditem = d->first;
  newitem = olditem->lprev;
  newitem->lprev = NULL;
  d->first = newitem;
  while (olditem->lnext) {
   olditem = olditem->lnext;
   nextitem = olditem->lprev;
   newitem->lnext = nextitem;
   newitem->lnext->lprev = newitem;
   newitem = nextitem;
  }
  newitem->lnext = NULL;
  d->last = newitem;
 }
"'')
    IF !gen.manageMemory()
      fd.write(''"
 if (d->array != d->smallArray) Zfree((void*)d->array - ZOH_OFF);"'')
    }
    fd.write(''"
 d->array = newarray;
 d->mask = newmask;
 d->filled = d->used;
}

/* "ow" is the overwrite flag.  When zero it's not allowed to overwrite an
 * existing entry. */
Td *ZDictAdd(int ow, Td *d, Tz key, Tz value) {
 Zhashtype hash;
 CDictItem *di;
 if (d == NULL) ZthrowCstringNil("Adding item to NIL dict");
 hash = ZDictHash(d->keyType, key);
 di = ZDictLookup(d, key, hash);
#ifdef DICT_DEBUG
 if (d->keyType->nr >= 100)
   printf("Adding item %s\n", (Tc*)key.ptr);
 else
   printf("Adding item %lld\n", key.ival);
 if (key.ptr != NULL
     && (strcmp(key.ptr, "ENUM") == 0
         || strcmp(key.ptr, "Equal") == 0
         || strcmp(key.ptr, "EXIT") == 0))
   dumpdict(d);
#endif
 if (di->flags == 0 || di->flags == CDI_FLAG_DEL || ow) {
  if (di->flags == 0 || di->flags == CDI_FLAG_DEL) {
   ++d->used;
   if (di->flags == 0)
    ++d->filled;
  }
  di->hash = hash;
  if (d->keyType->nr == 391) {
   di->iokey = *(Tr*)key.ptr;"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(''"
  } else if (d->keyType->nr == 360) {
   di->dynkey = *(Tx*)key.ptr;"'')
    }
    fd.write(''"
  } else if (d->keyType->nr >= 100) {
   if (di->flags == 0 || di->flags == CDI_FLAG_DEL) {
    di->key = key;
   }
  } else di->key = key;
  if (d->itemType->nr == 391)
   di->ioitem = *(Tr*)value.ptr;"'')
    IF gen.isDeclUsed(Type.aDyn)
      fd.write(''"
  else if (d->itemType->nr == 360)
   di->dynitem = *(Tx*)value.ptr;"'')
    }
    fd.write(''"
  else
   di->item = value;
  di->flags = CDI_FLAG_USED;
  if (d->type & DTYPE_ORDERED) {
   di->lprev = d->last;
   if (d->last) d->last->lnext = di;
   else d->first = di;
   d->last = di;
   di->lnext = NULL;
  }

  ZDictResize(d, 0);
 } else {
  if (d->keyType->nr >= 100) ZthrowStringKeyExists(key, Zstr("dict.add(): "));
  ZthrowIntKeyExists(key, Zstr("dict.add(): "));
 }
 return d;
}"'')

    # Passing "Tr" by value is a bit expensive, only do this when actually
    # using a Tr type.  We can use a pointer internally, since we don't
    # store the pointer.
    fd.write(''"
Td *ZDictAddIobjTz(int ow, Td *d, Tr key, Tz value) {
 return ZDictAdd(ow, d, (Tz)(void*)&key, value);
}
Td *ZDictAddTzIobj(int ow, Td *d, Tz key, Tr value) {
 return ZDictAdd(ow, d, key, (Tz)(void*)&value);
}
Td *ZDictAddIobjIobj(int ow, Td *d, Tr key, Tr value) {
 return ZDictAdd(ow, d, (Tz)(void*)&key, (Tz)(void*)&value);
}"'')

    IF gen.isDeclUsed(Type.aDyn)
      # Passing "Tx" by value is a bit expensive, just like "Tr".
      # Need all the combinations...
      fd.write(''"
Td *ZDictAddDynTz(int ow, Td *d, Tx key, Tz value) {
 return ZDictAdd(ow, d, (Tz)(void*)&key, value);
}
Td *ZDictAddDynIobj(int ow, Td *d, Tx key, Tr value) {
 return ZDictAdd(ow, d, (Tz)(void*)&key, (Tz)(void*)&value);
}
Td *ZDictAddTzDyn(int ow, Td *d, Tz key, Tx value) {
 return ZDictAdd(ow, d, key, (Tz)(void*)&value);
}
Td *ZDictAddIobjDyn(int ow, Td *d, Tr key, Tx value) {
 return ZDictAdd(ow, d, (Tz)(void*)&key, (Tz)(void*)&value);
}
Td *ZDictAddDynDyn(int ow, Td *d, Tx key, Tx value) {
 return ZDictAdd(ow, d, (Tz)(void*)&key, (Tz)(void*)&value);
}"'')
    }

    IF LOG.isDebug()
      fd.write(''"

#ifdef DICT_DEBUG
dumpdict(Td *d)
{
 int        todo = (int)d->used;
 CDictItem  *item;
 int        idx = 0;

 for (item = d->array; todo > 0; ++item) {
  if (item->flags & CDI_FLAG_USED) {
   printf("%2d: %s\n", idx, (Tc*)item->key.ptr);
   --todo;
  } else if (item->flags == 0) {
   printf("%2d: unused\n", idx);
  } else if (item->flags == CDI_FLAG_DEL) {
   printf("%2d: deleted\n", idx);
  } else {
   printf("%2d: invalid flags: %d\n", idx, item->flags);
  }
  ++idx;
 }
}
#endif

"'')
    }
  }

}
