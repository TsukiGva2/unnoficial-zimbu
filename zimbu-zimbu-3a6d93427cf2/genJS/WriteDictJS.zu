#
# The Zimbu compiler written in Zimbu
#
# Stuff for Dict
#
# Copyright 2009-2012 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO ../parser/zui.proto

IMPORT ../CodeWriter.zu
IMPORT ../ContainerType.zu
IMPORT ../Declaration.zu
IMPORT ../DeclStore.zu
IMPORT ../DictStuff.zu
IMPORT ../ExprArg.zu
IMPORT ../Generate.zu
IMPORT ../ListStuff.zu
IMPORT ../Output.zu
IMPORT ../Report.zu
IMPORT ../SContext.zu
IMPORT ../Type.zu
IMPORT ../WriteCommon.zu
IMPORT WriteJS.zu

MODULE WriteDictJS @public @items=public       # TODO: restrict visibility

  # [key1: value1, key2: value2] ->
  #    ZDictAdd(0, ZDictAdd(0, ZnewDict(), key1, value1), key2, value2)
  # TODO: check for duplicate keys at compile time.
  # Return type of dict in |type|.
  PROC generateNewDict(Zui.Expression expr,
                             SContext ctx, ContainerType type, Type destType)
    WriteCommon.getDictTypes(expr, ctx, type, destType)

    IF expr.sizeDictItem() == 0
      # empty dict: [:]
      writeDictAlloc(type, NIL, NIL, expr.getOrderedDict(), ctx)
    ELSE
      IF type.keyType == NIL || type.itemType == NIL
        RETURN
      }

      # Write an add function head for each item.
      FOR item IN expr.getDictItemList() ?: []
        ctx.out.write("ZDictAdd(0, ")
      }

      # Create the dict.
      writeDictAlloc(type, NIL, NIL, expr.getOrderedDict(), ctx)

      # Write the end of the add function for each item.
      FOR item IN expr.getDictItemList() ?: []
        ctx.out.write(", ")
        # write the key argument
        genKeyArg(type, item.getKey(), ctx)
        ctx.out.write(", ")
        # write the value argument
        Generate.genExprDoConv(item.getValue(), ctx, type.itemType)
        ctx.out.write(")")
      }
    }
  }

  FUNC generateSubscript(ContainerType type, Zui.Expression expr, bool lvalue,
                                                 SContext ctx, Type destType
                        ) Type
    Type ret = generateGet(type,
                  expr.getLeft(), expr.getRight(), NIL, lvalue, ctx, destType)
    RETURN ret
  }

  FUNC generateGet(ContainerType type, Zui.Expression dictExpr,
                               Zui.Expression keyExpr, Zui.Expression defExpr,
                                      bool lvalue, SContext ctx, Type destType
                 ) Type
    IF lvalue
      Report.internal("Using wrong way to assign to dict")
    }
    IF defExpr == NIL
      ctx.setDeclUsed(%dictGet)
      ctx.out.write("ZDictGet(")
      Generate.genExpr(dictExpr, ctx)
      ctx.out.write(", ")
      Generate.genExprDoConv(keyExpr, ctx, type.keyType)
      ctx.out.write(")")
    ELSE
      ctx.setDeclUsed(%dictGetDef)
      ctx.out.write("ZDictGetDef(")
      Generate.genExpr(dictExpr, ctx)
      ctx.out.write(", ")
      Generate.genExprDoConv(keyExpr, ctx, type.keyType)
      ctx.out.write(", ")
      Generate.genExprDoConv(defExpr, ctx, type.itemType)
      ctx.out.write(")")
    }
    IF type.itemType != NIL
      RETURN type.itemType
    }
    RETURN destType
  }

  FUNC dictAssign(string varname, string key, SContext ctx) string
    ctx.out.write("ZDictAdd(1, ")
    ctx.out.write(varname)
    ctx.out.write(", ")
    ctx.out.write(key)
    ctx.out.write(", ")
    RETURN ")"
  }

  FUNC generateMethodCall(ContainerType type, Zui.MethodCall call,
                                                 SContext ctx, Type destType
                         ) Type
    Type retType
    Zui.Expression name = call.getName()
    CHECK.true(name.getType() == Zui.ExprType.eMEMBER)
    string methodName = name.getRight().getName()
    Zui.Expression object = name.getLeft()
    list<Zui.Expression> argList = call.getArgumentList()
    bool dotnil = name.hasDotnil() && name.getDotnil()

    IF methodName == "ToString"
      IF Generate.checkArgCount(call, 0, 1, ctx) == OK
        ctx.setDeclUsed(%dictToString)
        ctx.out.write("ZDictToString(")
        # Write the object and arguments for key and item type.
        Generate.generateVarname(object, ctx, type)
        WriteJS.oneToStringArgument(type.keyType, call, TRUE, ctx)
        WriteJS.oneToStringArgument(type.itemType, call, TRUE, ctx)
        # TODO: format argument
        ctx.out.write(")")
        retType = Type.aString
      }
    ELSEIF methodName == "Type"
      ctx.out.write(type.typeUsed(ctx).pName)
      ctx.out.write("__T")
      retType = Type.aType
    ELSEIF methodName == "isOrdered"
      ctx.gen.setDeclUsed(%dictIsOrdered)
      ctx.out.write("ZDictIsOrdered(")
      Generate.genExpr(object, ctx, type)
      ctx.out.write(")")
      retType = Type.aBool
    ELSEIF methodName == "get"
      IF Generate.checkArgCount(call, 1, 2, ctx) == OK
        retType = ctx.gen.dictGet(type, object, argList[0],
                     call.sizeArgument() > 1 ? argList[1] : NIL,
                                                                ctx, destType)
      }
    ELSEIF methodName == "has"
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        ctx.setDeclUsed(%dictHas)
        ctx.out.write("ZDictHas(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        genKeyArg(type, argList[0], ctx)
        ctx.out.write(")")
        retType = Type.aBool
      }
    ELSEIF methodName == "add" || methodName == "set"
      IF Generate.checkArgCount(call, 2, 2, ctx) == OK
        ctx.out.write("ZDictAdd(")
        ctx.out.write(methodName == "add" ? "0, " : "1, ")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        Zui.Expression arg0 = argList[0]
        Zui.Expression arg1 = argList[1]
        genKeyArg(type, arg0, ctx)
        genValueArg(type, arg1, ctx)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "remove"
                       || (methodName == "clear" && call.sizeArgument() > 0)
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        ctx.setDeclUsed(%dictRemove)
        Zui.Expression arg = argList[0]
        ctx.out.write("ZDictRemove(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(", ")
        genKeyArg(type, arg, ctx)
        IF methodName == "clear"
          ctx.out.write(", 0)")  # no exception
          retType = DictStuff.newDict(type)
        ELSE
          ctx.out.write(", 1)")  # exception when key not found
          retType = type.itemType
        }
      }
    ELSEIF methodName == "clear"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictClear)
        ctx.out.write("ZDictClear(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "keys"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictKeys)
        ctx.out.write("ZDictKeys(")
        Generate.genExpr(object, ctx, type)
        # Need to pass the keyType for in case the dict is NIL.
        ctx.out.write(", ")
        ctx.out.write(WriteJS.getTypeName(type.keyType, ctx))
        ctx.out.write(dotnil ? ", 1)" : ", 0)")
        retType = ListStuff.newList(type)
        retType.<ContainerType>.itemType = type.keyType
      }
    ELSEIF methodName == "values"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictValues)
        ctx.out.write("ZDictValues(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(dotnil ? ", 1)" : ", 0)")
        retType = ListStuff.newList(type)
      }
    ELSEIF methodName == "map" || methodName == "keyMap"
      IF Generate.checkArgCount(call, 1, 1, ctx) == OK
        IF methodName == "map"
          ctx.setDeclUsed(%dictMap)
          ctx.out.write("ZDictMap(")
        ELSE
          ctx.setDeclUsed(%dictKeyMap)
          ctx.out.write("ZDictKeyMap(")
        }
        Generate.genExpr(object, ctx, type)

        ctx.out.write(", ")
        Zui.Expression arg = argList[0]
        Generate.genFuncArg(arg,
                 methodName == "map" ? NIL : type.keyType, type.itemType, ctx)

        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "copy"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictCopy)
        ctx.out.write("ZDictCopy(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
        retType = DictStuff.newDict(type)
      }
    ELSEIF methodName == "size" || methodName == "Size"
      IF Generate.checkArgCount(call, 0, 0, ctx) == OK
        ctx.setDeclUsed(%dictSize)
        ctx.out.write("ZDictSize(")
        Generate.genExpr(object, ctx, type)
        ctx.out.write(")")
      }
      retType = Type.anInt
    ELSEIF ctx.gen.writing
      ctx.error("Method " .. methodName .. "() not supported for Dict",
                                                              call.getPos())
    }

    IF retType == NIL
      RETURN Type.anUnknown
    }
    RETURN retType
  }

  # Generate the key argument for |expr|.
  PROC genKeyArg(ContainerType type, Zui.Expression expr, SContext ctx)
    IF type.keyType == NIL
      ctx.out.write("nokeytype")
      RETURN
    }
    Generate.genExprDoConv(expr, ctx, type.keyType)
  }

  # Generate the value argument for |expr|.
  # Outputs ", val".
  PROC genValueArg(ContainerType type, Zui.Expression expr, SContext ctx)
    ctx.out.write(", ")
    Generate.genExprDoConv(expr, ctx, type.itemType ?: Type.anInt)
  }

  # Set dependencies between used items.  Called before marking Main() as
  # used.
  PROC addDependencies(WriteJS gen)
    Declaration.itemToString.addDependsOnCond(%dictToString, Declaration.dict,
                                                                          gen)

    # Not always used but too much work to figure it out properly.
    Declaration.dict.addDependsOn(
                     DeclStore.getDecl("MEModule", "FthrowStringKeyNotFound"))
    Declaration.dict.addDependsOn(
                     DeclStore.getDecl("MEModule", "FthrowStringKeyExists"))
  }


  Declaration.C %dictToString = NEW("dictToString")
  Declaration.C %dictGet = NEW("dictGet")
  Declaration.C %dictGetDef = NEW("dictGetDef")
  Declaration.C %dictIsOrdered = NEW("dictIsOrdered")
  Declaration.C %dictRemove = NEW("dictRemove")
  Declaration.C %dictCopy = NEW("dictCopy")
  Declaration.C %dictSize = NEW("dictSize")
  Declaration.C %dictHas = NEW("dictHas")
  Declaration.C %dictClear = NEW("dictClear")
  Declaration.C %dictKeys = NEW("dictKeys")
  Declaration.C %dictValues = NEW("dictValues")
  Declaration.C %dictMap = NEW("dictMap")
  Declaration.C %dictKeyMap = NEW("dictKeyMap")
  Declaration.C %dictCompare = NEW("dictCompare")
  Declaration.C %dictEqual = NEW("dictEqual")

  PROC initCodeWriters(list<CodeWriter> codeWriters)
    codeWriters.add(NEW(%dictToString,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictToString(d, keyUseq, itemUseq) {
 if (!d) return "NIL";
 ++tosNr;
 return ZDictToStringGa(d, keyUseq, itemUseq);
}
function ZDictToStringGa(d, keyUseq, itemUseq) {
 if (!d) return 'NIL';
 var res = ['['];
 if (d.tosNr == tosNr) {
  res.push('recursive-dict');
 } else {
  d.tosNr = tosNr;
  var first = 1;
  for (var key in d) {
   if (key.charCodeAt(0) == 58) {
    if (first == 0)
     res.push(', ');
    else
     first = 0;
    var v = d[key];
    res.push(ZitemToString(v[0], d.keyType, keyUseq));
    res.push(": ");
    res.push(ZitemToString(v[1], d.itemType, itemUseq));
   }
  }
  d.tosNr = 0;
  if (first) return '[:]';
 }
 res.push(']');
 return res.join('');
}
"'')
      }).setDependencies([Declaration.itemToString]))

    codeWriters.add(NEW(%dictGet,
      PROC (WriteJS gen, IO.File fd)
        string stringKey = DeclStore.getPName("MEModule",
                                                    "FthrowStringKeyNotFound")
        fd.write(''"
function ZDictGet(d, key) {
 if (d == null) ZthrowNil("getting item from NIL dict");
 var ckey = ZDictKey(d, key);
 if (ckey in d)
  return d[ckey][1];
 "'' .. stringKey .. ''"(key, '');
}
"'')
      }).setDependencies([["MEModule", "FthrowStringKeyNotFound"]]))

    codeWriters.add(NEW(%dictGetDef,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictGetDef(d, key, def) {
 var ckey = ZDictKey(d, key);
 if (ckey in d)
  return d[ckey][1];
 return def;
}
"'')
      }))

    codeWriters.add(NEW(%dictKeys,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictKeys(d, kt, dn) {
 var l = [];
 var i = 0;
 if (d) {
  for (var key in d) {
   if (key.charCodeAt(0) == 58) {
    l[i++] = d[key][0];
   }
  }
 }
 return {a: l, itemType: kt};
}
"'')
      }))

    codeWriters.add(NEW(%dictValues,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictValues(d, dn) {
 if (!d) {
  if (dn) return null;
  ZthrowNil("Invoking values() on NIL dict");
 }
 var l = [];
 var i = 0;
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   l[i++] = d[key][1];
  }
 }
 return {a: l, itemType: d.itemType};
}
"'')
      }))

    codeWriters.add(NEW(%dictMap,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictMap(d, f) {
 if (d == null) return null;
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   d[key][1] = f(d[key][1]);
  }
 }
 return d;
}
"'')
      }))

    codeWriters.add(NEW(%dictKeyMap,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictKeyMap(d, f) {
 if (d == null) return null;
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   var v = d[key];
   v[1] = f(v[0], v[1]);
  }
 }
 return d;
}
"'')
      }))

    codeWriters.add(NEW(%dictRemove,
      PROC (WriteJS gen, IO.File fd)
        string stringKey = DeclStore.getPName("MEModule",
                                                  "FthrowStringKeyNotFound")
        fd.write(''"
function ZDictRemove(d, key, remove) {
 var r;
 var ckey = ZDictKey(d, key);
 if (ckey in d) {
  d.size--;
  r = d[ckey][1];
  delete d[ckey];
 } else if (remove) {
  "'' .. stringKey .. ''"(key, 'dict.remove(): ');
 }
 if (remove)
  return r;
 return d;
}

"'')
      }).setDependencies([["MEModule", "FthrowStringKeyNotFound"]]))

    codeWriters.add(NEW(%dictClear,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictClear(d) {
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   delete d[key];
  }
 }
 d.size = 0;
 return d;
}
"'')
      }))

    codeWriters.add(NEW(%dictCopy,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictCopy(d) {
 var newd = {};
 for (var key in d) {
  if (key.charCodeAt(0) == 58) {
   newd[key] = d[key].slice(0);
  } else {
   newd[key] = d[key];
  }
 }
 return newd;
}
"'')
      }))

    codeWriters.add(NEW(%dictSize,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictSize(d) {
 return d ? d.size : 0;
}
"'')
      }))

    codeWriters.add(NEW(%dictHas,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictHas(d, key) {
 var ckey = ZDictKey(d, key);
 return ckey in d;
}
"'')
      }))

    codeWriters.add(NEW(%dictIsOrdered,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictIsOrdered(d) {
 if (d == null) ZthrowNil("Invoking isOrdered() on NIL dict");
 return d.ordered;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

    codeWriters.add(NEW(%dictEqual,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictEqual(dl, dr) {
 if (!dl || !dr) ZthrowNil("Comparing with NIL dict");
 if (dl.size != dr.size) return false;
 for (var ckey in dl) {
  if (ckey.charCodeAt(0) == 58 && (!dr[ckey] || !ZitemEqual(dl.itemType, dl[ckey][1], dr.itemType, dr[ckey][1]))) return false;
 }
 return true;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

    codeWriters.add(NEW(%dictCompare,
      PROC (WriteJS gen, IO.File fd)
        fd.write(''"
function ZDictCompare(dl, dr) {
 if (!l || !r) ZthrowNil("Comparing with NIL dict");
 if (dl.size != dr.size) return dl.size > dr.size ? 1 : -1;
 for (var ckey in dl) {
  if (ckey.charCodeAt(0) == 58 && (!dr[ckey] || !ZitemEqual(dl.itemType, dl[ckey][1], dr.itemType, dr[ckey][1]))) return 1;
 }
 return 0;
}
"'')
      }).setDependencies([Declaration.throwCstringNil]))

  }  # end of initCodeWriters

  PROC writeBody(WriteJS gen, IO.File fd)
    IF gen.isDeclUsed(Declaration.dict)
      # "ow" is the overwrite flag.  When zero it's not allowed to overwrite
      # an existing entry.
      # For keys that are objects we add an "id" field with a unique number,
      # so that we follow C in using object identity for the key.
      # For a dyn key insert the type, so that the number 11 and the string
      # "11" are different. Add the name so that enum and object differ.
      string keyExists = DeclStore.getPName("MEModule",
                                                    "FthrowStringKeyExists")
      fd.write(''"
var nextId = 0;
function ZDictKey(d, key) {
 if (!key) return ':';
 if (d.keyType[0] == 360) {
  var kl = ':' + key[0][0] + key[0][1];
  var val = key[1];
  if (typeof val == 'object') {
   if (!val.id) val.id = ':' + ++nextId;
   return kl + val.id;
  }
  return kl + ':' + val;
 }
 if (typeof key == 'object') {
  if (!key.id) key.id = ':' + ++nextId;
  return key.id;
 }
 return ':' + key;
}
function ZDictAdd(ow, d, key, value) {
 if (!d) ZthrowNil("adding item to NIL dict");
 var ckey = ZDictKey(d, key);
 if (d[ckey]) {
  if (!ow) "'' .. keyExists .. ''"(key, 'dict.add(): ');
 } else {
  d.size++;
 }
 d[ckey] = [key, value];
 return d;
}

function ZnewDict(keyType, itemType, ordered) {
  return {size: 0, keyType: keyType, itemType: itemType, ordered: ordered};
}
"'')
    }
  }

  PROC writeDictAlloc(ContainerType type, string noAllocName,
                        Zui.MethodCall call, bool isOrderedDict, SContext ctx)
    Output out = ctx.out
    out.write("ZnewDict(")
    out.write(WriteJS.getTypeName(type.keyType, ctx))
    out.write(", ")
    out.write(WriteJS.getTypeName(type.itemType, ctx))
    IF call != NIL && call.sizeArgument() == 1
      # NEW(bool): evaluate argument
      out.write(", ")
      ctx.gen.genArg(call.getArgument(0), ctx, Type.aBool)
    ELSEIF isOrderedDict
      # O[key: value]
      out.write(", 1")
    ELSE
      # [key: value]
      out.write(", 0")
    }
    out.write(")")
  }

}
