#
# The Zimbu compiler written in Zimbu
#
# MainFile class: values for the main file.
#
# Copyright 2009 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO parser/zui.proto

IMPORT Annotator.zu
IMPORT Arguments.zu
IMPORT Builtin.zu
IMPORT ClassType.zu
IMPORT CommonFlags.zu
IMPORT Config.zu
IMPORT Declaration.zu
IMPORT DeclStore.zu
IMPORT Generate.zu
IMPORT Output.zu
IMPORT Resolve.zu
IMPORT SContext.zu
IMPORT TopScope.zu
IMPORT Type.zu
IMPORT UsedFile.zu
IMPORT ZimbuFile.zu
IMPORT ZuiDeclarationExt.zu
IMPORT genC/WriteC.zu
IMPORT genJava/WriteJava.zu
IMPORT genJS/WriteJS.zu

CLASS MainFile @items=public   # TODO: restrict visibility
  UsedFile   $usedFile   # The file contents, and imports recursively.
  TopScope   $topScope   # What is used globally.

  NEW(string fileName)
    $topScope = NEW()
    $usedFile = NEW(fileName, :isMainFile + :isTopFile)
  }

  # Parse the main file.
  FUNC $parse() status
    RETURN $usedFile.parse($topScope, "")
  }

  # Return TRUE if there is a Main() method in this file.
  FUNC $hasMain() bool
    RETURN $usedFile.hasMain()
  }

  # Recursively parse imported files.
  # Doing all the parsing first quickly finds syntax errors and locates used
  # builtin modules.
  PROC $parseImports()
    CTX.add($topScope)
    $usedFile.parseImports("", $getSContext())
  }

  # Recursively resolve symbols.
  # Return TRUE if another pass is needed.
  FUNC $resolve() bool
    ++$topScope.pass

    CTX.add($topScope)
    bool r = Generate.resolve($usedFile, $getSContext())

    # Remember whether the undefined count wasn't zero.
    lastPassUndef = $usedFile.scope().undefined != 0

    # Run the garbage collector after finishing every other pass.
    IF ($topScope.pass & 1) == 0
      GENERATE_IF Z.have("portable")
        GC.run()
      GENERATE_ELSE
        # Run the garbage collector in another thread, so that this one can
        # continue after the mark phase.
        IF %gcThread == NIL
          %gcPipe = NEW()
          %gcThread = NEW()
          %gcThread.start()
        }
        %gcPipe.write(TRUE)
      }
    }

    RETURN r
  }

  FUNC $getSContext() SContext
    Resolve gen = NEW()
    Output.Group dummy = NEW()
    RETURN NEW($usedFile.scope(), gen, dummy)
  }

  bool $prevUndefNonZero

  # Generate C code and write it to |outFile|.
  PROC $generateC(string inFileName, IO.File outFile)
    WriteC gen = NEW()
    # We do not want to write a declaration for abstract classes.
    Declaration.abstractClass.clearUsed()
    # We do not write an inherited method in the parent class.
    Declaration.inheritMethod.clearUsed()

    # Reset before marking items as used, isDeclused() uses it.
    $prevUndefNonZero = Generate.undefinedNonZero
    Generate.undefinedNonZero = FALSE

    gen.setDeclUsed(Declaration.cCode)

    # Add dependencies for all the CodeWriters.
    gen.addDependencies()

    $markUsed(gen)

    $generateCommon(inFileName, gen, outFile)
  }

  # Generate JS code and write it to |outFile|.
  PROC $generateJS(string inFileName, IO.File outFile)
    WriteJS gen = createJsGen()

    # Reset before marking items as used, isDeclused() uses it.
    $prevUndefNonZero = Generate.undefinedNonZero
    Generate.undefinedNonZero = FALSE

    $markUsed(gen)
    $usedFile.zimbuFile.usedAsZwt = TRUE

    $generateCommon(inFileName, gen, outFile)
  }

  # Generate Java code and write it to |outFile|.
  PROC $generateJava(string inFileName, IO.File outFile)
    WriteJava gen = createJavaGen()

    # Reset before marking items as used, isDeclused() uses it.
    $prevUndefNonZero = Generate.undefinedNonZero
    Generate.undefinedNonZero = FALSE

    $markUsed(gen)

    $generateCommon(inFileName, gen, outFile)
  }

  # Generate C or JS code and write it to |outFile|.
  PROC $generateCommon(string inFileName, Resolve gen, IO.File outFile)
    # Add annotations to the code.  Used to decide if temp vars are needed and
    # stop GC for unsafe calls.
    Annotator.annotate($usedFile, $topScope, gen)

    # First do it with prevUndefNonZero FALSE so that errors in generated code
    # will be given.
    $generateInner(inFileName, gen, outFile)

    IF $prevUndefNonZero && LOG.errorCount == 0
      IF Generate.unusedUndefined == Generate.undefinedCount
                                     && !CommonFlags.reportErrorInUnused.get()
        LOG.warning("Last pass had undefined symbols in unused code (use --reportErrorInUnused to see the problem)")
      ELSE
        LOG.warning("Last pass had undefined symbols, "
                        .. "yet no errors were reported when generating code")
        Generate.reportUndef = TRUE
        Generate.skip_zero_undefined = FALSE
        $resolve()

        IF LOG.errorCount == 0
          # We have undefined symbols but no errors were reported.  Do it again
          # while producing unused code as well, so that errors in not generated
          # code are given.
          IO.print("Making another pass to find errors")
          $topScope.clearStartedWrite()
          Generate.undefinedNonZero = TRUE
          Generate.continueAfterError = TRUE
          $generateInner(inFileName, gen, outFile)
        }
        LOG.error("Found undefined symbols")
      }
    }
  }

  PROC $generateInner(string inFileName, Resolve gen, IO.File outFile)
    # Write the C code into |outputs|.
    Output.Group outputs = NEW()
    outputs.startWriting()

    CTX.add($topScope)
    SContext ctx = NEW($usedFile.scope(), gen, outputs)

    # Write global declarations to |outputs|.
    gen.writeGlobals(ctx)

    # Write code to |outputs|.
    Generate.unusedUndefined = 0
    Generate.write($usedFile, ctx, outputs)

    IF LOG.errorCount == 0
      # Write the collected C code from |outputs| into the output file.
      outFile.write("/*\n")
      outFile.write(" * Generated from Zimbu file " .. inFileName .. "\n")
      outFile.write(" */\n")
      gen.writeFile($usedFile, ctx, outputs, outFile)
    }
  }

  # Mark symbols as used, including Main() and builtin modules.
  PROC $markUsed(Resolve gen)
    IF Arguments.testMode
      # Mark all symbols used directly or indirectly from test methods as used.
      $usedFile.markTestsUsed(gen, $topScope)
    ELSE
      # Mark all symbols used directly or indirectly from Main() as used.
      $usedFile.markMainUsed(gen, $topScope)
    }

    # Mark dependencies in Builtin modules as used.
    Builtin.markUsed(gen, $topScope)

    # Let the language add dependencies for used symbols.
    # Must come last before write().
    gen.markUsed()

    # Now it's no longer permitted to mark items as used that are defined
    # in the program or libraries.
    gen.didMarkUsed = TRUE
  }

  # If there are any ZUT modules, write the Javascript.
  PROC $generateZUT()
    IF $topScope.javascriptImports == NIL
      RETURN
    }

    IF Arguments.testMode && !CommonFlags.writeJsFlag.get()
      # When running C tests some ZUT modules may produce Javascript, but they
      # won't get exectued.
      RETURN
    }
    LOG.info("Generating Javascript code...")

    WriteJS jsGen = createJsGen()
    Output.Group jsOutputs = NEW()
    jsOutputs.startWriting()

    FOR zimbuFile IN $topScope.javascriptImports.values()
      Zui.Statement stmt = zimbuFile.getDeclarationStatement(FALSE)
      IF stmt != NIL
        Declaration topDecl = stmt.getDeclaration().<ZuiDeclarationExt>.decl
        # Mark used items.
        jsGen.setDeclUsed(topDecl)
      }
    }
    
    # Mark the action methods that were registered from C as used.
    IF $topScope.declarationsUsedInJs != NIL
      FOR method IN $topScope.declarationsUsedInJs
        jsGen.setDeclUsed(method)
      }
    }

    # Used in writeZutFooter()
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CContext", "MNEW__1"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CElement", "MNEW"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEventConfig", "MNEW"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEventConfig", "Mlisten"))

    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEvent__X",
                                                            "FnewClickEvent"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEvent__X",
                                                          "FnewKeyDownEvent"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEvent__X",
                                                            "FnewKeyUpEvent"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEvent__X",
                                                              "FnewKeyEvent"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEvent__X",
                                                        "FnewMouseMoveEvent"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEvent__X",
                                                        "FnewMouseOverEvent"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEvent__X",
                                                         "FnewMouseOutEvent"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule__CEvent__X",
                                                      "FnewValueChangeEvent"))
    jsGen.setDeclUsed(DeclStore.getDecl("MZUTModule", "FonLoad"))

    jsGen.setDeclUsed(DeclStore.getDecl("MEModule__CNilAccess", "MNEW__p2__2"))

    jsGen.setDeclUsed(Declaration.usesCtx)

    bool first = TRUE

    # Produce the imports marked with @javascript.
    UsedFile firstUsedFile
    SContext firstCtx
    Output initOut = NEW()
    initOut.writing = TRUE
    CTX.add($topScope)
    FOR zimbuFile IN $topScope.javascriptImports.values()
      IF jsGen.needWrite(zimbuFile)
        UsedFile usedFile = NEW(zimbuFile, FALSE)
        SContext newCtx = NEW(usedFile.scope(), jsGen, jsOutputs)
        IF first
          first = FALSE
          firstCtx = newCtx

          # Generate used parts of builtin modules.
          Builtin.generateBuiltins(FALSE, TRUE, firstCtx)
          firstUsedFile = usedFile

          # Write global declarations to |outputs|.
          jsGen.writeGlobals(firstCtx)
        }

        jsOutputs.structOut.write("// \(zimbuFile.filename) structs\n")
        jsOutputs.declOut.write("// \(zimbuFile.filename) declarations\n")
        jsOutputs.bodyOut.write("// \(zimbuFile.filename) bodies\n")
        Generate.write(usedFile, newCtx, jsOutputs, "  ")

        # Collect initialization function calls.  Clear the initialization for
        # the next import.
        initOut.append(jsOutputs.initOut)
        IF jsOutputs.initLead == ""
          # Wrote "if (round == 2001) {", need to close it.
          initOut.write(" }\n")
        }
        jsOutputs.earlyInitOut.clear()
        jsOutputs.initOut.clear()
        jsOutputs.earlyInitLead = NIL
        jsOutputs.initLead = NIL
      }
    }

    IF firstUsedFile != NIL
      # Put the collected inits back.
      jsOutputs.initOut.append(initOut)

      # Write JSoutputs to ZUDIR/main.js
      # TODO: do we need to get the output directory of the binary?
      jsGen.writeJavascript(firstUsedFile, firstCtx,
                            Config.zudirName, "main.js", jsOutputs)
    }
  }

  SHARED

    # This flag is set when the previous pass had undefined symbols.
    # It is used when writing, we know there is something wrong.
    bool lastPassUndef

    # Generate Javascript for IMPORT.ZWT.
    PROC generateJSFile(UsedFile usedFile, SContext ctx)
      Zui.Statement stmt = usedFile.zimbuFile.getModuleStatement()
      IF stmt == NIL
        RETURN
      }
      Declaration moduleDecl = stmt.getDeclaration().<ZuiDeclarationExt>.decl

      WriteJS jsGen = createJsGen()

      # Delete older versions of the produced files.
      string fname = jsGen.zwtFilename(usedFile.zimbuFile)
      IO.print("Deleting \(fname)")
      IO.delete(fname)

      # Mark used items.
      jsGen.setDeclUsed(moduleDecl)

      string moduleName = usedFile.zimbuFile.getModuleName()
      Declaration initDecl = DeclStore.getDecl("M" .. moduleName, "Finit")
      IF initDecl == NIL
        LOG.internal("no init() in \(moduleName)")
      ELSE
        # This recursively marks everything used from the init() method as used.
        jsGen.setDeclUsed(initDecl)
      }

      # Produce the JS file.
      Output.Group jsOutputs = NEW()
      SContext newCtx = NEW(usedFile.scope(), jsGen, jsOutputs)
      Generate.write(usedFile, newCtx, jsOutputs,
                                               ctx.scope.importIndent .. "  ")

      # Write JSoutputs to ZUDIR/ModuleName.html
      jsGen.writeZwtImport(usedFile, newCtx, jsOutputs)
    }

    FUNC createJsGen() WriteJS
      WriteJS jsGen = NEW()

      # Dependencies may have been added to Declarations used in
      # addDependsOnCond() while the declaration was not used.  We do not want
      # to use them here.
      Declaration.abstractClass.clearDependsOn()
      Declaration.inheritMethod.clearDependsOn()
      Declaration.jsCode.clearDependsOn()

      # We do want to write a declaration for abstract classes.
      jsGen.setDeclUsed(Declaration.abstractClass)

      # A method is written in the parent class, not the child.
      jsGen.setDeclUsed(Declaration.inheritMethod)

      jsGen.setDeclUsed(Declaration.jsCode)

      # Let the language add dependencies between symbols and mark items as
      # used that are always used.
      jsGen.addDependencies()

      RETURN jsGen
    }

    FUNC createJavaGen() WriteJava
      WriteJava javaGen = NEW()

      # Dependencies may have been added to Declarations used in
      # addDependsOnCond() while the declaration was not used.  We do not want
      # to use them here.
      Declaration.abstractClass.clearDependsOn()
      Declaration.inheritMethod.clearDependsOn()
      Declaration.javaCode.clearDependsOn()

      # We do want to write a declaration for abstract classes.
      javaGen.setDeclUsed(Declaration.abstractClass)

      # A method is written in the parent class, not the child.
      javaGen.setDeclUsed(Declaration.inheritMethod)

      javaGen.setDeclUsed(Declaration.javaCode)

      # Let the language add dependencies between symbols and mark items as
      # used that are always used.
      javaGen.addDependencies()

      RETURN javaGen
    }

    GENERATE_IF !Z.have("portable")
      pipe<bool> %gcPipe
      GcThread   %gcThread

      CLASS GcThread EXTENDS thread
        PROC $body() @replace
          WHILE TRUE
            status st
            bool doIt = %gcPipe.read(&st)
            IF st == FAIL
              BREAK
            }
            GC.run()
          }
        }
      }
    }

  }
}
