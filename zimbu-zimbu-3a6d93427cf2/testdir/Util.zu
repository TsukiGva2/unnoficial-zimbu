# Test Utils
#
# Copyright 2013 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

MODULE Util @public

  PROC test() @public
    IO.print("testdir/Util.zu")

    IO.print(fixOrder("[\"9\": [4, \"four\"], \"8\": 8, \"7\": [recursive-list]]"))
  }

  # Strip the line number from an exception:
  # "line 234 col 5" ->  "line col 5".
  # Also remove the full path from a file name.
  FUNC stripLine(string origMsg) string @public
    string msg = origMsg
    int lineIdx = msg.find("line ")
    int colIdx = msg.find("col ")
    IF lineIdx > 0 && colIdx > 0
      msg = msg.sliceWrap(0, lineIdx + 4) .. msg.sliceWrap(colIdx)
    }
    
    int libIdx = msg.find("/lib/")
    IF libIdx > 0
      msg = msg.sliceWrap(libIdx + 1)
    }

    RETURN msg
  }

  # If |s| is the result of dyn.ToString() this sorts the dict items, so that
  # the order does not depend on the implementation.
  FUNC fixOrder(string s) string @public
    int startIdx = s.find('[')
    string body
    int endIdx
    body, endIdx = fixBox(s, startIdx + 1)

    string lead = s.sliceWrap(0, startIdx)
    string tail = s.sliceWrap(endIdx)
    RETURN lead .. body .. tail
  }

  # Handle one list or dict.  |startIdx| is just after the '['.
  # Return the body of the list/dict and the index of the ']'.
  FUNC fixBox(string s, int startIdx) string, int
    int commaIdx = s.find(',', startIdx)
    int colonIdx = s.find(':', startIdx)
    string res
    int idx
    IF colonIdx > 0 && colonIdx < commaIdx
      res, idx = fixDict(s, startIdx)
    ELSE
      res, idx = fixList(s, startIdx)
    }
    RETURN res, idx
  }

  FUNC fixList(string s, int startIdx) string, int
    string result = ""
    int idx = startIdx
    WHILE TRUE
      int openIdx = s.find('[', idx)
      int endIdx = s.find(']', idx)
      IF endIdx < 0
        # Missing ']'
        RETURN "Missing ]", s.Size()
      }
      IF openIdx >= 0 && openIdx < endIdx
        # found item that is a list or dict
        result ..= s.sliceWrap(idx, openIdx)
        string item
        item, endIdx = fixBox(s, openIdx + 1)
        result ..= item .. "]"
        idx = endIdx + 1
      ELSE
        # found end of the list
        result ..= s.sliceWrap(idx, endIdx - 1)
        idx = endIdx
        BREAK
      }
    }
    RETURN result, idx
  }

  FUNC fixDict(string s, int startIdx) string, int
    list<string> parts = []
    int idx = startIdx
    WHILE TRUE
      int commaIdx = s.find(',', idx)
      int openIdx = s.find('[', idx)
      int endIdx = s.find(']', idx)
      IF endIdx < 0
        # Missing ']'
        RETURN "Missing ]", s.Size()
      }
      IF openIdx > 0 && openIdx < commaIdx && openIdx < endIdx
        # found key: [value that is a list or dict]
        string item
        item, endIdx = fixBox(s, openIdx + 1)
        parts.add(s.sliceWrap(idx, openIdx) .. item .. "]")
        IF s[endIdx + 1] != ','
          idx = endIdx + 1
          BREAK
        }
        idx = endIdx + 3
      ELSEIF commaIdx > 0 && commaIdx < endIdx
        parts.add(s.sliceWrap(idx, commaIdx - 1))
        idx = commaIdx + 2
      ELSE
        parts.add(s.sliceWrap(idx, endIdx - 1))
        idx = endIdx
        BREAK
      }
    }

    RETURN parts.sort().join(", "), idx
  }

}
