
# The Zimbu compiler written in Zimbu
#
# Tests for the FOR command
#
#*license
#* Copyright 2016 Bram Moolenaar  All Rights Reserved.
#*
#* Licensed under the Apache License, Version 2.0.  See the LICENSE file or
#* obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

FUNC test_for_over_NIL() status
  list<int> l
  FOR i IN l
    TEST.fail("should not loop over NIL")
  }

  string s
  FOR c IN s
    TEST.fail("should not loop over NIL")
  }

  RETURN OK
}

CLASS Foo<Titem> IMPLEMENTS I.Iterable<Titem>
  list<Titem> $items = NEW()

  PROC $add(Titem item)
    $items.add(item)
  }

  FUNC $Iterator() I.Iterator<Titem>
    RETURN FooIterator<Titem>.NEW($items)
  }
}

CLASS FooIterator<Titem> IMPLEMENTS I.Iterator<Titem>
  list<Titem> $items
  int         $pos
  bool        $canRemove

  NEW(list<Titem> items)
    $items = items
  }

  FUNC $hasNext() bool
    RETURN $pos < $items.Size()
  }

  FUNC $next() Titem
    Titem item = $peek()
    ++$pos
    $canRemove = TRUE
    RETURN item
  }

  FUNC $peekSupported() bool
    RETURN TRUE
  }

  FUNC $peek() Titem
    IF $pos >= $items.Size()
      THROW E.OutOfRange.NEW("Calling next() while there is no next item")
    }
    RETURN $items.get($pos)
  }

  FUNC $removeSupported() bool
    RETURN TRUE
  }

  FUNC $remove() status
    IF !$canRemove
      THROW E.OutOfRange.NEW("Calling remove() not after next()")
    }
    IF $pos > $items.Size()
      THROW E.OutOfRange.NEW("Calling remove() past the end")
    }
    $items.clear($pos - 1)
    $canRemove = FALSE
    RETURN OK
  }
}

FUNC test_iterator() status
  Foo<int> foos = NEW()
  foos.add(1)
  foos.add(2)
  foos.add(3)

  int count = 1
  FOR item IN foos
    TEST.equal(count, item)
    ++count
  }
  count = 1
  FOR item IN foos.Iterator()
    TEST.equal(count, item)
    ++count
  }
  count = 1
  FooIterator<int> it = foos.Iterator()
  WHILE it.hasNext()
    TEST.equal(count, it.next())
    ++count
  }

  # Check the generic type works.
  I.Iterator<int> it2 = foos.Iterator()

  # New iterator starts all over.
  it = foos.Iterator()
  TEST.equal(1, it.next())
  TEST.equal(2, it.peek())
  TEST.equal(2, it.next())
  TEST.equal(3, it.peek())
  TEST.equal(3, it.peek())
 
  RETURN OK
}

FUNC test_two_iterators() status
  Foo<int> foo1 = NEW()
  foo1.add(1)
  foo1.add(2)
  Foo<string> foo2 = NEW()
  foo2.add("a")
  foo2.add("b")
  foo2.add("c")  # not used
  int count
  FOR v1, v2 IN foo1, foo2
    IF count == 0
      TEST.equal(1, v1)
      TEST.equal("a", v2)
    ELSEIF count == 1
      TEST.equal(2, v1)
      TEST.equal("b", v2)
    ELSE
      TEST.fail("did not expect a third round")
    }
    ++count
  }
  RETURN OK
}

CLASS Container IMPLEMENTS I.Iterable<string>
  list<string> $s = ["Cone", "Ctwo", "Cthree"]

  FUNC $Iterator() I.Iterator<string> @public
    RETURN ContIterator.NEW($s)
  }

  FUNC $KeyIterator() I.KeyIterator<int, string> @public
    RETURN ContKeyIterator.NEW($s)
  }
}

CLASS ContIterator IMPLEMENTS I.Iterator<string>
  list<string> $items
  int          $pos
  bool         $canRemove

  NEW(list<string> items)
    $items = items
  }

  FUNC $hasNext() bool
    RETURN $pos < $items.Size()
  }

  FUNC $next() string
    string item = $items.get($pos)
    ++$pos
    RETURN item
  }

  FUNC $peekSupported() bool
    RETURN FALSE
  }

  FUNC $peek() string
    RETURN NIL
  }
}

CLASS ContKeyIterator IMPLEMENTS I.KeyIterator<int, string>
  list<string> $items
  int          $pos
  bool         $canRemove

  NEW(list<string> items)
    $items = items
  }

  FUNC $hasNext() bool
    RETURN $pos < $items.Size()
  }

  FUNC $next() int, string
    string item = $items.get($pos)
    ++$pos
    RETURN $pos - 1, item
  }

  FUNC $peekSupported() bool
    RETURN FALSE
  }

  FUNC $peek() int, string
    RETURN 0, NIL
  }
}

FUNC test_for_iterator() status
  Container ct = NEW()
  int count
  list<string> exp = ["Cone", "Ctwo", "Cthree"]
  FOR s IN ct
    TEST.equal(exp[count++], s)
  }
  count = 0
  FOR i, s IN ct
    TEST.equal(count, i)
    TEST.equal(exp[count++], s)
  }

  RETURN OK
}

FUNC test_for_iterator_nil() status
  Container ct
  FOR s IN ct
    TEST.fail("should not loop over NIL")
  }
  FOR i, s IN ct
    TEST.fail("should not loop over NIL")
  }

  Foo<int> foo1
  Foo<string> foo2
  FOR a, b IN foo1, foo2
    TEST.fail("should not loop over NIL")
  }
  foo1 = NEW()
  foo1.add(1)
  FOR a, b IN foo1, foo2
    TEST.fail("should not loop over NIL")
  }
  foo1 = NIL
  foo2 = NEW()
  foo2.add("a")
  FOR a, b IN foo1, foo2
    TEST.fail("should not loop over NIL")
  }

  RETURN OK
}
