#
# Part of Zudocu.
#
# Copyright 2015 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT.PROTO ../parser/zui.proto
IMPORT.ZUT DocPage.zut

IMPORT Parent.zu

MODULE Util @items=public

  # Return a string for an expression that can be a member list.
  # Returns text, not HTML.
  FUNC getDotName(Zui.Expression expr, Parent parent) string
    SWITCH expr.getType()
      CASE Zui.ExprType.eID
        RETURN expr.getName()
      CASE Zui.ExprType.eMEMBER
        RETURN getDotName(expr.getLeft(), parent)
                                 .. "." .. getDotName(expr.getRight(), parent)
      CASE Zui.ExprType.eTYPESPEC
        RETURN getDotName(expr.getLeft(), parent)
                    .. getTypeSpecText(expr.getTypespecList(), parent)
    }
    RETURN "unknown"
  }

  # Return the list of argument names.
  FUNC getArgumentNames(list<Zui.Declaration> arguments) string
    string ret = ""
    string comma = ""
    FOR arg IN arguments ?: []
      ret ..= comma
      ret ..= arg.getName()
      comma = ", "
    }
    RETURN ret
  }

  FUNC getTypeSpecText(list<Zui.Id> types) string
    string ret = ""
    string comma = ""
    FOR id IN types
      ret ..= comma .. id.getName()
      comma = ", "
    }
    RETURN "<" .. ret .. ">"
  }

  # Return a string for a type name.
  # |parent| is the item one level higher.  E.g. when defining a method in a
  # CLASS inside a MODULE it's the MODULE.  Types are assumed to be defined at
  # the MODULE level.
  # |thisClass| is the class we are currently in, and it points to its parents.
  # Used to lookup types defined in a template.
  #
  # Return text, not HTML.
  FUNC getTypeNameText(Zui.Type type, Parent parent, Parent thisClass) string
    RETURN getTypeListText([type], parent, thisClass, FALSE, FALSE)
  }

  # Like getTypeNameText() but wrap it in HTML stuff and return HTML.
  FUNC getTypeNameHtml(Zui.Type type, Parent parent, Parent thisClass) ZUT.Html
    RETURN DocPage.typeSpan(getTypeListHtml([type], parent, thisClass,
                                                                FALSE, FALSE))
  }

  FUNC getTypeSpecText(list<Zui.Type> types, Parent parent) string
    RETURN "<" .. getTypeListText(types, parent, NIL, FALSE, FALSE) .. ">"
  }

  # When |addType| is TRUE add type names to the |thisClass|.
  # Return text, not HTML.
  FUNC getTypeListText(list<Zui.Type> typeList, Parent parent,
                           Parent thisClass, bool addType, bool isFunc) string
    string res = ""
    string comma = ""
    FOR i IN 0 UNTIL typeList.Size()
      VAR type = typeList[i]
      IF isFunc && i == typeList.Size() - 1
        IF comma == ""
          res ..= " => "
        ELSE
          comma = " => "
        }
      }
      string item = getTypeRecurseText(type, parent, thisClass, addType)
      res ..= comma .. item
      comma = ", "
    }
    RETURN res
  }

  # When |addType| is TRUE add type names to the |thisClass|.
  # Wrap the type in HTML stuff and return HTML,
  FUNC getTypeListHtml(list<Zui.Type> typeList, Parent parent,
                         Parent thisClass, bool addType, bool isFunc) ZUT.Html
    ZUT.Html html = NEW()
    string comma = ""
    FOR i IN 0 UNTIL typeList.Size()
      VAR type = typeList[i]
      IF isFunc && i == typeList.Size() - 1
        IF comma == ""
          html.add(" => ")
        ELSE
          comma = " => "
        }
      }
      html.add(comma)
      ZUT.Html item = getTypeRecurseHtml(type, parent, thisClass, addType)
      html.add(wrapTypeRef(item, thisClass))
      comma = ", "
    }
    RETURN html
  }

  # When |addType| is TRUE add type names to the |thisClass|.
  # Return text, not HTML.
  FUNC getTypeRecurseText(Zui.Type type, Parent parent, Parent thisClass,
                                                          bool addType) string
    IF type == NIL
      RETURN "nil"
    }

    string ret = ""
    IF type.getType() == Zui.TypeEnum.eNAME
      ret ..= getTypeFromExprText(type.getName(), parent, thisClass, addType)
    ELSEIF type.getType() == Zui.TypeEnum.eREF
      ret ..= getTypeRecurseText(type.getRef(), parent, thisClass, addType)
      ret ..= " &"
    ELSE
      IO.print("Type not supported: " .. type.getType().ToString())
      ret ..= "unknown"
    }

    RETURN ret
  }

  # When |addType| is TRUE add type names to the |thisClass|.
  # Wrap it in HTML stuff and return HTML,
  FUNC getTypeRecurseHtml(Zui.Type type, Parent parent, Parent thisClass,
                                                        bool addType) ZUT.Html
    ZUT.Html html = NEW()
    IF type == NIL
      html.add("nil")
      RETURN html
    }

    IF type.getType() == Zui.TypeEnum.eNAME
      html.add(getTypeFromExprHtml(type.getName(), parent, thisClass, addType))
    ELSEIF type.getType() == Zui.TypeEnum.eREF
      html.add(getTypeRecurseHtml(type.getRef(), parent, thisClass, addType))
      html.add(" &")
    ELSE
      IO.print("Type not supported: " .. type.getType().ToString())
      html.add("unknown")
    }

    RETURN html
  }

  # When |addType| is TRUE add type names to the |thisClass|.
  # Return text, not HTML.
  FUNC getTypeFromExprText(Zui.Expression expr, Parent parent,
                                        Parent thisClass, bool addType) string
    string ret = ""
    IF expr.getType() == Zui.ExprType.eID
      string name = expr.getName()
      IF addType
        # Inside a template of a class: add type names to the class
        ret ..= name
        thisClass.addType(name)
      ELSEIF parent != NIL && useParentName(name, thisClass)
        # Special case: prepend parent name to class name.
        # This is very simplistic, but it appears to work for the libraries.
        ret ..= parent.fullName .. "." .. name
      ELSE
        ret ..= name
      }
    ELSEIF expr.getType() == Zui.ExprType.eTHIS
      ret ..= "THIS"
    ELSEIF expr.getType() == Zui.ExprType.eMEMBER
      ret ..= getTypeFromExprText(expr.getLeft(), parent, thisClass, addType)
      ret ..= "."
      ret ..= getTypeFromExprText(expr.getRight(), NIL, thisClass, addType)
    ELSEIF expr.getType() == Zui.ExprType.eSUBSCRIPT
      ret ..= getTypeFromExprText(expr.getLeft(), parent, thisClass, addType)
      ret ..= "["
      ret ..= getTypeFromExprText(expr.getRight(), parent, thisClass, addType)
      ret ..= "]"
    ELSEIF expr.getType() == Zui.ExprType.eTYPESPEC
      string specName
      bool isType
      IF expr.getLeft().getType() == Zui.ExprType.eID
        specName = expr.getLeft().getName()
        isType = ["func", "proc", "callback"].has(specName)
      }

      # Don't pass parent to avoid SET.Set instead of Set.
      ret ..= getTypeFromExprText(expr.getLeft(), NIL, thisClass, addType)
      ret ..= "<"
      ret ..= getTypeListText(expr.getTypespecList(), parent, thisClass,
                                                  addType, specName == "func")
      ret ..= ">"
    ELSEIF expr.getType() == Zui.ExprType.eCTYPE
      ret ..= "C(" .. expr.getName() .. ")"
    ELSE
      IO.print("ExprType not supported: " .. expr.getType().ToString())
      ret ..= "unknown"
    }
    RETURN ret
  }
   
  # When |addType| is TRUE add type names to the |thisClass|.
  # Wrap it in HTML stuff and return HTML,
  FUNC getTypeFromExprHtml(Zui.Expression expr, Parent parent,
                                      Parent thisClass, bool addType) ZUT.Html
    ZUT.Html html = NEW()
    IF expr.getType() == Zui.ExprType.eID
      string name = expr.getName()
      IF addType
        # Inside a template of a class: add type names to the class
        html.add(name)
        thisClass.addType(name)
      ELSEIF parent != NIL && useParentName(name, thisClass)
        # Special case: prepend parent name to class name.
        # This is very simplistic, but it appears to work for the libraries.
        html.add(parent.fullName .. "." .. name)
      ELSEIF knownTypes.has(name)
        html.add(knownTypes[name])
      ELSE
        html.add(name)
      }
    ELSEIF expr.getType() == Zui.ExprType.eTHIS
      html.add("THIS")
    ELSEIF expr.getType() == Zui.ExprType.eMEMBER
      html.add(getTypeFromExprHtml(expr.getLeft(), parent, thisClass, addType))
      html.add(".")
      html.add(getTypeFromExprHtml(expr.getRight(), NIL, thisClass, addType))
    ELSEIF expr.getType() == Zui.ExprType.eSUBSCRIPT
      html.add(getTypeFromExprHtml(expr.getLeft(), parent, thisClass, addType))
      html.add("[")
      html.add(getTypeFromExprHtml(expr.getRight(), parent, thisClass, addType))
      html.add("]")
    ELSEIF expr.getType() == Zui.ExprType.eTYPESPEC
      string specName
      bool isType
      IF expr.getLeft().getType() == Zui.ExprType.eID
        specName = expr.getLeft().getName()
        isType = ["func", "proc", "callback"].has(specName)
      }

      # Don't pass parent to avoid SET.Set instead of Set.
      ZUT.Html left = getTypeFromExprHtml(expr.getLeft(), NIL,
                                                           thisClass, addType)
      IF isType
        html.add(DocPage.typeSpan(left))
      ELSE
        html.add(left)
      }

      html.add("<")
      html.add(getTypeListHtml(expr.getTypespecList(), parent, thisClass,
                                                 addType, specName == "func"))
      html.add(">")
    ELSEIF expr.getType() == Zui.ExprType.eCTYPE
      html.add("C(" .. expr.getName() .. ")")
    ELSE
      IO.print("ExprType not supported: " .. expr.getType().ToString())
      html.add("unknown")
    }
    RETURN html
  }
   
  FUNC useParentName(string name, Parent thisClass) bool
    RETURN name.Size() >= 2
        && name[0] >= 'A' && name[0] <= 'Z'
        && name[0] != 'T'  # HACK: exclude Titem, template type
        && (name[1] < 'A' || name[1] > 'Z')
        && (thisClass == NIL || !thisClass.hasType(name))
  }

  # Wrap a type with a link when it starts with something that is a toplevel
  # item.
  FUNC wrapTypeRef(ZUT.Html type, Parent thisClass) ZUT.Html
    string typeString = type.ToString()
    IF thisClass != NIL && thisClass.hasType(typeString)
      # No link if we are already on the right page.
      RETURN type
    }

    # This is a bit of guessing: only wrap items starting with "FOO." or "Foo."
    # TODO: make this work properly.
    IF !startsWithDotname(typeString)
      RETURN type
    }
    string lead
    IF typeString.endsWith(".I")
      # Interface is defined in the page of its class.
      lead = typeString.sliceWrap(0, -3)
    ELSE
      int idx = typeString.find("&lt;")
      IF idx > 0
        # strip <type>
        lead = typeString.slice(0, idx - 1)
      ELSE
        lead = typeString
      }
    }
    RETURN DocPage.wrapType(lead, type)
  }

  # Return TRUE if |s| starts with "XXX." or "Xxx.".
  FUNC startsWithDotname(string s) bool
    IF s[0] < 'A' || s[0] > 'Z'
      RETURN FALSE
    }
    IF s == "THIS"
      RETURN FALSE
    }
    IF s == "Titem" || s == "Tkey" || s == "Tresult" 
      # generic template types, no link
      RETURN FALSE
    }
    FOR c IN s
      IF c == '.'
        BREAK
      }
      IF !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
        RETURN FALSE
      }
    }
    RETURN TRUE
  }

  dict<string, ZUT.Html> knownTypes = [
    "array": DocPage.wrapType("ARRAY.array", "array"),
    "bool": DocPage.wrapType("BOOL.bool", "bool"),
    "byteString": DocPage.wrapType("BYTESTRING.byteString", "byteString"),
    "cond": DocPage.wrapType("THREAD.Cond", "cond"),
    "dict": DocPage.wrapType("DICT.dict", "dict"),
    "dyn": DocPage.wrapType("DYN.dyn", "dyn"),
    "evalThread": DocPage.wrapType("THREAD.EvalThread", "evalThread"),
    "float": DocPage.wrapType("FLOAT.float", "float"),
    "int": DocPage.wrapType("INT.int", "int"),
    "list": DocPage.wrapType("LIST.list", "list"),
    "lock": DocPage.wrapType("THREAD.Lock", "lock"),
    "autoLock": DocPage.wrapType("THREAD.AutoLock", "autoLock"),
    "multiDict": DocPage.wrapType("MULTIDICT.MultiDict", "multiDict"),
    "multiSet": DocPage.wrapType("MULTISET.MultiSet", "multiSet"),
    "nat": DocPage.wrapType("NAT.nat", "nat"),
    "pipe": DocPage.wrapType("PIPE.Pipe", "pipe"),
    "regex": DocPage.wrapType("RE.Regex", "regex"),
    "set": DocPage.wrapType("SET.Set", "set"),
    "sortedList": DocPage.wrapType("SORTEDLIST.SortedList", "sortedList"),
    "status": DocPage.wrapType("STATUS.status", "status"),
    "string": DocPage.wrapType("STRING.string", "string"),
    "thread": DocPage.wrapType("THREAD.Thread", "thread"),
    "type": DocPage.wrapType("TYPE.type", "type"),
    "tuple": DocPage.wrapType("TUPLE.Tuple", "tuple"),
    "varByteString": DocPage.wrapType("VARBYTESTRING.varByteString", "varByteString"),
    "varString": DocPage.wrapType("VARSTRING.varString", "varString"),
  ]

  # Change known internal names into builtin type names.
  FUNC builtinTranslate(string name) string
    RETURN builtinMap.get(name, name)
  }

  dict<string, string> builtinMap = [
      "ARRAY.array": "T.array",
      "BOOL.bool": "T.bool",
      "BYTESTRING.byteString": "T.byteString",
      "THREAD.Cond": "T.cond",
      "DICT.dict": "T.dict",
      "DYN.dyn": "T.dyn",
      "THREAD.EvalThread": "T.evalThread",
      "FLOAT.float": "T.float",
      "INT.int": "T.int",
      "LIST.list": "T.list",
      "THREAD.Lock": "T.lock",
      "THREAD.AutoLock": "T.autoLock",
      "MULTIDICT.MultiDict": "T.multiDict",
      "MULTISET.MultiSet": "T.multiSet",
      "NAT.nat": "T.nat",
      "PIPE.Pipe": "T.pipe",
      "RE.Regex": "T.regex",
      "SET.Set": "T.set",
      "SORTEDLIST.SortedList": "T.sortedList",
      "STATUS.status": "T.status",
      "STRING.string": "T.string",
      "TYPE.type": "T.type",
      "THREAD.Thread": "T.thread",
      "TUPLE.Tuple": "T.tuple",
      "TYPE.Type": "T.type",
      "VARBYTESTRING.varByteString": "T.varByteString",
      "VARSTRING.varString": "T.varString",
  ]

  FUNC getVisibility(Zui.Attributes attr, Parent parent) Zui.Visibility
    Zui.Visibility vis
    IF attr.hasVisibility()
      vis = attr.getVisibility()
    }
    IF vis == Zui.Visibility.eUNSET || vis == Zui.Visibility.unknown
      IF parent == NIL
        vis = Zui.Visibility.eDIRECTORY
      ELSEIF parent.attr.hasItemsVisibility()
                  && parent.attr.getItemsVisibility() != Zui.Visibility.eUNSET
        vis = parent.attr.getItemsVisibility()
      ELSE
        vis = Zui.Visibility.eFILE
      }
    }
    RETURN vis
  }

  dict<Zui.Visibility, string> visName = [
      Zui.Visibility.ePRIVATE:   "@private",
      Zui.Visibility.ePROTECTED: "@protected",
      Zui.Visibility.ePUBLIC:    "@public",
      Zui.Visibility.eFILE:      "@file",
      Zui.Visibility.eDIRECTORY: "@directory",
      ]

}
