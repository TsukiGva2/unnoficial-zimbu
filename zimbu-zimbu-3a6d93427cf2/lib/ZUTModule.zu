#
# The Zimbu compiler written in Zimbu
#
# builtin module ZUT.
#
# Beware of browser incompabilities!
# compatibility tables: http://www.quirksmode.org/

IMPORT.ZUT zut/MainPage.zut

IMPORT zut/Dialog.zu

#= Zimbu Templates. For creating interactive web pages.
#
#*license
#* Copyright 2014 Bram Moolenaar  All Rights Reserved.
#*
#* Licensed under the Apache License, Version 2.0.  See the LICENSE file or
#* obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#
MODULE ZUTModule @public

  # Dialogs
  ALIAS Dialog.TextDialog       TextDialog @public

  #= The configuration for events handled by ZUT.
  CLASS EventConfig @public
    set<EventType> $active

    #= This constructor is only used internaly.
    NEW()
      $active = NEW()
      eventConfig = THIS
    }

    #= Add EventType |type| to the set of events that ZUT listens on.
    #- Returns FAIL for an event that is not supported.
    #
    #- It is only possible to add types, they can't be removed.
    FUNC $listen(EventType type) status @public
      GENERATE_IF Z.lang == "JS"
        IF !$active.has(type)
          $active.add(type)

          # zut.eventHandler is defined in GenJS.writeZutFooter().
          # TODO: only listen on events that are actually used.
          SWITCH type
            CASE EventType.click
>>>
              $doc.onclick = zut.clickEventHandler;
<<<
            CASE EventType.keyDown
>>>
              $doc.onkeydown = zut.keyDownEventHandler;
<<<
            CASE EventType.keyUp
>>>
              $doc.onkeyup = zut.keyUpEventHandler;
<<<
            CASE EventType.key
>>>
              $doc.onkeypress = zut.keyEventHandler;
<<<
            CASE EventType.mouseMove
>>>
              $doc.onmousemove = zut.mouseMoveEventHandler;
<<<
            CASE EventType.mouseOver
>>>
              $doc.onmouseover = zut.mouseOverEventHandler;
<<<
            CASE EventType.mouseOut
>>>
              $doc.onmouseout = zut.mouseOutEventHandler;
<<<
            CASE EventType.valueChange
>>>
              $doc.onchange = zut.valueChangeEventHandler;
<<<
            DEFAULT
              RETURN FAIL
          }
        }
      }
      RETURN OK
    }
  }

  #! Singleton EventConfig.
  EventConfig eventConfig
  
  #= The context for processing ZUT templates.
  #- Passed to all the methods generating CSS and HTML.
  CLASS Context @public
    HTTP.Context    $httpContext @public #!
    set<string>     $cssNames #!
    list<string>    $cssEntries @public #!
    set<EventType>  $activeEvents

    #= Create a new Context for a HTTP request on the server.
    NEW(HTTP.Context httpContext) @public
      $httpContext = httpContext
      NEW()
    }

    #= Create a new Context for use on the client.
    NEW() @public
      $cssEntries = NEW()
      $cssNames = NEW()
    }

    #= Return the HTTP.Context for the current request.
    #- In the client this will return NIL.
    FUNC $getHttpContext() HTTP.Context @public
      RETURN $httpContext
    }

    #! Return TRUE if CSS entry |name| was already added.
    FUNC $hasCss(string name) bool @public
      RETURN $cssNames.has(name)
    }

    #! Add CSS entry |css|, registering as |name|.
    #  When |name| is NIL the CSS entry is not registered.
    PROC $addCss(string name, Css css) @public
      $cssNames.add(name)
      GENERATE_IF Z.lang == "C"
        # Add to the list used by MainPage.
        $cssEntries.add(css.ToString())
      GENERATE_ELSE
        # Add to the page right away.
>>>
        var styleEl = $doc.createElement('style');
        styleEl.type = 'text/css';
        if (styleEl.styleSheet) {
          styleEl.styleSheet.cssText = %css.ToString()%;
        } else {
          styleEl.appendChild($doc.createTextNode(%css.ToString()%));
        }
        $doc.head.appendChild(styleEl);
<<<
      }
    }

    #! Add an event to listen on.  Passed on to the EventConfig, either right
    # away (on the client) or through the page (on the server).
    FUNC $listen(EventType eventType) status @public
      GENERATE_IF Z.lang == "C"
        IF $activeEvents == NIL
          $activeEvents = NEW()
        }
        IF !$activeEvents.has(eventType)
          $activeEvents.add(eventType)
        }
        RETURN OK
      GENERATE_ELSE
        RETURN eventConfig.listen(eventType)
      }
    }

    #! On the server, when generating the html page, add the event listeners
    # used in the encountered templates.
    FUNC $activateEventListeners() Html @public
      GENERATE_IF Z.lang == "C"
        IF $activeEvents != NIL
          Html html = NEW()
          html.addUNESCAPED("<script type=\"text/javascript\">\n")
          FOR e IN $activeEvents
            html.addUNESCAPED("zut.eventConfig.listen(")
            html.addUNESCAPED(e.value())
            html.addUNESCAPED(");\n")
          }
          html.addUNESCAPED("</script>\n")
          RETURN html
        }
      }
      RETURN Html.NEW()
    }

  }

  #= The type used for a ZUT template method producing HTML.
  #- Extra arguments are to be passed using a callback.
  #
  #- Example, creating a callback for template function HelloMessage.show():
  #% callback<ZUT.HtmlFunc, string> cb = NEW(HelloMessage.show, "Hello World!")
  ALIAS func< => Html> HtmlFunc @public

  #= The properties of an HTML page.
  CLASS Page @public @items=public
    string          $title #!
    HtmlFunc        $bodyTemplate #!
    list<string>    $pathList #!
    bool            $html5 #!
    list<string>    $cssEntries #!
    list<string>    $jsFiles #!

    #= Create a page with Title |title|.
    NEW(string title) @public
      $title = title
      $pathList = NEW()
      $jsFiles = NEW()
      $jsFiles.add("main.js")  # TODO: split up in parts
    }

    #= Set the template to call to fill the body of the page.
    #- Use a callback to pass arguments to the template, e.g.:
    #% ZUT.page page = NEW("ZUT demo page")
    #% callback<ZUT.HtmlFunc, string> cb = NEW(ZutDemoPage.page, "Hello world!")
    #% page.setBody(cb)
    PROC $setBody(HtmlFunc body) @public
      $bodyTemplate = body
    }

    #= Render the body template, passing |context| if needed.
    FUNC $renderBody() Html @public
      IF $bodyTemplate != NIL
        RETURN $bodyTemplate()
      }
      RETURN NIL
    }

    #= Set whether the page should use an HTML 5 declaration.
    PROC $setHtml5(bool html5)
      $html5 = html5
    }

    # PROC addController()

    #= Add a path for which this page should display.
    PROC $addPath(string path) @public
      $pathList.add(path)
    }

    #= Add CSS to be inserted in the page header.
    #- Note that |css| is included as-is, not processed like a template.
    PROC $addCss(string css) @public
      IF $cssEntries == NIL
        $cssEntries = NEW()
      }
      $cssEntries.add(css)
    }

    #! Return all added CSS concatenated.
    FUNC $getAllCss() string @public
      RETURN $cssEntries == NIL ? "" : $cssEntries.join("\n")
    }
  }

  #!
  list<proc<>> onLoadMethods

  #!
  bool didOnLoad

  #= Add a method to be invoked after the HTML page has loaded.
  #- If the page already loaded the method will be invoked right away.
  #
  #- To do this from a controller you can use the Init method:
  #%SHARED
  #%  FUNC Init() status
  #%    GENERATE_IF Z.lang == "JS"
  #%      ZUT.callOnLoad(onLoad)
  #%    }
  #%    RETURN OK
  #%  }
  PROC callOnLoad(proc<> method) @public
    IF didOnLoad
      method()
    ELSE
      IF onLoadMethods == NIL
        onLoadMethods = NEW()
      }
      onLoadMethods.add(method)
    }
  }

  #!
  PROC onLoad()
    didOnLoad = TRUE
    FOR method IN onLoadMethods
      method()
    }
    onLoadMethods = NIL
  }

#  GENERATE_IF Z.lang == "JS"
    #= Lowest level object, an HTML element.
    #- Only to be used in Javascript code.
    CLASS DomElement @public
    }

    #= A low level browser event.
    #- Only to be used in Javascript code.
    CLASS DomEvent @public
    }

    #= A wrapper around an HTML element.
    #- Only to be used in Javascript code.
    CLASS Element @public
      DomElement $el

      NEW(DomElement el)
        $el = el
      }

      #= Get the parent Element
      #- Returns NIL for the HTML element.
      FUNC $getParent() Element @public
        DomElement el
        GENERATE_IF Z.lang == "JS"
>>>
  %el% = %$el%.parentElement;
<<<
        }
        IF el == NIL
          RETURN NIL
        }
        RETURN NEW(el)
      }

      #= Get the list of child Elements.
      #- Returns an empty list if there are no children.
      FUNC $getChildren() list<Element> @public
        list<Element> result = []
        GENERATE_IF Z.lang == "JS"
          DomElement de
>>>
  var elms = %$el%.children;
  if (elms) {
   for (var i = 0; i < elms.length; ++i) {
    %de% = elms[i];
<<<
    result.add(NEW(de))
>>>
   }
  }
<<<
        }
        RETURN result
      }

      #= Get the value of the DOM element.
      FUNC $getValue() string @public
        string s
        GENERATE_IF Z.lang == "JS"
>>>
  %s% = %$el%.value;
<<<
        }
        RETURN s
      }

      #= Set the value of the DOM element.
      # TODO: escaping?
      PROC $setValue(string text) @public
        GENERATE_IF Z.lang == "JS"
>>>
  %$el%.value = %text%;
<<<
        }
      }

      #= Get the text content of the DOM element.
      FUNC $getText() string @public
        string s
        GENERATE_IF Z.lang == "JS"
>>>
  %s% = %$el%.textContent;
<<<
        }
        RETURN s
      }

      #= Set the text content of the DOM element.
      # TODO: escaping?
      PROC $setText(string text) @public
        GENERATE_IF Z.lang == "JS"
>>>
  %$el%.textContent = %text%;
<<<
        }
      }

      #= Return the value of attribute |name| of DOM element.
      #- Returns an empty string when the attribute does not exist.
      #
      #- Can only be used in the client.
      FUNC $getAttribute(string name) string @public
        string value
        GENERATE_IF Z.lang == "JS"
>>>
  %value% = %$el%.getAttribute(%name%);
<<<
        }
        RETURN value
      }

      #= Set the value of attribute |name| of DOM element to |value|.
      #- Returns the Element.
      #
      #- Can only be used in the client.
      FUNC $setAttribute(string name, string value) Element @public
        GENERATE_IF Z.lang == "JS"
>>>
  %value% = %$el%.setAttribute(%name%, %value%);
<<<
        }
        RETURN THIS
      }

      #= Return the class attribute value of the DOM element.
      #- Returns an empty string when the attribute does not exist.
      #
      #- Can only be used in the client.
      FUNC $getClasses() string @public
        string value
        GENERATE_IF Z.lang == "JS"
>>>
  %value% = %$el%.className || '';
<<<
        }
        RETURN value
      }

      #= Sets the class attribute value of the DOM element to |classes|.
      #- |classes| must be a space saparated list of class names.
      #
      #- Can only be used in the client.
      PROC $setClasses(string classes) @public
        GENERATE_IF Z.lang == "JS"
>>>
  %$el%.className = %classes%;
<<<
        }
      }

      #= Returns TRUE if the class property of the Element contains |class|.
      #- Can only be used in the client.
      FUNC $hasClass(string class) bool @public
        GENERATE_IF Z.lang == "JS"
          string oldVal
>>>
  %oldVal% = %$el%.className || '';
<<<
          RETURN oldVal.split().has(class)
        GENERATE_ELSE
          RETURN FALSE
        }
      }

      #= Add |class| to the class property, if it wasn't there yet.
      #- Can only be used in the client.
      PROC $addClass(string class) @public
        GENERATE_IF Z.lang == "JS"
          string oldVal
>>>
  %oldVal% = %$el%.className || '';
<<<
          list<string> classes = oldVal.split()
          IF !classes.has(class)
            string newVal = oldVal == "" ? class : oldVal .. " " .. class
>>>
  %$el%.className = %newVal%;
<<<
          }
        }
      }

      #= Remove |class| from the class property, if it wa there.
      #- Can only be used in the client.
      PROC $removeClass(string class) @public
        GENERATE_IF Z.lang == "JS"
          string oldVal
>>>
  %oldVal% = %$el%.className || '';
<<<
          list<string> classes = oldVal.split()
          int idx = classes.find(class)
          IF idx >= 0
            string newVal = classes.slice(0, idx - 1).join()
                                              .. classes.slice(idx + 1).join()
>>>
  %$el%.className = %newVal%;
<<<
          }
        }
      }

      #= Set the display attribute.
      #- When |display| is TRUE then style.display is made empty.
      #- When |display| is FALSE then style.display is set to "none".
      #
      #- Can only be used in the client.
      PROC $setDisplay(bool display) @public
        GENERATE_IF Z.lang == "JS"
          string value = display ? "" : "none"
>>>
          %$el%.style.display = %value%;
<<<
        }
      }

      #= Set the disabled attribute of a button.
      #- When |disabled| is TRUE then the button will be disabled.
      #- When |disabled| is FALSE then the button will be enabled.
      #
      #- Can only be used in the client.
      PROC $setDisabled(bool disabled) @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.disabled = %disabled%;
<<<
        }
      }

      #= Set style attribute |name| to string |value|.
      #- Can only be used in the client.
      PROC $setStyle(string name, string value) @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.style[%name%] = %value%;
<<<
        }
      }

      #= Set style attribute |name| to number |value|.
      #- Can only be used in the client.
      PROC $setStyle(string name, int value) @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.style[%name%] = %value%;
<<<
        }
      }

      #= Set the background-color style attribute to the |r|, |g| and |b|
      #= values.
      #- Can only be used in the client.
      PROC $setBackgroundColor(int r, int g, int b) @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.style['background-color'] = 'rgb(' + %r% + ',' + %g% + ',' + %b% + ')';
<<<
        }
      }

      #= Return the width of this Element.
      #- Only works when it is visible.
      FUNC $getWidth() int @default @public
        int r
        GENERATE_IF Z.lang == "JS"
>>>
          %r% = %$el%.offsetWidth;
<<<
        }
        RETURN r
      }

      #= Return the height of this Element.
      #- Only works when it is visible.
      FUNC $getHeight() int @default @public
        int r
        GENERATE_IF Z.lang == "JS"
>>>
          %r% = %$el%.offsetHeight;
<<<
        }
        RETURN r
      }

      #= Return the vertical position of this Element in the page
      FUNC $getTop() int @public
        RETURN $getTop(NIL)
      }

      #= Return the vertical position of this Element within |container|
      #- If the Element is not inside |container| return -1.
      #- If |container| is NIL this works like getTop().
      FUNC $getTop(Element container) int @public
        int r
        GENERATE_IF Z.lang == "JS"
>>>
          var item = %$el%;
          while (item && item != %container.el%) {
            %r% += item.offsetTop;
            item = item.offsetParent;
          }
          if (%container% && !item) {
            return -1;
          }
<<<
        }
        RETURN r
      }

      #= Return the horizontal position of this Element in the page
      FUNC $getLeft() int @public
        RETURN $getLeft(NIL)
      }

      #= Return the horizontal position of this Element within |container|
      #- If the Element is not inside |container| return -1.
      #- If |container| is NIL this works like getLeft().
      FUNC $getLeft(Element container) int @public
        int r
        GENERATE_IF Z.lang == "JS"
>>>
          var item = %$el%;
          while (item && item != %container.el%) {
            %r% += item.offsetLeft;
            item = item.offsetParent;
          }
          if (%container% && !item) {
            return -1;
          }
<<<
        }
        RETURN r
      }

      #= Get the current horizontal scroll position in pixels.
      #- Zero means that the left side is visible.
      FUNC $getHorizontalScroll() int @public
        int r
        GENERATE_IF Z.lang == "JS"
>>>
          %r% = %$el%.scrollLeft;
<<<
        }
        RETURN r
      }

      #= Set the horizontal scroll position to |pixels|.
      #- Use zero to scroll to the far left.
      #
      #- Can only be used in the client.
      PROC $setHorizontalScroll(int pixels) @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.scrollLeft = %pixels%;
<<<
        }
      }

      #= Scroll horizontally to the far left.
      PROC $scrollLeft() @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.scrollLeft = 0;
<<<
        }
      }

      #= Scroll horizontally to the far right.
      PROC $scrollRight() @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.scrollLeft = %$el%.scrollWidth;
<<<
        }
      }

      #= Get the current vertical scroll position in pixels.
      #- Zero means the top is visible.
      #
      #- Can only be used in the client.
      FUNC $getVerticalScroll() int @public
        int r
        GENERATE_IF Z.lang == "JS"
>>>
          %r% = %$el%.scrollTop;
<<<
        }
        RETURN r
      }

      #= Set the vertical scroll position to |pixels|.
      #- Use zero to scroll to the top.
      #
      #- Can only be used in the client.
      PROC $setVerticalScroll(int pixels) @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.scrollTop = %pixels%;
<<<
        }
      }

      #= Scroll vertically to the top.
      #- Can only be used in the client.
      PROC $scrollTop() @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.scrollTop = 0;
<<<
        }
      }

      #= Scroll vertically to the bottom.
      #- Can only be used in the client.
      PROC $scrollBottom() @public
        GENERATE_IF Z.lang == "JS"
>>>
          %$el%.scrollTop = %$el%.scrollHeight;
<<<
        }
      }

      #= Ensure that |element| is visible by scrolling horizontally and/or
      #= vertically.
      #- If possible, |element| is centered in the viewable space.
      #
      #- |element| must be a child if this element.
      #
      #- Can only be used in the client.
      PROC $ensureVisible(Element element) @public
        $ensureVisibleVertical(element)
        $ensureVisibleHorizontal(element)
      }

      #= Ensure that |element| is visible by scrolling vertically only.
      #- If possible, |element| is centered in the viewable space vertically.
      #
      #- |element| must be a child if this element.
      #
      #- Can only be used in the client.
      PROC $ensureVisibleVertical(Element element) @public
        GENERATE_IF Z.lang == "JS"
          int top = element.getTop(THIS)
          # Center the item.
>>>
          var s = %$el%.clientHeight - %element.el%.offsetHeight;
          s = s < 0 ? 0 : s / 2;
          %$el%.scrollTop = %top% - s;
<<<
        }
      }

      #= Ensure that |element| is visible by scrolling horizontally only.
      #- If possible, |element| is centered in the viewable space horizontally.
      #
      #- |element| must be a child if this element.
      #
      #- Can only be used in the client.
      PROC $ensureVisibleHorizontal(Element element) @public
        GENERATE_IF Z.lang == "JS"
          int left = element.getLeft(THIS)
          # Center the item.
>>>
          var s = %$el%.clientWidth - %element.el%.offsetWidth;
          s = s < 0 ? 0 : s / 2;
          %$el%.scrollLeft = %left% - s;
<<<
        }
      }

      #= Fire an event on the element.
      #- Can only be used in the client.
      PROC $fireEvent(EventType type, int key = 0) @public
        GENERATE_IF Z.lang == "JS"
          IF type == EventType.keyUp
>>>
            if (document.createEvent) {
              var e = document.createEvent("HTMLEvents");
              e.initEvent("keyup", true, true);
              e.eventName = "keyup";
              %$el%.dispatchEvent(e);
            } else {
              var e = document.createEventObject("KeyboardEvent");
              e.keyCode = %key%;
              %$el%.fireEvent("onkeyup", e);
            }
<<<
          ELSE
            # TODO: more event types
            THROW "Event type not yet supported: " .. type.ToString()
          }
        }
      }

      #= Add a listener to the Element.
      #- Can only be used in the client.
      PROC $addListener(I_Listener listener)
        GENERATE_IF Z.lang == "JS"
          list<I_Listener> listeners
>>>
          %listeners% = %$el%.zlisteners;
<<<
          IF listeners == NIL
            listeners = NEW()
          }
          listeners.add(listener)
>>>
          %$el%.zlisteners = %listeners%;
<<<
        }
      }

      #= Return TRUE if this element has any listeners.
      #- Can only be used in the client.
      FUNC $hasListener() bool
        GENERATE_IF Z.lang == "JS"
          list<I_Listener> listeners
>>>
          %listeners% = %$el%.zlisteners;
<<<
          RETURN listeners.Size() > 0
        }
        RETURN FALSE
      }

      #= Trigger all listeners, passing |info|.
      #- Can only be used in the client.
      PROC $triggerListeners(dyn info)
        GENERATE_IF Z.lang == "JS"
          list<I_Listener> listeners
>>>
          %listeners% = %$el%.zlisteners;
<<<
          FOR listener IN listeners
            listener.trigger(info)
          }
        }
      }

      #= Fill the element with the result of |template|.
      #- Can only be used in the client.
      PROC $fill(HtmlFunc template) @public
        GENERATE_IF Z.lang == "JS"
          string html = template(C(zut.context)).ToString()
>>>
    %$el%.innerHTML = %html%;
<<<
        }
      }

      #= Remove this element from the DOM.
      #- Can only be used in the client.
      PROC $removeFromDom() @public
        GENERATE_IF Z.lang == "JS"
>>>
         %$el%.parentNode.removeChild(%$el%);
<<<
        }
      }

    }
#  }

  #= Finds element |id|.
  #- Returns NIL if the element is not found.
  FUNC getElementById(string id) Element @public
    DomElement e
    GENERATE_IF Z.lang == "JS"
>>>
  %e% = $doc.getElementById(%id%);
<<<
    }
    IF e == NIL
      RETURN NIL
    }
    RETURN NEW(e)
  }

  #= Append |html| to the DOM.
  #- If "stdout" was written to |html| will be put before it.
  #
  #- If |blockStyle| is not NIL the template output will be wrapped in a div
  #- with "display" set to |blockStyle|.
  #
  #- Can only be used in the client.
  #
  #- If |blockStyle| is NIL returns the first appended element.  If nothing
  #- was appended then NIL is returned.
  #
  #- If |blockStyle| is not NIL returns the Element of the appended div.
  FUNC appendToDom(ZUT.Html html, string blockStyle = NIL) Element @public
    GENERATE_IF Z.lang == "JS"
      DomElement e
>>>
  %e% = document.createElement('div');
  %e%.innerHTML = %html.ToString()%;
  if (%blockStyle%) %e%.style.display = %blockStyle%;
  var el = $doc.getElementById("stdout");
  if (el) {
    $doc.body.insertBefore(%e%, el);
  } else {
    $doc.body.appendChild(%e%);
  }
  if (!%blockStyle%) {
    var ret = %e%.firstChild;
    while (%e%.firstChild) {
      var c = %e%.removeChild(%e%.firstChild);
      $doc.body.insertBefore(c, %e%);
    }
    $doc.body.removeChild(%e%);
    %e% = ret;
  }
<<<
      RETURN e == NIL ? NIL : NEW(e)
    GENERATE_ELSE
      RETURN NIL
    }
  }
  #= Append the result of |template| to the DOM.
  #- If "stdout" was written to it will be put before it.
  #
  #- If |blockStyle| is not NIL the template output will be wrapped in a div
  #- with "display" set to |blockStyle|.
  #
  #- Can only be used in the client.
  #
  #- If |blockStyle| is NIL returns the first appended element.  If nothing
  #- was appended then NIL is returned.
  #
  #- If |blockStyle| is not NIL returns the Element of the appended div.
  FUNC appendToDom(HtmlFunc template, string blockStyle = NIL) Element @public
    GENERATE_IF Z.lang == "JS"
      RETURN appendToDom(template(C(zut.context)))
    GENERATE_ELSE
      RETURN NIL
    }
  }

  #= Add a CSS style element to the document.
  #- When |name| is not NIL, the CSS will only be added when CSS with this
  #- name was not added before.  The CSS blocks in templates use the file name
  #- here.
  #
  #- On the server the style will be added to the list of styles for the page.
  #- On the client the style will be added as a separate style element right
  #- away.
  PROC addCss(string name, Css css) @public
    Context context = CTX.get(Context.Type())
    CHECK.notNil(context, "Not in a ZUT context")
    IF name == NIL || !context.hasCss(name)
      context.addCss(name, css)
    }
  }

  ENUM EventType @public
    click          #= single mouse click or touch tap (triggers when the mouse
                   #= button is released)
    doubleClick    #= double mouse click or touch tap twice
    longClick      #= long mouse click or touch & hold (ca. 2 seconds)
    mouseDown      #= pressing the mouse button
    mouseUp        #= releasing the mouse button

    mouseMove      #= moving the mouse inside an element (no touch equivalent)
    mouseOver      #= when the mouse enters an element (no touch equivalent)
    mouseOut       #= when the mouse leaves an element (no touch equivalent)

    key            #= keyboard key typed (not for modifier keys)
    keyDown        #= keyboard key down (also for modifier keys)
    keyUp          #= keyboard key release (also for modifier keys)

    valueChange    #= element value changed
  }

  #= All controllers should inherite from this.
  CLASS Controller @public
  }

  #= The properties of an event.
  CLASS Event @public @items=public
    Element     $element  #= The element on which the "zaction" was triggered
    EventType   $type     #= The type of the event

    DomElement  $ctrlElement #!
    DomEvent    $domEvent #!

    NEW(Element el)
      $element = el
    }
    NEW(DomElement el)
      $element = NEW(el)
    }
    NEW(DomElement actionEl, DomElement ctrlEl)
      $element = NEW(actionEl)
      $ctrlElement = ctrlEl
    }

    NEW(DomElement actionEl, DomElement ctrlEl, DomEvent event)
      $element = NEW(actionEl)
      $ctrlElement = ctrlEl
      $domEvent = event
    }

    # Returns the relevant controller.
    FUNC $getController() Controller
      Controller ctrl
      GENERATE_IF Z.lang == "JS"
>>>
   %ctrl% = %$ctrlElement%.zcontrollerInst;
<<<
      }
      RETURN ctrl
    }

    #= Returns the horizontal position (offsetX).
    #- Returns T.int.min when unknown.
    FUNC $getOffsetX() int
      int v = T.int.min
      GENERATE_IF Z.lang == "JS"
        # TODO: check if the offsetX field exists.
>>>
        if (%$domEvent%) {
          %v% = %$domEvent%.offsetX;
        }
<<<
      }
      RETURN v
    }

    SHARED
      FUNC newClickEvent(DomElement actionEl,
                         DomElement ctrlEl,
                         DomEvent event) Event
        Event e = NEW(actionEl, ctrlEl, event)
        e.type = EventType.click
        RETURN e
      }

      FUNC newKeyDownEvent(DomElement actionEl,
                           DomElement ctrlEl,
                           DomEvent event) Event
        Event e = NEW(actionEl, ctrlEl, event)
        e.type = EventType.keyDown
        RETURN e
      }

      FUNC newKeyUpEvent(DomElement actionEl,
                         DomElement ctrlEl,
                         DomEvent event) Event
        Event e = NEW(actionEl, ctrlEl, event)
        e.type = EventType.keyUp
        RETURN e
      }

      FUNC newKeyEvent(DomElement actionEl,
                       DomElement ctrlEl,
                       DomEvent event) Event
        Event e = NEW(actionEl, ctrlEl, event)
        e.type = EventType.key
        RETURN e
      }

      FUNC newMouseMoveEvent(DomElement actionEl,
                             DomElement ctrlEl,
                             DomEvent event) Event
        Event e = NEW(actionEl, ctrlEl, event)
        e.type = EventType.mouseMove
        RETURN e
      }

      FUNC newMouseOverEvent(DomElement actionEl,
                             DomElement ctrlEl,
                             DomEvent event) Event
        Event e = NEW(actionEl, ctrlEl, event)
        e.type = EventType.mouseOver
        RETURN e
      }

      FUNC newMouseOutEvent(DomElement actionEl,
                            DomElement ctrlEl,
                            DomEvent event) Event
        Event e = NEW(actionEl, ctrlEl, event)
        e.type = EventType.mouseOut
        RETURN e
      }

      FUNC newValueChangeEvent(DomElement actionEl,
                               DomElement ctrlEl,
                               DomEvent event) Event
        Event e = NEW(actionEl, ctrlEl, event)
        e.type = EventType.valueChange
        RETURN e
      }
    }
  }

  #= An interface which is used to pass information from a Controller to the
  #= object that created the DOM.
  INTERFACE I_Listener @public
    PROC $trigger(dyn info)
    }
  }

  #= Fill element |id| with the result of |template|.
  #- Can only be used in the client.
  PROC fillElement(string id, HtmlFunc template) @public
    GENERATE_IF Z.lang == "JS"
      string html = template(C(zut.context)).ToString()
>>>
      var el = $doc.getElementById(%id%);
      if (el) {
        el.innerHTML = %html%;
      }
<<<
    }
  }

  #= Set the display attribute of element |id|.
  #- When |display| is TRUE then style.display is made empty.
  #- When |display| is FALSE then style.display is set to "none".
  #
  #- Can only be used in the client.
  PROC setDisplay(string id, bool display) @public
    GENERATE_IF Z.lang == "JS"
      string value = display ? "" : "none"
>>>
      var el = $doc.getElementById(%id%);
      if (el) {
        el.style.display = %value%;
      }
<<<
    }
  }

  #= Returns wether element |id| is being displayed.
  #- When style.display is "none" FALSE is returned, otherwise TRUE.
  #
  #- When element |id| does not exist FALSE is returned.
  #
  #- Can only be used in the client.
  FUNC getDisplay(string id) bool @public
    string value
    GENERATE_IF Z.lang == "JS"
>>>
      var el = $doc.getElementById(%id%);
      if (el) {
         %value% = el.style.display;
      }
<<<
    }
    RETURN value != "none"
  }

  #= Returns the value of the selected radio button of the group |name|
  #- Returns NIL when no item with |name| can be found or none is selected.
  FUNC getRadioValue(string name) string @public
    string val
    GENERATE_IF Z.lang == "JS"
>>>
  var elements = document.getElementsByName(%name%);
  for (var i = 0; i < elements.length; i++) {
    if (elements[i].checked) {
      %val% = elements[i].value;
      break;
    }
  }
<<<
    }
    RETURN val
  }

  #= Returns the value of the first input with |name|
  #- Returns NIL when no item with |name| can be found.
  FUNC getValue(string name) string @public
    string val
    GENERATE_IF Z.lang == "JS"
>>>
  var elements = document.getElementsByName(%name%);
  if (elements.length > 0) {
    %val% = elements[0].value;
  }
<<<
    }
    RETURN val
  }

  #= Returns the location of the current page.
  #- On the server this returns NIL.
  FUNC getLocation() IO.Url @public
    IO.Url url
    GENERATE_IF Z.lang == "JS"
      string protocol
      string domain
      int port
      string path
>>>
      %protocol% = window.location.protocol;
      %domain% = window.location.hostname;
      %port% = window.location.port;
      %path% = window.location.pathname;
<<<
      url = NEW(domain, path.startsWith("/") ? path.slice(1) : path)
      url.setProtocol(protocol)
      IF port != 0
        url.setPort(port)
      }
    }
    RETURN url
  }

  #= Navigate to |url|.
  #- This replaces the current page.
  #
  #- On the server this has no effect.
  PROC navigate(IO.Url url) @public
    GENERATE_IF Z.lang == "JS"
      string s = url.ToString()
>>>
      window.open(%s%, "_self");
<<<
    }
  }

  #= Function passed to a FunctionServlet to create the HTML page.
  FUNC createPage(HTTP.Context httpContext, Page page) string @public
    Context zutContext = NEW(httpContext)
    CTX.add(zutContext)
    RETURN MainPage.page(page).ToString()
  }

  #= Gets the internal name of a controller.
  #- This is needed to uniquely identify zcontroller class names.
  #
  #- Normally the ZUT plugin generates these calls for you when it finds a
  #- "zcontroller" attribute.
  #
  #- The argument must be a class.
  #% ZUT.controllerName(ButtonController)
  FUNC controllerName(dyn f) string @public
    #! Implemented in the compiler.
    RETURN NIL
  }

  #= Registers an action on a controller.
  #- This is needed for methods that are not called directly but only from the
  #- ZUT event handling implementation.
  #
  #- Normally the ZUT plugin generates these calls for you when it finds a
  #- "zaction" attribute.
  #
  #- The argument must be a method on a class, taking a ZUt.Event argument and
  #- return a bool: func<Event => bool>
  #% ZUT.registerAction(ButtonController.clicked)
  PROC registerAction(dyn f) @public
    #! Implemented in the compiler.
  }

  int nextId #!
  string letters = "abcdefghijklmnopqrstuvwxyz0123456789" #!

  #= Return a unique ID.
  #- This will start with "z_" when used in the server, "z-" when used in the
  #- client.
  FUNC uid() string @public
    string r = ""
    int n = nextId++
    WHILE TRUE
      int idx = n % letters.Size()
      r ..= letters[idx].asString()
      n = n / letters.Size()
      IF n == 0
        BREAK
      }
      --n
    }
    # Use a separate namespace for the server and the client.
    GENERATE_IF Z.lang == "JS"
      r = "z-" .. r
    GENERATE_ELSE
      r = "z_" .. r
    }
    RETURN r
  }

  #= In the browser show an alert.  In the server log a message.
  PROC alert(string message) @public
    GENERATE_IF Z.lang == "JS"
>>>
      alert(%message%);
<<<
    GENERATE_ELSE
      LOG.info(message)
    }
  }

  #= A Timer is used to postpone a callback to be invoked.  The Timer fires
  #= once.  To trigger multiple times use an Interval.
  #- Currently only implemented for Javascript.
  CLASS Timer @public
    proc<> $callback  #!
    int    $time      #!
    int    $timeout   #!

    #= Create a new timer that will invoke |callback| after |time|
    #= milliseconds.
    #- When time is zero the callback will be invoked as soon as the current
    #- work is done.
    NEW(proc<> callback, int time) @public
      GENERATE_IF Z.lang == "C"
        LOG.error("Sorry, Timer is not yet implemented for C")
      }
      $callback = callback
      $time = time
      $start()
    }

    #= Returns the time this Timer was created with.
    FUNC $getTime() int @public
      RETURN $time
    }

    #! Internal: start a new timeout.
    PROC $start() @private
      GENERATE_IF Z.lang == "JS"
>>>
        %$timeout% = window.setTimeout(%$callback%, %$time%);
<<<
      }
    }

    #= Restart the timer.
    #- If it was pending it is cancelled first.
    PROC $restart() @public
      $cancel()
      $start()
    }

    #= Restart the timer with a new delay |time| milliseconds.
    #- If it was pending it is cancelled first.
    PROC $restart(int time) @public
      $cancel()
      $time = time
      $start()
    }

    #= Cancel the timer.
    #- If the timer already fired or was already cancelled this has no effect.
    PROC $cancel() @public
      IF $timeout != -1
        GENERATE_IF Z.lang == "JS"
>>>
           window.clearTimeout(%$timeout%);
<<<
        }
        $timeout = -1
      }
    }

    #= Cancel the timer and invoke the callback right away.
    PROC $fire() @public
      $cancel()
      $callback()
    }
  }

  #= Exception thrown when using a value in a way the result can't possibly be
  #= valid.
  CLASS E_BadValue EXTENDS E.BadValue
  }

  PROC throw(string msg) @backtrace=no @public
    THROW E_BadValue.NEW(msg)
  }

  #!
  CLASS Base @abstract @private
    IO.StringWriter $writer @protected = NEW() #!

    NEW() @public
    }

    #= Add |safeContent| to the section, it will not be escaped.
    #- USE WITH CARE: Text that is not properly escaped can create an XSS
    #- vulnerability!
    FUNC $addUNESCAPED(string safeContent) Base @default @public
      $writer.write(safeContent)
      RETURN THIS
    }

    #= Add |text| to the item.  Child class should implement this with
    #= appropriate escaping.
    FUNC $add(string text) Base @abstract @public
    }

    #= Add |number| to the item as a string.
    FUNC $add(int number) Base @default @public
      RETURN $add(number.ToString())
    }

    #= Add |number| to the item as a string.
    FUNC $add(float number) Base @default @public
      RETURN $add(number.ToString(".17g"))
    }

    #= Return the concatenated result.
    FUNC $ToString() string @public
      RETURN $writer.ToString()
    }

  }

  #= A string that is properly formatted HTML.
  #- This is used to ensure proper HTML escaping.
  CLASS Html EXTENDS Base @public @final

    #= Add |text| to the Html, it will be HTML-escaped.
    FUNC $add(string text) Base @define @public
      # HTML / string
      $writer.write(htmlEscape(text))
      RETURN THIS
    }

    #= Add |text| to the Html, it will be conservatively HTML-escaped.
    FUNC $addText(string text) Html @public
      # HTML / string
      $writer.write(htmlTextEscape(text))
      RETURN THIS
    }

    #= Add |html| to this Html. Does not apply any escaping.
    FUNC $add(Html html) Html @public
      # HTML / Html
      $writer.write(html.ToString())
      RETURN THIS
    }

    #= Add |url| to this Html.  It will show up as plain text.
    FUNC $add(Url url) Html @public
      # HTML / Url
      $writer.write(htmlEscape(url.ToString()))
      RETURN THIS
    }

    #= Inside pre and title do escape html
    PROC $addData(Html html) @public
      # HTML data / Html
      $writer.write(htmlDataHtmlEscape(html.ToString()))
    }

    #= Inside pre and title escape string like in Html.
    PROC $addData(string text) @public
      # HTML data / others
      $writer.write(htmlDataStringEscape(text))
    }

    #= Inside pre and title escape Url like in Html.
    PROC $addData(Url text) @public
      # HTML data / others
      $writer.write(htmlDataStringEscape(text.ToString()))
    }

    #= Inside a tag, add Attributes directly.
    PROC $addAttributes(Attributes attributes) @public
      # HTML attribute / Attributes
      $writer.write(attributes.ToString())
    }

    #= Inside a style tag, add CSS directly.
    PROC $addCss(Css style) @public
      # CSS / Css
      $writer.write(style.ToString())
    }

    SHARED
      #= Create a ZUT.Html object from a string that contains safe, already
      #= escaped HTML.
      #- USE WITH CARE: HTML that is not properly escaped can create an XSS
      #- vulnerability!
      FUNC fromSafeString(string safeContent) Html @public
        Html html = NEW()
        html.addUNESCAPED(safeContent)
        RETURN html
      }
    }
  }

  #= Returns |text| conservatively HTML-escaped.
  #- Replaces & with &amp;, < with &lt;, > with &gt;, NUL with &#0;.
  FUNC htmlTextEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0;    w.write("&#0;")
        CASE '&';  w.write("&amp;")
        CASE '<';  w.write("&lt;")
        CASE '>';  w.write("&gt;")
        DEFAULT;   w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| HTML-escaped.
  #- Besides what htmlTextEscape() does also replaces " with &quot;, ' with
  #- &#39; and a line break with <br>.
  FUNC htmlEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0;    w.write("&#0;")
        CASE '"';  w.write("&quot;")
        CASE '\''; w.write("&#39;")
        CASE '&';  w.write("&amp;")
        CASE '<';  w.write("&lt;")
        CASE '>';  w.write("&gt;")
        CASE '\n'; w.write("<br>")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| HTML-un-escaped.
  #- Unodes htmlEscape(), except that <br> is not changed back to a line
  #- break.
  FUNC htmlUnescape(string text) string @public
    IO.StringWriter w = NEW()
    int idx
    WHILE idx < text.Size()
      int next = text.find('&', idx)
      IF next < 0 || next + 3 >= text.Size()
        w.write(text.slice(idx))
        BREAK
      }
      SWITCH text[next + 1]
        CASE '#'
          IF text[next + 2] == '0' && text[next + 3] == ';'
            w.write(text.slice(idx, next - 1))
            w.writeChar(0)
            idx = next + 4
          ELSEIF next + 4 < text.Size() && text[next + 2] == '3'
                             && text[next + 3] == '9' && text[next + 4] == ';'
            w.write(text.slice(idx, next - 1))
            w.writeChar('\'')
            idx = next + 5
          ELSE
            idx = next + 1
          }
        CASE 'q'
          IF next + 5 < text.Size() && text[next + 2] == 'u'
                             && text[next + 3] == 'o' && text[next + 4] == 't'
                             && text[next + 5] == ';'
            w.write(text.slice(idx, next - 1))
            w.writeChar('"')
            idx = next + 6
          ELSE
            idx = next + 1
          }
        CASE 'a'
          IF next + 4 < text.Size() && text[next + 2] == 'm'
                             && text[next + 3] == 'p' && text[next + 4] == ';'
            w.write(text.slice(idx, next - 1))
            w.writeChar('&')
            idx = next + 5
          ELSE
            idx = next + 1
          }
        CASE 'l'
        CASE 'g'
          IF text[next + 2] == 't' && text[next + 3] == ';'
            w.write(text.slice(idx, next - 1))
            w.writeChar(text[next + 1] == 'l' ? '<' : '>')
            idx = next + 4
          ELSE
            idx = next + 1
          }
      }
    }
    RETURN w.ToString()
  }

  #= Returns |htmlText| HTML-data-escaped.
  #- Like htmlEscape but doesn't change & and line break.
  FUNC htmlDataHtmlEscape(string htmlText) string @public
    IO.StringWriter w = NEW()
    FOR c IN htmlText
      SWITCH c
        CASE 0; w.write("&#0;")
        CASE '"'; w.write("&quot;")
        CASE '\''; w.write("&#39;")
        CASE '<'; w.write("&lt;")
        CASE '>'; w.write("&gt;")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| HTML-data-escaped.
  #- Like htmlEscape but doesn't change &.
  FUNC htmlDataStringEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0; w.write("&#0;")
        CASE '"'; w.write("&quot;")
        CASE '\''; w.write("&#39;")
        CASE '&';  w.write("&amp;")
        CASE '<'; w.write("&lt;")
        CASE '>'; w.write("&gt;")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| when it is a valid tag name.
  #- Throws an E_BadValue exception when |text| contains an invalid character
  #- or when |text| is empty.
  #
  #- Leading and trailing white space is removed first.
  #
  #- Also throws an E_BadValue exception for "script", "style" and "title",
  #- because these require different escaping.
  FUNC tagNameEscape(string text) string @public
    string lower = text.toLowerAscii().trim()
    FOR c IN lower
      IF !c.isAlphaAscii() && !c.isDigit() && c != '-' && c != '_'
        throw("tag name contains invalid character: '\(text)'")
      }
    }

    # TODO: More tag names?
    STATIC set<string> badNames = ["script", "style", "title", ""]

    IF badNames.has(lower)
      throw("tag name cannot be used here: '\(text)'")
    }
    RETURN text.trim()  # keep the case
  }

  #= A string that is properly formatted HTML attributes.
  #- This is used to ensure proper HTML escaping.
  CLASS Attributes EXTENDS Base @public @final

    #= Add |text| to the Attributes, it will be escaped.
    FUNC $add(string text) Base @define @public
      $writer.write(attributesEscape(text))
      RETURN THIS
    }

    #= Add |attributes| to this Attributes.
    FUNC $add(Attributes attributes) Attributes @public
      # No escaping needed.
      $writer.write(attributes.ToString())
      RETURN THIS
    }

    SHARED
      #= Create a ZUT.Attributes object from a string that contains safe,
      #= already escaped HTML element attributes.
      #- USE WITH CARE: text that is not properly escaped can create an XSS
      #- vulnerability!
      FUNC fromSafeString(string safeContent) Attributes @public
        Attributes attr = NEW()
        attr.addUNESCAPED(safeContent)
        RETURN attr
      }
    }
  }

  #= Returns |text| Attributes-escaped.
  #- Only escapes & and control characters.
  FUNC attributesEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        # TODO: is this right?
        CASE '\x00'; w.write("&#0;")
        CASE '\x09'; w.write("&#9;")
        CASE '\x0a'; w.write("&#10;")
        CASE '\x0b'; w.write("&#11;")
        CASE '\x0c'; w.write("&#12;")
        CASE '\x0d'; w.write("&#13;")

        CASE '&'; w.write("&amp;")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| Attribute-value-escaped.
  #- As attributesEscape() but also escapes quotes.
  FUNC attrValueEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE '\x00'; w.write("&#0;")
        CASE '\x09'; w.write("&#9;")
        CASE '\x0a'; w.write("&#10;")
        CASE '\x0b'; w.write("&#11;")
        CASE '\x0c'; w.write("&#12;")
        CASE '\x0d'; w.write("&#13;")

        CASE '"'; w.write("&quot;")
        CASE '\''; w.write("&#39;")
        CASE '`'; w.write("&#96;")
        CASE '&'; w.write("&amp;")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |url| Attribute-value-escaped.
  #- Converts |url| to a string and then applies attrValueEscape() on it.
  FUNC attrValueEscape(Url url) string @public
    RETURN attrValueEscape(url.ToString())
  }


  #= Returns |text| Attribute-value-escaped for values not in quotes.
  #- As attrValueEscape() but also escapes white space.
  FUNC attrNoSpaceEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE '\x00'; w.write("&#0;")
        CASE '\x09'; w.write("&#9;")
        CASE '\x0a'; w.write("&#10;")
        CASE '\x0b'; w.write("&#11;")
        CASE '\x0c'; w.write("&#12;")
        CASE '\x0d'; w.write("&#13;")

        CASE ' '; w.write("&#32;")
        CASE '"'; w.write("&quot;")
        CASE '&'; w.write("&amp;")
        CASE '\''; w.write("&#39;")
        CASE '-'; w.write("&#45;")
        CASE '/'; w.write("&#47;")
        CASE '<'; w.write("&lt;")
        CASE '='; w.write("&#61;")
        CASE '>'; w.write("&gt;")
        CASE '`'; w.write("&#96;")

        CASE '\x85'; w.write("&#133;")
        CASE '\xa0'; w.write("&#160;")
        CASE '\u2028'; w.write("&#8232;")
        CASE '\u2029'; w.write("&#8233;")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |url| Attribute-unquoted-value-escaped.
  #- Converts |url| to a string and then applies attrNoSpaceEscape() on it.
  FUNC attrNoSpaceEscape(Url url) string @public
    RETURN attrNoSpaceEscape(url.ToString())
  }

  #!
  ENUM UrlState
    urlProtocol     # URL at start
    urlHead         # URL after http: or /, before ?
    urlTail         # URL after ?
    urlParamVal     # URL after param=
    urlFragment     # URL after #
  }

  #= A string that is a properly formatted URL.
  #- This is used to ensure proper URL escaping.
  CLASS Url EXTENDS Base @public @final
    UrlState           $state  #!

    PROC $Init()
      $state = UrlState.urlProtocol
    }

    #= Create a new Url with initial text |safeContent|, where the context at
    #= the end is |state|.
    NEW(string safeContent, UrlState state)
      $writer.write(safeContent)
      $state = state
    }

    #= Add |text| to the Url, it will be escaped.
    FUNC $add(string text) Base @define @public
      IF $state == UrlState.urlProtocol && ($writer.ToString() .. text)
                                      .toLowerAscii().startsWith("javascript")
        throw("Cannot use javascript: in a URL")
      ELSE
        $addUNESCAPED(urlEscape(text, $state == UrlState.urlParamVal))
      }
      RETURN THIS
    }

    #= Add |url| to the URL as-is.
    FUNC $add(Url url) Url @public
      IF $state == UrlState.urlParamVal
        # Unescape % because it will be escaped again.
        $add(urlUnEscape(url.ToString()))
      ELSE
        $addUNESCAPED(url.ToString())
      }
      RETURN THIS
    }

    #= Add |safeContent| to the section, it will not be escaped.
    #- USE WITH CARE: text that is not properly escaped can create an XSS
    #- vulnerability!
    FUNC $addUNESCAPED(string safeContent) Base @replace @public
      $writer.write(safeContent)

      # Update the state.
      int idx = 0
      byteString content = safeContent.asByteString()
      WHILE idx < content.Size()
        int byte = content[idx]
        SWITCH $state
          CASE UrlState.urlProtocol
            IF !byte.isAlphaAscii()
              $state = UrlState.urlHead
            }
          CASE UrlState.urlHead
            IF byte == '?'
              $state = UrlState.urlTail
            ELSEIF byte == '#'
              $state = UrlState.urlFragment
            }
          CASE UrlState.urlTail
            IF byte == '='
              $state = UrlState.urlParamVal
            ELSEIF byte == '#'
              $state = UrlState.urlFragment
            }
          CASE UrlState.urlParamVal
            IF byte == '&'
              $state = UrlState.urlTail
            ELSEIF byte == '#'
              $state = UrlState.urlFragment
            }
        }
        ++idx
      }
      RETURN THIS
    }

    SHARED
      #= Create a ZUT.Url object from a string that contains a safe, already
      #= escaped Url.
      #- USE WITH CARE: text that is not properly escaped can create an XSS
      #- vulnerability!
      FUNC fromSafeString(string safeContent) Url @public
        Url url = NEW()
        url.addUNESCAPED(safeContent)
        RETURN url
      }
    }
  }

  #= Apply URL-escaping to a plain text URL.
  #- See below for what replacements are done.
  #
  #- When |isParamVal| is present and TRUE, then characters with a special
  #- meaning in a parameter value, such as "=" and "&", will also be escaped.
  #
  #- This assumes using UTF-8.
  FUNC urlEscape(string text, bool isParamVal = FALSE) string
    # We read bytes, so that characters 0x80 and above become escaped UTF-8
    # bytes.
    IO.StringWriter w = NEW()
    byteString bytes = text.asByteString()
    FOR byte IN bytes
      w.write(urlEscape(byte, isParamVal))
    }
    RETURN w.ToString()
  }

  #= Apply URL-escaping to a plain text URL parameter value.
  #- See below for what replacements are done.  Additionally characters
  #- with a special meaning in a parameter value, such as "=" and "&", are
  #- escaped.
  #
  #- This assumes using UTF-8.
  FUNC urlParamValEscape(string text) string
    # We read bytes, so that characters 0x80 and above become escaped UTF-8
    # bytes.
    IO.StringWriter w = NEW()
    byteString bytes = text.asByteString()
    FOR byte IN bytes
      w.write(urlEscape(byte, TRUE))
    }
    RETURN w.ToString()
  }

  #= Turns all %xx pieces into the xx byte.
  FUNC urlUnEscape(string text) string
    IO.StringWriter w = NEW()
    byteString bytes = text.asByteString()
    int idx = 0
    WHILE idx < bytes.Size()
      int byte = bytes[idx]
      IF byte == '%' && bytes[idx + 1].isHexDigit()
                                                && bytes[idx + 2].isHexDigit()
        w.writeByte(bytes.slice(idx + 1, idx + 2).asString().hexToInt())
        idx += 2
      ELSE
        w.writeByte(byte)
      }
      ++idx
    }
    RETURN w.ToString()
  }

  #= Returns |byte| as a URL-escaped string.
  #- Returns the % form for a special character.
  #
  #- When |isParamVal| is present and TRUE, then characters with a special
  #- meaning in a parameter value, such as "=" and "&", will also be escaped.
  #
  #- Returns an empty string for a control character.
  FUNC urlEscape(int byte, bool isParamVal = FALSE) string
    SWITCH byte
      # Characters with a special meaning in a parameter value.
      CASE ';'
      CASE ','
      CASE '/'
      CASE '?'
      CASE ':'
      CASE '@'
      CASE '&'
      CASE '='
      CASE '+'
      CASE '$'
      CASE '#'
        IF isParamVal
          RETURN "%" .. byte.toHexUpper()
        }
        BREAK

      # Characters without a special meaning.
      CASE '-'
      CASE '_'
      CASE '.'
      CASE '!'
      CASE '~'
      CASE '*'
        BREAK

      DEFAULT
        IF byte.isAlphaAscii() || byte.isDigit()
          # Alpha-numeric characters can be passed as-is.
          BREAK
        }
        # Character needs escaping.
        RETURN "%" .. byte.toHexUpper()
    }
    RETURN byte.asString()
  }

  #= A string that is properly formatted CSS.
  #- This is used to ensure proper style sheet escaping.
  CLASS Css EXTENDS Base @public @final

    #= Add |text| to the Css, it will be CSS-escaped.
    FUNC $add(string text) Base @define @public
      # Css / string
      $writer.write(cssEscape(text))
      RETURN THIS
    }

    #= Add |css| to the Css, it will be added as-is.
    FUNC $add(Css css) Css @public
      # Css / Css
      $writer.write(css.ToString())
      RETURN THIS
    }

    SHARED
      #= Create a ZUT.Css object from a string that contains safe, already
      #= escaped Css.
      #- USE WITH CARE: Css that is not properly escaped can create an XSS
      #- vulnerability!
      FUNC fromSafeString(string safeContent) Css @public
        Css css = NEW()
        css.addUNESCAPED(safeContent)
        RETURN css
      }
    }
  }

  #! reduced version of what is used in the ZUT plugin.
  ENUM Ctx
    none

    css             # CSS toplevel
    cssComment      # CSS comment
    cssSQuoted      # CSS 'quoted'
    cssDQuoted      # CSS "quoted"

    javascript      # Javascript toplevel
    jsLineComment   # Javascript // comment
    jsBlockComment  # Javascript /* comment */
    jsSquotedString # Javascript 'string'
    jsDquotedString # Javascript "string"
    jsRegexp        # Javascript /regexp/
  }

  #= Returns |text| and throws an error for missing quotes, "</", etc.
  FUNC cssEscape(string text) string @public
    Ctx context = Ctx.css
    FOR idx IN 0 UNTIL text.Size()
      int c = text[idx]
      SWITCH c
        CASE 0;    throw("NUL character in '\(text)'")
        CASE '\''; IF context == Ctx.css
                     context = Ctx.cssSQuoted
                   ELSEIF context == Ctx.cssSQuoted
                     context = Ctx.css
                   }
        CASE '"';  IF context == Ctx.css
                     context = Ctx.cssDQuoted
                   ELSEIF context == Ctx.cssDQuoted
                     context = Ctx.css
                   }
        CASE '\n'; IF context == Ctx.cssSQuoted
                     throw("unterminated single quoted string in '\(text)'")
                   ELSEIF context == Ctx.cssDQuoted
                     throw("unterminated double quoted string in '\(text)'")
                   }
        CASE '<';  IF idx + 1 < text.Size() && text[idx + 1] == '/'
                     # TODO: not inside a string?
                     throw("found </ in '\(text)'")
                   }
        CASE '\\'; ++idx
                   IF idx == text.Size()
                      throw("trailing backslash in '\(text)'")
                   }
                   c = text[idx]
                   IF c == 0
                     throw("NUL character in '\(text)'")
                   }
                   IF c == '\n'
                      throw("trailing backslash in '\(text)'")
                   }
        CASE '/';  IF context == Ctx.css && idx + 1 < text.Size()
                                                       && text[idx + 1] == '*'
                     context = Ctx.cssComment
                     ++idx
                   }
        CASE '*';  IF context == Ctx.cssComment && idx + 1 < text.Size()
                                                       && text[idx + 1] == '/'
                     context = Ctx.css
                     ++idx
                   }
      }
    }
    IF context == Ctx.cssSQuoted
      throw("unterminated single quoted string in '\(text)'")
    ELSEIF context == Ctx.cssDQuoted
      throw("unterminated double quoted string in '\(text)'")
    ELSEIF context == Ctx.cssComment
      throw("unterminated comment in '\(text)'")
    }
    RETURN text
  }

  #= Returns |url| CSS-string-escaped for single quotes.
  FUNC cssSingleStringEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0;    BREAK
        CASE '\''; w.write("\\'")
        CASE '\n'; w.write("\\a")
        CASE '\\'; w.write("\\\\")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| Css-string-escaped for double quotes.
  FUNC cssDoubleStringEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0;    BREAK
        CASE '"'; w.write("\\\"")
        CASE '\n'; w.write("\\a")
        CASE '\\'; w.write("\\\\")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| Css-comment-escaped for a /* comment
  FUNC cssCommentEscape(string text) string @public
    # Same as for javascript
    RETURN javascriptBlockCommentEscape(text)
  }

  #= Returns |text| Css-comment-escaped for a /* comment
  FUNC cssCommentEscape(dyn text) string @public
    # Same as for javascript
    RETURN javascriptBlockCommentEscape(text.ToString())
  }

  #= A string that is properly formatted Javascript.
  #- This is used to ensure proper Javascript escaping.
  CLASS Javascript EXTENDS Base @public @final

    #= Add |js| to the Javascript, it will be escaped as needed.
    FUNC $add(string js) Base @define @public
      # Javascript / string
      $writer.write(javascriptEscape(js))
      RETURN THIS
    }

    #= Add |js| to the Javascript, it will be added as-is.
    FUNC $add(Javascript js) Javascript @public
        # Javascript / Javascript
      $writer.write(js.ToString())
      RETURN THIS
    }

    SHARED
      #= Create a ZUT.Javascript object from a string that contains safe,
      #= already escaped Javascript.
      #- USE WITH CARE: Javascript that is not properly escaped can create an
      #- XSS vulnerability!
      FUNC fromSafeString(string safeContent) Javascript @public
        Javascript js = NEW()
        js.addUNESCAPED(safeContent)
        RETURN js
      }

      #= Inside a script tag, escape a string.
      FUNC toSafeString(string js) string @public
        # Javascript / string
        RETURN javascriptEscape(js)
      }

      #= Inside a script tag, add an int.
      FUNC toSafeString(int nr) string @public
        # Javascript / int
        RETURN nr.ToString()
      }

      #= Inside a script tag, add a float.
      FUNC toSafeString(float nr) string @public
        # Javascript / float
        RETURN nr.ToString()
      }

      #= Inside a script tag, add Javascript directly.
      FUNC toSafeString(Javascript js) string @public
        # Javascript / Javascript
        RETURN js.ToString()
      }

    }
  }

  #= Returns |text| and throws an error for missing quotes, "</", etc.
  FUNC javascriptEscape(string text) string @public
    Ctx context = Ctx.javascript
    FOR idx IN 0 UNTIL text.Size()
      int c = text[idx]
      SWITCH c
        CASE 0;    throw("NUL character in '\(text)'")
        CASE '\''; IF context == Ctx.javascript
                     context = Ctx.jsSquotedString
                   ELSEIF context == Ctx.jsSquotedString
                     context = Ctx.javascript
                   }
        CASE '"';  IF context == Ctx.javascript
                     context = Ctx.jsDquotedString
                   ELSEIF context == Ctx.jsDquotedString
                     context = Ctx.javascript
                   }
        CASE '\n'; IF context == Ctx.jsSquotedString
                     throw("unterminated single quoted string in '\(text)'")
                   ELSEIF context == Ctx.jsDquotedString
                     throw("unterminated double quoted string in '\(text)'")
                   ELSEIF context == Ctx.jsLineComment
                     context = Ctx.javascript
                   }
        CASE '<';  IF idx + 1 < text.Size() && text[idx + 1] == '/'
                     # TODO: not inside a string?
                     throw("found </ in '\(text)'")
                   }
        CASE '\\'; ++idx
                   IF idx == text.Size()
                      throw("trailing backslash in '\(text)'")
                   }
                   c = text[idx]
                   IF c == 0
                     throw("NUL character in '\(text)'")
                   }
                   IF c == '\n'
                      throw("trailing backslash in '\(text)'")
                   }
        CASE '/';  IF context == Ctx.javascript && idx + 1 < text.Size()
                     IF text[idx + 1] == '*'
                       context = Ctx.jsBlockComment
                       ++idx
                     ELSEIF text[idx + 1] == '/'
                       context = Ctx.jsLineComment
                       ++idx
                     ELSEIF !text[idx + 1].isWhite()
                       context = Ctx.jsRegexp
                       ++idx
                     }
                   ELSEIF context == Ctx.jsRegexp
                     context = Ctx.javascript
                   }
        CASE '*';  IF context == Ctx.jsBlockComment && idx + 1 < text.Size()
                                                       && text[idx + 1] == '/'
                     context = Ctx.javascript
                     ++idx
                   }
      }
    }
    IF context == Ctx.jsSquotedString
      throw("unterminated single quoted string in '\(text)'")
    ELSEIF context == Ctx.jsDquotedString
      throw("unterminated double quoted string in '\(text)'")
    ELSEIF context == Ctx.jsRegexp
      throw("unterminated /regexp/ in '\(text)'")
    ELSEIF context == Ctx.jsBlockComment
      throw("unterminated /* comment in '\(text)'")
    ELSEIF context == Ctx.jsLineComment
      throw("unterminated // comment in '\(text)'")
    }
    RETURN text
  }

  #= Returns |url| Javascript-string-escaped for single quotes.
  FUNC javascriptSingleStringEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0;    BREAK
        CASE '\''; w.write("\\'")
        CASE '\n'; w.write("\\n")
        CASE '\\'; w.write("\\\\")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |url| Javascript-string-escaped for single quotes.
  FUNC javascriptSingleStringEscape(Url url) string @public
    RETURN javascriptSingleStringEscape(url.ToString())
  }

  #= Returns |text| Javascript-string-escaped for double quotes.
  FUNC javascriptDoubleStringEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0;    BREAK
        CASE '"'; w.write("\\\"")
        CASE '\n'; w.write("\\n")
        CASE '\\'; w.write("\\\\")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |url| Javascript-string-escaped for double quotes.
  FUNC javascriptDoubleStringEscape(Url url) string @public
    RETURN javascriptDoubleStringEscape(url.ToString())
  }

  #= Returns |text| Javascript-string-escaped for a regular expression.
  FUNC javascriptRegexpEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0;    BREAK
        CASE '/'; w.write("\\/")
        CASE '\n'; w.write("\\n")
        CASE '\\'; w.write("\\\\")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| Javascript-string-escaped for a regular expression.
  FUNC javascriptRegexpEscape(Url url) string @public
    RETURN javascriptRegexpEscape(url.ToString())
  }

  #= Returns |text| Javascript-comment-escaped for a // comment
  FUNC javascriptLineCommentEscape(string text) string @public
    IO.StringWriter w = NEW()
    FOR c IN text
      SWITCH c
        CASE 0;    BREAK
        CASE '\n'; w.write("\n//")

        DEFAULT;  w.writeChar(c)
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| Javascript-comment-escaped for a // comment
  FUNC javascriptLineCommentEscape(dyn text) string @public
    RETURN javascriptLineCommentEscape(text.ToString())
  }

  #= Returns |text| Javascript-comment-escaped for a /* comment
  FUNC javascriptBlockCommentEscape(string text) string @public
    IO.StringWriter w = NEW()
    bool hadStar
    FOR c IN text
      SWITCH c
        CASE 0;    BREAK
        CASE '*';  hadStar = TRUE
                   w.writeChar('*')
        CASE '/';  IF hadStar
                     w.writeChar(' ')
                   }
                   w.writeChar('/')
                   hadStar = FALSE

        DEFAULT;  w.writeChar(c)
                  hadStar = FALSE
      }
    }
    RETURN w.ToString()
  }

  #= Returns |text| Javascript-comment-escaped for a /* comment
  FUNC javascriptBlockCommentEscape(dyn text) string @public
    RETURN javascriptBlockCommentEscape(text.ToString())
  }
}
